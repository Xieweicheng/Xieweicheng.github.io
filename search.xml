<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（七）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%83%EF%BC%89.html</url>
    <content type="text"><![CDATA[第五部分 高效并发第十二章 Java内存模型与线程一. 概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了； 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景； 服务端是 Java 语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好Java语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少； 二. 硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了； 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等； 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性； 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 三. Java 内存模型Java虚拟机规范中视图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 1. 主内存和工作内存 Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享； Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的Java内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 2. 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量的某些操作在某些平台允许有例外）： lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但lock操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。 3. 对于 volatile 型变量的特殊规则 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制； 当一个变量定义为 volatile 之后，它将具备两种特性： 第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成； 另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics） volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的； 在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性： 运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束； volatile 变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求； 4. 对于 long 和 double 型变量的特殊规则 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的 load、store、read 和 write 这4个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定； 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待； 5. 原子性、可见性与有序性 原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write；在 synchronized 块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了 volatile 之外，Java 还有 synchronized 和 final 关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象；Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性； 6. 先行发生原则 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作B之前，操作 A 产生的影响能被操作 B 观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是 Java 内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile 变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 四. Java 与线程1. 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模式就是一对一的； 2. Java线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java语言一共设置了 10 个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与 Java 线程的优先级一一对应，另外优先级还可能被系统自行改变； 3. 状态转换 Java语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 五. 本章小结本章我们首先了解了虚拟机 Java 内存模型的结构及操作，然后讲解了原子性、可见性、有序性在 Java 内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在 Java 语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第十三章 线程安全与锁优化一. 概述 首先需要保证并发的正确性，然后在此基础上实现高效； 二. 线程安全Brian Goetz 对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 1. Java语言中的线程安全 我们可以将Java语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变带来的安全性是最简单和最纯粹的，如final的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的 substring、replace 方法；Number 类型的大部分子类都符合不可变要求的类型，但是 AtomicInteger 和 AtomicLong 则并非不可变的； 线程绝对安全：Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如 java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了； 线程相对安全：是我们通常意义上所讲的线程安全，在 Java 语言中，大部分的线程安全类都属于这种类型； 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况； 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java语言中很少出现； 2. 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java中最基本的互斥同步手段就是synchronized关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，相比 synchronized 关键字 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java并发包的整数原子类，其中的 compareAndSet 和 getAndIncrement 等方法都使用了 Unsafe 类的 CAS 操作； 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码； 三. 锁优化1. 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁； 在 JDK 1.6 已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在 JDK 1.6 中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 2. 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 3. 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 4. 轻量级锁 轻量级锁是 JDK 1.6 之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗； 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象的内存布局开始介绍； HotSpot 虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄等，这部分官方称之为 Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word 被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC标志、可偏向）下对象的存储内容如下： 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的 Mark Word 的拷贝（官方称之为Displaced Mark Word）；然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位将转变为“00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据； 5. 偏向锁 偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式；同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 之中；如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象Mark Work的关系如下图所示： 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 四. 本章小结本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（六）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%85%AD%EF%BC%89.html</url>
    <content type="text"><![CDATA[第四部分 程序编译与代码优化第十章 早期（编译期）优化一. 概述Java 语言的“编译器”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（编译器的前端）把 .java 文件转变成 .class 文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器代码的过程。 前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ） JIT编译器：HotSpot VM 的 C1、C2 编译器 AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET 二. Javac 编译器Javac 是由 java 进行编写的，编译过程大致可以分为三个过程： 解析与填充符号表过程 插入式注解处理器的注解处理过程 分析与字节码生成过程 以下为 Javac 编译过程的主体代码 1. 解析与填充符号表过程词法、语法分析 词法分析：是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如 int a=b+2这句代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个Token，不可再拆分。在Javac的源码中，词法分析过程由 com.sun.tools.javac.parser.Scanner 类来实现。 语法分析：是根据 Token 序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。在Javac的源码中，语法分析过程由 com.sun.tools.javac.parser.Parser 类实现，这个阶段产出的抽象语法树由 com.sun.tools.javac.tree.JCTree 类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。 填充符号表 完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是上图中 enterTrees() 方法（上图中的过程1.2）所做的事情。符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，读者可以把它想象成哈希表中K-V值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。 在 Javac 源代码中，填充符号表的过程由 com.sun.tools.javac.comp.Enter 类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及 package-info.java（如果存在的话）的顶级节点。 2. 注解处理器在JDK 1.5之后，Java 语言提供了对注解（Annotation）的支持，这些注解与普通的 Java 代码一样，是在运行期间发挥作用的。在JDK 1.6中实现了 JSR-269 规范，提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个 Round，也就是上图（Javac 编译过程的主体代码）的回环过程。 有了编译器注解处理的标准 API 后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器的简单实战。 在Javac源码中，插入式注解处理器的初始化过程是在 initPorcessAnnotations() 方法中完成的，而它的执行过程则是在 processAnnotations() 方法中完成的，这个方法判断是否还有新的注解处理器需要执行，如果有的话，通过 com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing() 方法生成一个新的 JavaCompiler 对象对编译的后续步骤进行处理。 3. 语义分析与字节码生成语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。如下： 1234567int a = 1;boolean b = false;char c = 2;// 只有第一种的写法在语义上是没有问题的，能够通过编译，其余两种在 Java 语言中是不合逻辑的，无法编译。int d = a + c;int d = b + c;char d = a + c; Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别由上图（Javac 编译过程的主体代码）中所示的 attribute() 和 flow() 方法完成。 标注检查 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代码中写了如下定义：int a = 1 + 2。那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”。 标注检查步骤在Javac源码中的实现类是 com.sun.tools.javac.comp.Attr 类和 com.sun.tools.javac.comp.Check 类。 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。 数据及控制流分析步骤在Javac源码中的实现类是 由com.sun.tools.javac.comp.Flow 类。 解语法糖 Java 中最常用的语法糖主要是前面提到过的泛型（泛型并不一定都是语法糖实现，如 C# 的泛型就是直接由 CLR 支持的）、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。 解语法糖的过程由 desugar()方法触发，在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成。 字节码生成 字节码生成是Javac编译过程的最后一个阶段，在 Javac 源码里面由 com.sun.tools.javac.jvm.Gen 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 例如，前面章节中多次提到的实例构造器 &lt;init&gt;() 方法和类构造器 &lt;clinit&gt;() 方法就是在这个阶段添加到语法树之中的（注意，这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、访问性（public、protected 或 private）与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是 “static{}” 块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器， &lt;clinit&gt;() 方法中无须调用父类的 &lt;clinit&gt;()方法，虚拟机会自动保证父类构造器的执行，但在 &lt;clinit&gt;() 方法中经常会生成调用 java.lang.Object 的 &lt;init&gt;() 方法的代码）等操作收敛到 &lt;init&gt;() 和 &lt;clinit&gt;() 方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，上面所述的动作由 Gen.normalizeDefs() 方法来实现。除了生成构造器以外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为 StringBuffer 或 StringBuilder（取决于目标代码的版本是否大于或等于 JDK 1.5）的 append() 操作等。 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给 com.sun.tools.javac.jvm.ClassWriter 类，由这个类的 writeClass() 方法输出字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。 三. Java 语法糖的味道几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用“含糖”的语法，容易让程序员产生依赖，无法看清语法糖的糖衣背后，程序代码的真实面目。 总而言之，语法糖可以看做是编译器实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们所迷惑。 1. 泛型与类型擦除泛型是 JDK 1.5 的一项新增特性，它的本质是参数化类型（Parametersized Type）的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。 Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的 Java 语言来说，ArrayList&lt;Integer&gt; 与 ArrayList&lt;String&gt; 就是同一个类，所以泛型技术实际上是 Java 语言的一颗语法糖，Java 语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 以下两个方法由于类型擦除的原因，导致无法重载： 1234public void fun(List&lt;Integer&gt; xx) &#123;&#125;public void fun(List&lt;String&gt; xx) &#123;&#125; 2. 自动装箱、拆箱与遍历循环以下包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖 123456List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);int sum = 0;for (int i : list) &#123; sum += i;&#125;System.out.println(sum); 自动装箱、拆箱与遍历循环编译之后 1234567891011List list = Arrays.asList(new Integer[]&#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4)&#125;);int sum = 0;for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123; int i = ((Integer) localIterator.next()).intValue(); sum += i;&#125;System.out.println(sum); 自动装箱的陷阱：包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱，以及它们 equals() 方法不处理数据转型的关系 12345678910111213Integer a = 1;Integer b = 2;Integer c = 3;Integer d = 3;Integer e = 127;Integer f = 127;Long g = 3L;System.out.println(c == d); // trueSystem.out.println(e == f); // trueSystem.out.println(c == (a + b)); // trueSystem.out.println(c.equals(a + b)); // trueSystem.out.println(g == (a + b)); // trueSystem.out.println(g.equals(a + b)); // false 3. 条件编译使用条件为常量的 if 语句，如下： 12345if (true) &#123; System.out.println("block 1"); &#125; else &#123; System.out.println("block 2");&#125; 编译后会变为： 1System.out.println("block 1"); 四. 本章小结在本章中，我们从编译器源码实现的层次上了解了 Java 源代码编译为字节码的过程，分析了 Java 语言中泛型、主动装箱/拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。如本章概述中所说的那样，在前端编译器中，“优化”手段主要用于提升程序的编码效率，之所以把 Javac 这类将 Java 代码转变为字节码的编译器称做“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的“后端编译器”完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或JIT编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。在第 11 章中，我们将会介绍即时编译器的运作和优化过程。 第十一章 晚期（运行期）优化一. 概述在部分的商用虚拟机（Sun HotSpot、IBM J9）中，Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。 二. HotSpot虚拟机内的即时编译器1. 解释器与编译器主流的商用虚拟机都同时包含解释器和编译器。 解释器和编译器各有优势： 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。 在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率。 当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。 同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器[2])担任“逃生门”的角色），因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作 HotSpot 虚拟机内置了两个即时编译器，分别为： Client Compiler（C1 编译器） Server Compiler（C2 编译器） HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式 混合模式：无论采用 C1 还是 C2，解释器与编译器搭配使用的方式 解释模式：-Xint 强制只使用解释器 编译模式：-XComp 优先采用编译方式执行，但是解释器仍然要在编译无法进行的情况下介入执行过程。 分层编译策略 由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）的策略。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括： 第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。 第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。 2.编译对象与触发条件在运行过程中会被即时编译器编译的“热点代码”有两类，即： 被多次调用的方法 被多次执行的循环体 以上两种情况都会以整个方法作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。 热点探测 判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection），其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主要的热点探测判定方式有两种，分别如下： 基于采样的热点探测（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。 基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确和严谨。（HotSpot使用这种热点探测） 基于计数器的热点探测 该热点探测准备了两类计数器，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译，分别为： 方法调用计数器：统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10 000 次，这个阈值可以通过虚拟机参数 -XX：CompileThreshold 来人为设定 回边计数器：统计一个方法中循环体代码执行的次数 三. 编译优化技术 1. 公共子表达式消除123456// 其中 b * c 为公共子表达式int d = (c * b) * 12 + a + (a + b * c);// 会优化为int d = E * 12 + a + (a + E)// 也可能优化为int d = E * 13 + a * 2 2. 数组边界检查消除对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。解决方案如下： 把运行期检查提前到编译期完成，通过语义，断定不会异常的就不检查。 隐式异常处理，直接访问，然后捕获 segment_fault，转化抛出该抛的异常。 3. 方法内联把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用。 非虚方法（invokespecial 指令调用的私有方法、实例构造器、父类方法以及使用 invokestatic 指令进行调用的静态方法，Final 方法）会在编译期，进行内联 虚方法由于在编译期无法确认指向，虚拟机设计团队引入了“类型继承关系分析”（Class Hierarchy Analysis，CHA）技术去解决这个问题。在许多情况下虚拟机进行的内联都是一种激进优化 4. 逃逸分析它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。 甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化，如下所示： 栈上分配（Stack Allocation）：Java 虚拟机中，在Java堆上分配创建对象的内存空间几乎是 Java 程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。 同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。 标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java 虚拟机中的原始数据类型（int、long 等数值类型以及 reference 类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它就称作聚合量（Aggregate），Java 中的对象就是最典型的聚合量。如果把一个 Java 对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。 四. Java 与 C/C++ 的编译器对比Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势（下面列举的也包括一些虚拟机执行子系统的性能劣势）： 第一，因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。如果编译速度不能达到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。 第二，Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须频繁地进行动态检查，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。 第三，Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化（如前面提到的方法内联）时的难度要远大于C/C++的静态优化编译器。 第四，Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。 第五，Java语言中对象的内存分配都是堆上进行的，只有方法中的局部变量才能在栈上分配。而C/C++的对象则有多种内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅指运行效率，排除了开发效率）也比垃圾收集机制要高。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（五）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%94%EF%BC%89.html</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第七章 虚拟机类加载机制一. 概述 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。 二. 类加载的时机 类的整个生命周期：加载（Loading），验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、解析 3 个部分统称为连接（Linking）。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定） 虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有5种情况必须立即对类进行初始化： 遇到 new、getstatic、putstatic 和 invokestatic 指令； 对类进行反射调用时如果类没有进行过初始化； 初始化时发现父类还没有进行初始化； 虚拟机启动指定的主类； 动态语言中 MethodHandle 实例最后解析结果 REF_getStatic、REF_putStatic 和 REF_invokeStatic 等的方法句柄对应的类没有初始化时； 三. 类的加载过程1. 加载 通过一个类的全限定名来获取定义此类的二进制字节流（zip 包获取，网络获取，反射运行时计算生成，jps，数据库获取等） 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 2. 验证 验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 验证阶段是非常重要的，这个阶段是否严谨决定了Java虚拟机是否能承受恶意代码的攻击； 校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）； 3. 准备 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配； 需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是static final的则是直接赋值； 数据类型 零值 int 0 long 0L short (short)0 char ‘\u0000’ byte (byte)0 boolean false float 0.0f double 0.0d reference null 4. 解析 解析阶段是虚拟机将常量池内的符号引用（如CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等7种）替换为直接引用的过程； 符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在； 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存； 5. 初始化 是类加载过程的最后一步，真正开始执行类中定义的Java程序代码（或者说是字节码）； 初始化阶段是执行类构造器方法&lt;clinit&gt;()的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问； &lt;clinit&gt;()方法与类的构造函数（或者说是实例构造器方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已执行完毕； 执行接口的方法不需要先执行父接口的方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的方法； &lt;clinit&gt;()方法初始化是加锁阻塞等待的，应当避免在&lt;clinit&gt;()方法中有耗时很长的操作； 四. 类加载器 虚拟机设计团队把类加载阶段的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器； 这时 Java 语言的一项创新，也是Java语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩； 1. 类与类加载器 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间； 比较两个类是否相等（如 Class 对象的 equal s方法、isAssignableFrom 方法、isInstance 方法），只有在这两个类是由同一个类加载器加载的前提下才有意义； 2. 双亲委派模型 从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader； 从 Java 开发人员角度来讲，有三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）； 双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码； 其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载； 这样的好处是 Java 类随着它的类加载器具备了一种带有优先级的层次关系，对保证 Java 程序的稳定运作很重要； 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中，逻辑清晰易懂； 3. 破坏双亲委派模型 上一小节的双亲委派模型是Java设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型； 典型的两种情况：为了解决JNI接口提供者（SPI）引入的线程上下文类加载器（Thread Context ClassLoader），该类加载器可以通过 java.lang.Thread 的 setContextClassLoader() 方法进行设置；为了程序动态性加强的 OSGI 的 Bundle 类加载器； 五. 本章小姐本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在 Class 文件里的字节码。 第八章 虚拟机字节码执行引擎一. 概述 执行引擎是Java虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式； 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观； 在不同的虚拟机实现里面，执行引擎在执行Java代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 二. 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素； 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程； 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的 Code 属性之中了，不会受到程序运行期变量数据的影响； 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作； 1. 局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code 属性的 max_locals 确定了该方法所需要分配的局部变量表的最大容量； 其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许 Slot 的长度随处理器、操作系统或虚拟机的不同而发生变化； 一个 Slot 可以存放一个 32位 以内的数据类型，包括boolean、byte、char。short、int、float、 reference 和 returnAddress 这八种类型；对于 64 位的数据类型（long 和 double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间 2. 操作数栈 也常称为操作栈，它是一个后入先出栈；Code 属性的 max_stacks 确定了其最大深度； 比如整数加法的字节码指令 iadd 在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会将这两个 int 值出栈并相加，然后将相加的结果入栈； 操作数栈中元素的类型必须与字节码指令的序列严格匹配； Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”，其中所指的栈就是操作数栈； 3. 动态连接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）； Class 文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接； 4. 方法返回地址 退出方法的方式：正常完成出口和异常完成出口； 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整 PC 计数器的值以只需方法调用指令后面的一套指令等； 5. 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现； 三. 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程； Class 文件的编译过程中不包含传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂； 1. 解析 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析； 在Java语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类； 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic； 只要能被 invokestatic、invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，包含静态方法、私有方法、实例构造器、父类方法四类，在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以被称为非虚方法（包含 final 方法），相反其他称为虚方法； 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的； 2. 分派 静态分派：Human man = new Man();语句中 Human 称为变量的静态类型，后面的 Man 称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载； 动态分派：invokevirtual 指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派； 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的Java语言是一门静态多分派、动态单分派的语言； 虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕； 3. 动态类型语言支持 JDK 1.7发布增加的 invokedynamic 指令实现了“动态类型语言”支持，也是为JDK 1.8顺利实现 Lambda 表达式做技术准备； 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如 JavaScript、Python 等； Java 语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到 Class 文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在 ECMAScript 等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征； JDK 1.7 实现了 JSR-292，新加入的 java.lang.invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为 MethodHandle； 从本质上讲，Reflection（反射）和 MethodHandle 机制都是在模拟方法调用，但 Reflection 是在模拟 Java 代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为Java语言服务，后者可服务于所有 Java 虚拟机之上的语言； 每一处含有 invokedynamic 指令的位置都称为“动态调用点(Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的 CONSTANT_Methodref_info 常量，而是 CONSTANT_InvokeDynamic_info 常量（可以得到引导方法、方法类型和名称）； invokedynamic 指令与其他 invoke 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的； 四. 基于栈的字节码解释执行引擎上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。 1. 解释执行 只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切； Java 语言中，javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现； 2. 基于栈的指令集与基于寄存器的指令集 Java 编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作； 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点；` 3. 基于栈的解释器执行过程一段简单的算法代码 123456public int calc() &#123; int a = 100; int b = 200; int c = 300; return (a + b) * c;&#125; 上述代码的字节码表示 1234567891011121314public int calc();Code:Stack=2, Locals=4, Args_size=10:bipush 1002:istore_13:sipush 2006:istore_27:sipush 30010:istore_311:iload_112:iload_213:iadd14:iload_315:imul16:ireturn javap 提示这段代码需要深度为 2 的操作数栈和 4 个 Slot 的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况： 执行偏移地址为 0 的指令 执行偏移地址为 2 的指令 执行偏移地址为 11 的指令 执行偏移地址为 12 的指令 执行偏移地址为 13 的指令 执行偏移地址为 14 的指令 执行偏移地址为 16 的指令 注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。 五. 本章小结本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对 Java 程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。 第九章 类加载及执行子系统的案例与实战一. 概述 在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多； 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路； 二. 案例分析1. Tomcat：正统的类加载器架构 Java Web 服务器：部署在同一个服务器上的两个 Web 应用程序所使用的Java类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的Web应用程序影响；要支持JSP生成类的热替换； 上图中，灰色背景的三个类加载器是JDK默认提供的类加载器，而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader 是 Tomcat 自己定义的类加载器，分别加载 /common/*（可被Tomcat和Web应用共用）、/server/*（可被Tomcat使用）、/shared/*（可被Web应用使用）和 /WebApp/WEB-INF/*（可被当前Web应用使用）中的 Java 类库，Tomcat 6.x 把前面三个目录默认合并到一起变成一个 /lib 目录（作用同原先的 common 目录）； 2. OSGI：灵活的类加载架构 OSGI 的每个模块称为 Bundle，可以声明它所依赖的 Java Package（通过 Import-Package 描述），也可以声明它允许导出发布的 Java Package（通过 Export-Package 描述）； 除了更精确的模块划分和可见性控制外，引入 OSGI 的另外一个重要理由是基于 OSGI 的程序很可能可以实现模块级的热插拔功能； OSGI 的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患； 3. 字节码生成技术与动态代理的实现 在 Java 里面除了 javac 和字节码类库外，使用字节码生成的例子还有 Web 服务器中的 JSP 编译器、编译时植入的 AOP 框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的； 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中； 以下的例子中生成的代理类 $Proxy0.class 文件可以看到代理为传入接口的每一个方法统一调用了 InvocationHandler 对象的 invoke 方法；其生成代理类的字节码大致过程其实就是根据 Class 文件的格式规范去拼接字节码； 123456789101112131415161718192021222324252627282930313233343536public class DynamicProxyTest &#123; interface IHello &#123; void sayHello(); &#125; static class Hello implements IHello &#123; @Override public void sayHello() &#123; System.out.println("Hello world"); &#125; &#125; static class DynamicProxy implements InvocationHandler &#123; Object originalObj; Object bind(Object originalObj) &#123; this.originalObj = originalObj; return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("Welcome"); return method.invoke(originalObj, args); &#125; &#125; public static void main(String[] args) &#123; // add this property to generate proxy class file System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); IHello hello = (IHello) new DynamicProxy().bind(new Hello()); hello.sayHello(); &#125;&#125; 4. Retrotranslator：跨越JDK版本 Retrotranslator的作用是将JDK 1.5编译出来的Class文件转变为可以在JDK 1.4或JDK 1.3部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作； JDK升级通常包括四种类型：编译器层面的做的改进、Java API的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator只能模拟前两类，第二类通过独立类库实现，第一类则通过ASM框架直接对字节码进行处理； 三. 实战：自己动手实现远程执行功能 目标：不依赖JDK版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端； 思路：如何编译提交到服务器的 Java 代码（客户端编译好上传 Class 文件而不是 Java 代码）、如何执行编译之后的Java代码（要能访问其他类库，要能卸载）、如何收集Java代码的执行结果（在执行的类中把 System.out 的符号引用替换为我们准备的 PrintStream 的符号引用）； 具体实现：HotSwapClassLoader 用于实现同一个类的代码可以被多次加载，通过公开父类 ClassLoader 的 defineClass 实现； HackSystem 是为了替换 java.lang.System，它直接修改 Class 文件格式的 byte[] 数组中的常量池部分，将常量池中指定内容的 CONSTANT_Utf8_info 常量替换为新的字符串；ClassModifier涉及对 byte[] 数组操作的部分，主要是将byte[]与int和String互相转换，以及把对 byte[] 数据的替换操作封装在 ByteUtils 类中；经过 ClassModifier 处理过的 byte[] 数组才会传给 HotSwapClassLoader.loadByte 方法进行类加载；而 JavaClassExecutor 是提供给外部调用的入口； 123456789101112131415161718public class JavaClassExecutor &#123; public static String execute(byte[] classByte) &#123; HackSystem.clearBuffer(); ClassModifier cm = new ClassModifier(classByte); byte[] modifiedBytes = cm.modifyUTF8Constant("java/lang/System", "org/fenixsoft/classloading/execute/HackSystem"); HotSwapClassLoader hotSwapClassLoader = new HotSwapClassLoader(); Class clazz = hotSwapClassLoader.loadByte(modifiedBytes); try &#123; Method method = clazz.getMethod("main", new Class[]&#123;String[].class&#125;); method.invoke(null, new String[]&#123;null&#125;); &#125; catch (Throwable t) &#123; t.printStackTrace(HackSystem.out); &#125; return HackSystem.getBufferString(); &#125;&#125; 用于测试的JSP 123456789101112&lt;%@page import="java.lang.*" %&gt;&lt;%@page import="java.io.*" %&gt;&lt;%@page import="org.fenixsoft.classloading.execute.*" %&gt;&lt;%InputStream is = new FileInputStream("c:/TestClass.class");byte[] b = new byte[is.available()];is.read(b);is.close();out.println(JavaClassExecutor.execute(b));%&gt; 四. 本章小结只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（四）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89.html</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第六章 类文件结构代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步 由于最近10年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 一. 无关性的基石 Java刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。 字节码（ByteCode）是构成平台无关的基石； 另外虚拟机的语言无关性也越来越被开发者所重视，JVM设计者在最初就考虑过实现让其他语言运行在Java虚拟机之上的可能性，如今已发展出一大批在JVM上运行的语言，比如Clojure、Groovy、JRuby、Jython、Scala； 实现语言无关性的基础仍是虚拟机和字节码存储格式，Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行。 Java虚拟机提供的语言无关性 二. Class类文件的结构 Class文件是一组以8个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符； Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表； 无符号数属于基本的数据类型，以u1、u2、u4和u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值； 表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以“_info”结尾； 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attributes_count 1 attribute_info attributes attributes_count 实操：TestClass.java 1234567package org.fenixsoft.clazz;public class TestClass &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 编译 TestClass.java 得到 TestClass.class，内容如下（这里使用 Sublime Text 3 的 16 进制插件查看） 1234567891011121300000000: cafe babe 0000 0034 0013 0a00 0400 0f09 0003 0010 0700 1107 :.......4................00000018: 0012 0100 016d 0100 0149 0100 063c 696e 6974 3e01 0003 2829 :.....m...I...&lt;init&gt;...()00000030: 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 :V...Code...LineNumberTab00000048: 6c65 0100 0369 6e63 0100 0328 2949 0100 0a53 6f75 7263 6546 :le...inc...()I...SourceF00000060: 696c 6501 000e 5465 7374 436c 6173 732e 6a61 7661 0c00 0700 :ile...TestClass.java....00000078: 080c 0005 0006 0100 1d6f 7267 2f66 656e 6978 736f 6674 2f63 :.........org/fenixsoft/c00000090: 6c61 7a7a 2f54 6573 7443 6c61 7373 0100 106a 6176 612f 6c61 :lazz/TestClass...java/la000000a8: 6e67 2f4f 626a 6563 7400 2100 0300 0400 0000 0100 0200 0500 :ng/Object.!.............000000c0: 0600 0000 0200 0100 0700 0800 0100 0900 0000 1d00 0100 0100 :........................000000d8: 0000 052a b700 01b1 0000 0001 000a 0000 0006 0001 0000 0002 :...*....................000000f0: 0001 000b 000c 0001 0009 0000 001f 0002 0001 0000 0007 2ab4 :......................*.00000108: 0002 0460 ac00 0000 0100 0a00 0000 0600 0100 0000 0500 0100 :...`....................00000120: 0d00 0000 0200 0e :....... javap -v TestClass &gt; TestClassP，TestClassP 内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Classfile /home/mrxiexie/Desktop/Class类文件结构/TestClass.class Last modified Jul 27, 2019; size 295 bytes MD5 checksum ff327e53338de6f5f52ac73c58c0160d Compiled from "TestClass.java"public class org.fenixsoft.clazz.TestClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #3.#16 // org/fenixsoft/clazz/TestClass.m:I #3 = Class #17 // org/fenixsoft/clazz/TestClass #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 TestClass.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 org/fenixsoft/clazz/TestClass #18 = Utf8 java/lang/Object&#123; public org.fenixsoft.clazz.TestClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 2: 0 public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 5: 0&#125;SourceFile: "TestClass.java" 魔数与Class文件的版本 Class文件的头4个字节，唯一作用是确定文件是否为一个可被虚拟机接受的Class文件，固定为“0xCAFEBABE”。 第5和第6个字节是次版本号，第7和第8个字节是主版本号（0x0034为52，对应JDK版本1.8）；能向下兼容之前的版本，无法运行后续的版本； 常量池 常量池可以理解为 Class 文件之中的资源仓库，是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项之一； 由于常量池中的常量数量不固定，因此需要在常量池前放置一项u2类型的数据来表示容量，该值是从 1 开始的，上图的 0x0013 为十进制的 19，代表常量池中有 18 项常量，索引值范围为 1~18； 常量池主要存放两大类常量： 字面量（Literal，比较接近Java的常量概念，比如文本字符串和final常量等） 符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符） Java 代码在 javac 编译时不会有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接；所以在 Class 文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中； JDK 1.7 中常量池共有 14 种不同的表结构数据，这些表结构开始的第一位是一个 u1 类型的标志位，代表当前常量的类型，具体如下表所示： 类型 标志 CONSTANT_Class 7 类或接口的符号引用 CONSTANT_Fieldref 9 字段的符号引用 CONSTANT_Methodref 10 类中方法的符号引用 CONSTANT_InterfaceMethodref 11 接口中方法的符号引用 CONSTANT_String 8 字符串类型字面量 CONSTANT_Integer 3 整型字面量 CONSTANT_Float 4 浮点型字面量 CONSTANT_Long 5 长整形字面量 CONSTANT_Double 6 双精度浮点型字面量 CONSTANT_NameAndType 12 字段或方法的部分符号引用 CONSTANT_Utf8 1 UTF-8 编码的字符串 CONSTANT_MethodHandle 15 表示方法句柄 CONSTANT_MethodType 16 标识方法类型 CONSTANT_InvokeDynamic 18 表示一个动态方法调用点 14 种不同的表结构数据如下表所示： 常量 项目 类型 描述 CONSTANT_Utf8_info tag u1 值为 1 length u2 UTF-8 编码的字符串占用的字节数 bytes u1 长度为 length 的 UTF-8 编码的字符串 CONSTANT_Integer_info tag u1 值为 3 bytes u4 按照高位在前存储的 int 值 CONSTANT_Float_info tag u1 值为 4 bytes u4 按照高位在前存储的 float 值 CONSTANT_Long_info tag u1 值为 5 bytes u8 按照高位在前存储的 long 值 CONSTANT_Double_info tag u1 值为 6 bytes u8 按照高位在前存储的 double 值 CONSTANT_Class_info tag u1 值为 7 index u2 指向全限定名常量项的索引 CONSTANT_String_info tag u1 值为 8 index u2 指向字符串字面量的索引 CONSTANT_Fieldref_info tag u1 值为 9 index u2 指向声明字段的类或者接口描述符 CONSTANT_Class_info 的索引项 index u2 指向字段描述符 CONSTANT_NameAndType 的索引项 CONSTANT_Methodref tag u1 值为 10 index u2 指向声明方法的类描述符 CONSTANT_Class_info 的索引项 index u2 指向名称及类型描述符 CONSTANT_NameAndType 的索引项 CONSTANT_Interface_Methidref_info tag u1 值为 11 index u2 指向声明方法的接口描述符 CONSTANT_Class_info 的索引项 index u2 指向名称及类型描述符 CONSTANT_NameAndType 的索引项 CONSTANT_NameAndType_info tag u1 值为 12 index u2 指向该字段或方法名称常量项的索引 index u2 指向该字段或方法描述符常量项的索引 CONSTANT_MethodHandle_info tag u1 值为 15 reference_kind u1 值必须在 1~9之间（包括 1 和 9），它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为 reference_index u2 只必须是对常量池的有效索引 CONSTANT_MethodType_info tag u1 值为 16 descriptor_index u2 只必须是对常量池的有效索引，常量池该索引处的项必须是 CONSTANT_Utf8_info 结构，表示方法的描述符 CONSTANT_InvokeDynamic_info tag u1 值为 18 bootstrap_method_attr_index u2 值必须是对当前 Class 文件中引导方法表的 bootstrap_methods[] 数组的有效索引 name_and_type_index u2 值必须是对当前常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_NameAndType_info 结构，表示方法名和方法描述符 访问标志 紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息； 访问标志一个有 16 个标志位，但目前只采用了其中 8 位，本例子中的 0x0021 标识为一个 public 的普通类； 具体标志位以及含义见下表： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为 public 类型 ACC_FINAL 0x0010 是否被声明为 final，是有类可设置 ACC_SUPER 0x0020 是否允许使用 invokespecial 字节码指令的新语意， incokespecial 指令的语意在 JDK 1.0.2 发生过改变，为了区别这条指令使用哪种语意，JDK 1.0.2 之后编译出来的类的这个标志都必须为真 ACC_INTERFACE 0x0200 标识这是一个接口 ACC_ABSTRACT 0x0400 是否为 abstract 类型，对于接口或者抽象类来说，此标志值为真，其他类值为假 ACC_SYNTHETIC 0x1000 标识这个类并非由用户代码产生的 ACC_ANNOTATION 0x2000 标识这是一个注解 ACC_ENUM 0x4000 标识这是一个枚举 类索引、父类索引与接口索引集合 类索引：u2类型的数据，用于确定类的全限定名。 父类索引：u2类型的数据，用于确定父类的全限定名。 接口索引计算器：u2类型的数据，用于表示索引集合的容量。 接口索引集合：一组u2类型的数据的集合，用于确定实现的接口（对于接口来说就是extend的接口）。 字段表集合字段表结构见下表： 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attributes_count 1 attribute_info attributes attributes_count 用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段； fields_count：字段数量，类型为 u2 access_flags：与类中的访问标志类似 name_index：字段的简单名，指向常量池的引用 descriptor_index：字段和方法的描述符，指向常量池的引用 attribute_info：属性表，下面会提到 方法表集合方法表结构见下表： 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attributes_count 1 attribute_info attributes attributes_count 方法访问标志见下表： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 方法是否为 public ACC_PRIVATE 0x0002 方法是否为 private ACC_PROTECTED 0x0004 方法是否为 protected ACC_STATIC 0x0008 方法是否为 static ACC_FINAL 0x0010 方法是否为 final ACC_SYNCHRONIZED 0x0020 方法是否为 synchronized ACC_BRIDGE 0x0040 方法是否是由编译器产生的桥接方法 ACC_VARARGS 0x0080 方法是否接受不定参数 ACC_NATIVE 0x0100 方法是否为 native ACC_ABSTRACT 0x0400 方法是否为 abstract ACC_STRICTFP 0x0800 方法是否为 strictfp ACC_SYNTHETIC 0x1000 方法是否是由编译器自动产生的 和字段表集合的方式几乎一样； 方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 Code 的属性里面； methods_count：字段数量，类型为 u2 access_flags：与类中的访问标志类似 name_index：字段的简单名，指向常量池的引用 descriptor_index：字段和方法的描述符，指向常量池的引用 attribute_info：属性表，下面会提到 属性表集合虚拟机规范预定义的属性见下表： 属性名称 使用位置 含义 Code 方法表 Java 代码编译成的字节码指令 ConstantValue 字段表 final 关键字定义的常量值 Deprecated 类、方法表、字段表 被声明为 deprecated 的方法和字段 Exceptions 方法表 方法抛出的异常 EncloseingMethod 类文件 仅当一个类的局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClasses 类文件 内部类列表 LineNumberTable Code 属性 Java 源码的行号与字节码指令的对应关系 LocalVariableTable Code 属性 方法的局部变量描述 StackMapTable Code 属性 JDK 1.6 中新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 Signature 类、方法表、字段表 JDK 1.5 中新增的属性，这个属性用于支持泛型情况下的方法签名，在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Paramterized Types），则 Signature 属性会为它记录泛型签名信息。由于 Java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 JDK 1.6 中新增的属性，SourceDebugExtension 属性用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 Java 语言编写，却需要编译为字节码并运行在 Java 虚拟机中的程序提供了一个进制调试的标准机制，使用 SourceDebugExtension 属性就可以用户存储这个标准所新加入的调试信息 Synthetic 类、方法表、字段表 标识方法或字段为编译器自动生成的 LocalVariableTypeTable 类 JDK 1.5 中新增的属性，它使用特性签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类、方法表、字段表 JDK 1.5 中新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations 属性用于指明哪些注解是运行时（实际上运行时就是通过反射调用）可见的 RuntimeInvisibleAnnotations 类、方法表、字段表 JDK 1.5 中新增的属性，与 RuntimeVisibleAnnotations 属性作用刚好相反，用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotations 方法表 JDK 1.5 中新增的属性，作用与 RuntimeVisibleAnnotations 类似，只不过作用对象为方法参数 RuntimeInvisibleParameterAnnotations 方法表 JDK 1.5 中新增的属性，作用与 RuntimeInvisibleAnnotations 类似，只不过作用对象为方法参数 AnnotationDefault 方法表 JDK 1.5 中新增的属性，用于记录注解类元素的默认值 BootstrapMethods 类文件 JDK 1.7 中新增的属性，用于保存 invokedynamic 指令引用的引导方法限定符 对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可，结构如下表： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length Code 属性 Java程序方法体中的代码经过 Javac 编译器处理后，最终变为字节码指令存储在 Code 属性内，其属性表结构如下： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 max_stack 1 u2 max_locals 1 u4 code_length 1 u1 code code_length u2 exception_table_length 1 exception_info exception_table exception_table_length u2 attributes_count 1 attribute_info attributes attributes_count attribute_name_index：指向 CONSTANT_Utf8_info 型常量的索引，常量值固定为 Code，代表该属性的属性名称 attribute_length：指向属性值的长度，用于属性名称索引与属性长度一共为 6 字节，所以属性的长度固定为整个属性长度减去 6 个字节 max_stack：代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。 max_locals：代表了局部变量表所需的存储空间 code_length：代表字节码长度 code：存储字节码指令的一系列字节流 exception_table_length：异常处理表长度 exception_table：异常处理表 异常处理表结构见下表： 类型 名称 数量 u2 start_pc 1 u2 end_pc 1 u2 handler_pc 1 u2 catch_type 1 它包含 4 个字段，这些字段的含义为：如果当字节码在第 start_pc 行到第 end_pc 行之间（不含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type 为指向一个 CONSTANT_Class_info 型常量的索引），则转到第 handler_pc 行继续处理。当 catch_type 的值为 0 时，代表任意异常情况都需要转向到 handler_pc 处进行处理。 Exceptions 属性方法描述时throws关键字后面列举的异常，和Code属性里的异常表不同。其属性表结构如下： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 number_of_exceptions 1 u2 exception_index_table number_of_exceptions Exceptions 属性中的 number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常，每一种受查异常使用一个 exception_index_table 项表示，exception_index_table 是一个指向常量池中 CONSTANT_Class_info 型常量的索引，代表了该受查异常的类型。 LineNumberTable 属性用于描述 Java 源码行号与字节码行号之间的对应关系，它不是必须的，可以通过 javac -g:none 取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。 LIneNumberTable 属性结构见下表： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 line_number_table_length 1 line_number_info line_number_table line_number_table_length line_number_table 是一个数量为 line_number_table_length、类型为 line_number_info 的集合，line_number_info 表包括了start_pc 和 line_number 两个 u2 类型的数据项，前者是字节码行号，后者是 Java 源码行号。 LocalVariableTable 属性用于描述栈帧中局部变量与Java源码中定义的变量之间的关系，它不是运行时必须的，可以通过 javac -g:none 取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以 arg0、arg1 这样的占位符来替代。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 local_variable_table_length 1 local_variable_info local_variable_table local_variable_table_length 其中，local_variable_info 项目代表了一个栈帧与源码中局部变量的关联，结构见下表： 类型 名称 数量 u2 start_pc 1 u2 length 1 u2 name_index 1 u2 descriptor_index 1 u2 index 1 start_pc 和 length 属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。 name_index 和 descriptor_index 都是指向常量池中 CONSTANT_Utf8_info 型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。 index是这个局部变量在栈帧局部变量表中 Slot 的位置。当这个变量数据类型是 64 位类型时（double 和 long），它占用的 Slot 为 index 和 index+1 两个。 SourceFile 属性用于记录生成这个Class的源码文件名称，这个属性也是可选的。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 sourcefile_index 1 ConstantValue 属性ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在 Java 程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同： 对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 &lt;init&gt; 方法中进行的； 而对于类变量，则有两种方式可以选择（Sun Javac 编译器的选择是）： 在类构造器 &lt;clinit&gt; 方法中初始化：变量没有被final修饰，或者并非基本类型及字符串 使用 ConstantValue 属性初始化：同时使用 final 和 static 来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 虽然有 final 关键字才更符合 ConstantValue 的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL 标志，只要求了有 ConstantValue 属性的字段必须设置 ACC_STATIC 标志而已，对final关键字的要求是 Javac 编译器自己加入的限制。而对 ConstantValue 的属性值只能限于基本类型和 String，不过笔者不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于 Class 文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算 ConstantValue 属性想支持别的类型也无能为力。 ConstantValue 属性的结构见下表： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 constantvalue_index 1 InnerClasses 属性用于记录内部类与宿主类之间的关联。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 number_of_classes 1 inner_classes_info inner_classes number_of_classes 其中number_of_class代表需要记录多少个内部类信息，每个内部类的信息都由一个inner_class_info表进行描述。 类型 名称 数量 u2 inner_class_info_index 1 u2 outer_class_info_index 1 u2 inner_name_index 1 u2 inner_class_access_flags 1 Deprecated 及 Synthetic 属性Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。 Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用 @deprecated 注释进行设置。 Synthetic 属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在 JDK 1.5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位，其中最典型的例子就是 Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器 &lt;init&gt; 方法和类构造器 &lt;clinit&gt; 方法。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 其中 attribute_length 数据项的值必须为 0x00000000，因为没有任何属性值需要设置。 StackMapTable 属性这是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 number_of_entries 1 stack_map_frame stack_map_frame_entries number_of_entries Signature 属性一个可选的定长属性，在 JDK 1.5 发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则 Signature 属性会为它记录泛型签名信息。这主要是因为 Java 的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过 Signature 属性，Java 的反射 API 能够获取泛型类型。 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 signature_index 1 BootstrapMethods 属性一个复杂的变长属性，位于类文件的属性表中，用于保存 invokedynamic 指令引用的引导方法限定符。 BootstrapMethods 属性结构见下表： 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u2 num_bootstrap_methods 1 bootstrap_method bootstrap_methods num_bootstrap_methods bootstrap_method 结构见下表： 类型 名称 数量 u2 bootstrap_method_ref 1 u2 num_bootstrap_arguments 1 u2 bootstrap_arguments num_bootstrap_arguments 三. 字节码指令简介Java虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。 在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如 iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中。 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令 goto 则是与数据类型无关的。 加载和存储指令：iload/iload_等（加载局部变量到操作栈）、istore/istore_等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_（加载常量到操作数栈）、wide（扩充局部变量表访问索引）； 运算指令：没有直接支持 byte、short、char 和 boolean 类型的算术指令而采用 int 代替；iadd/isub/imul/idiv加减乘除、irem求余、ineg取反、ishl/ishr位移、ior按位或、iand按位与、ixor按位异或、iinc局部变量自增、dcmpg/dcmpl比较； 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f； 对象创建与访问指令：new 创建类实例、newarray/anewarray/multianewarray创建数组、getfield/putfield/getstatic/putstatic访问类字段或实例字段、baload/iaload/aaload把一个数组元素加载到操作数栈、bastore/iastore/aastore将一个操作数栈的值存储到数组元素中、arraylength取数组长度、instanceof/checkcast检查类实例类型； 操作数栈管理指令：pop/pop2一个或两个元素出栈、dup/dup2复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap交互栈顶两个数值； 控制转移指令：ifeq/iflt/ifnull条件分支、tableswitch/lookupswitch复合条件分支、goto/jsr/ret无条件分支； 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic方法调用、ireturn/lreturn/areturn/return方法返回； 异常处理指令：athrow 同步指令：monitorenter/monitorexit 四. 公有设计和私有实现 Java虚拟机的实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的含义； 但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化； 虚拟机实现的方式主要有两种：将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机CPU的本地指令集。 五. Class文件结构的发展 Class文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容； Class文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱； 下载本文所有代码：传送门]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（三）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89.html</url>
    <content type="text"><![CDATA[第二部分 自动内存管理机制第三章 Java 垃圾收集器与内存分配策略经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。 Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回收也仅指这一部分内存。 主要思考 GC 需要完成的 3 件事情： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 一. 对象已死吗？在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。 1. 引用计数算法引用计数算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。 客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。 若使用引用计数算法，下面的例子将不会回收 objA 和 objB，可以在运行程序时添加 -XX:+PrintGCDetails JVM参数，可看出对象已被回收，说明 JVM 并不是使用引用计数算法。 123456789101112131415161718192021222324252627/** * testGC()方法执行后，objA和objB会不会被GC呢？ */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; /** * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设在这行发生GC，objA和objB是否能被回收？ System.gc(); &#125;&#125; 2. 可达性计数算法在主流的商用程序语言的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。如下图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。 可作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。 看到这里你可能要问，选择这些对象的依据是什么呢？ 可以概括得出，可作为 GC Roots 的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc 必须以当前存活的对象集为 Roots，因此必须选取确定存活的引用类型对象。GC 管理的区域是Java堆、虚拟机栈、方法区和本地方法栈不被 GC 所管理，因此选用这些区域内引用的对象作为 GC Roots，是不会被 GC 所回收的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是 GC roots 的一部分。 3. 再谈引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 JDK1.2之后，Java 提供了四种强度不同的引用类型。 强引用只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj = new Object(); 软引用用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 弱引用用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; // 使对象只被弱引用关联 虚引用虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj = null; // 使对象只被虚引用关联 4. 两次标记与 finalize() 方法即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 值得注意的是，如果代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的finalize()方法都只会被系统调用一次，如果对象面临下一次回收，它的finalize()方法不会再被执行，因此第二次逃脱行动失败。 需要说明的是，使用finalize()方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的工作，使用try-finally或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。 5. 回收方法区很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容： 废弃常量 回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 无用的类 判定一个类是否是“无用的类”的条件相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 二. 垃圾收集算法1. 标记-清除算法“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个： 效率问题：标记和清除两个过程的效率都不高 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如下图所示： 2. 复制算法（新生代）为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如下图所示： 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。 当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。 3. 标记-整理算法（老年代）复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下图所示： 4. 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 三. HotSpot的算法实现上谅解介绍了对象存活判定算法和垃圾收集算法，而在 HotSpot 虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。 1. 枚举根节点从可达性分析中从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。 GC停顿（”Stop The World”） 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。 准确式GC与OopMap 由于目前的主流Java虚拟机使用的都是准确式GC（即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。 2. 安全点（Safepoint）——进行 GC 时程序停顿的位置在 OopMap 的协助下，HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。 为此，HotSpot选择不为每条指令都生成 OopMap，而是只在“特定的位置”记录这些信息，这些位置便被称为安全点（Safepoint）。即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。Safepoint 的选定既不能太少以致于让 GC 等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。 对于Sefepoint，另一个需要考虑的问题是如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择： 抢先式中断（Preemptive Suspension）：其中抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。 主动式中断（Voluntary Suspension）：而主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 3. 安全区域（Safe Region）Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候（如线程处于Sleep状态或Blocked状态），这时线程无法响应 JVM 的中断请求，“走到”安全的地方去中断挂起，这时候就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。 四. 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于 JDK 1.7 Update 14 之后的 HotSpot 虚拟机（在这个版本中正式提供了商用的 G1 收集器，之前 G1 仍处于实验状态），这个虚拟机包含的所有收集器如下图所示： 以上为 Hotspot 虚拟机中的 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析 CMS 和 G1 这两款相对复杂的收集器，了解它们的部分运作细节。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 相关概念并行和并发 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个 CPU 上。 吞吐量（Throughput）吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。 假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。 Minor GC 和 Full GC 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 老年代GC（Major GC / Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC的速度一般会比 Minor GC 慢10倍以上。 1. Serial 收集器 Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 它是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数 3. Parallel Scavenge 收集器与 ParNew 一样是多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。 MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 GCTimeRatio 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/(1+19)），默认值为 99，就是允许最大 1%（即1/(1+99)）的垃圾收集时间。 可以通过一个开关参数（-XX:+UseAdaptiveSizePolicy）打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。 4. Serial Old收集器 是 Serial 收集器的老年代版本，使用“标记-整理”算法，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本，使用“标记-整理”算法。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。在 JDK 1.5 的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中，CMS 收集器的启动阈值已经提升至 92%。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，这样停顿时间就很长了。所以说参数 -XX:CM SInitiatingOccupancyFraction 设置得太高很容易导致大量 Concurrent Mode Failure 失败，性能反而降低。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。为了解决这个问题，CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。 7. G1 收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 总结 收集器 串行、并行or并发 新生代/老年代 算法 目标 适用场景 Serial 串行 新生代 复制算法 响应速度优先 单CPU环境下的Client模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单CPU环境下的Client模式、CMS的后备预案 ParNew 并行 新生代 复制算法 响应速度优先 多CPU环境时在Server模式下与CMS配合 Parallel Scavenge 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并发 老年代 标记-清除 响应速度优先 集中在互联网站或B/S系统服务端上的Java应用 G1 并发 both 标记-整理+复制算法 响应速度优先 面向服务端应用，将来替换CMS 五. 内存分配与回收策略Java的自动内存管理最终可以归结为自动化地解决了两个问题： 给对象分配内存 回收分配给对象的内存 对象的内存分配通常是在堆上分配（除此以外还有可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。 下面的是在使用 Serial/Serial Old 收集器下（ParNew/Serial Old收集器组合的规则也基本一致）的内存分配和回收的策略。 1. 对象优先在Eden分配大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 2. 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），经常出现大对象容易导致内存还有不少空间时就提前触发 GC 以获取足够的连续空间来安置它们。 虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法回收内存）。 3. 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 设置。 4. 动态对象年龄判定为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。 在JDK 6 Update 24之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。 六. Full GC的触发条件对于 Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍 Full GC 的触发条件。 调用System.gc()此方法的调用是建议 JVM 进行 Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 -XX:+ DisableExplicitGC来禁止 RMI 调用 System.gc()。 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出如下错误：Java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 空间分配担保失败前文介绍过，使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 JDK 1.7及以前的永久代空间不足在JDK 1.7及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用CMS GC 的情况下也会执行 Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space为避免 PermGen 占满造成 Full GC现象，可采用的方法为增大 PermGen 空间或转为使用 CMS GC。 在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。 Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报Concurrent Mode Failure错误，并触发 Full GC。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（二）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[第二部分 自动内存管理机制第二章 Java 内存区域与内存一. 运行时数据区域下图为我自己画的一张未完成的「Java虚拟机运行时数据区」 图，简单介绍可以直接看图中的文字 以下记录各个数据区域的详细介绍（直接 copy 的原文）： 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 局部变量表存放了编译期可知的各种： 基本数据类型（boolean、byte、char、short、int、float、long、double） 对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置） returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况： StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出。 OutOfMemoryError：如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出。 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将是第3章的主题。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern()）会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的 JDK 1.7 的 HotSpot 中，已经把原本放在永久代的字符串常量池移出。 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 二. 从 Java 堆中探讨对象的创建流程Java的对象创建大致有如下四种方式： new关键字这应该是我们最常见和最常用最简单的创建对象的方式。 使用newInstance()方法这里包括Class类的newInstance()方法和Constructor类的newInstance()方法（前者其实也是调用的后者）。 使用clone()方法要使用clone()方法我们必须实现实现Cloneable接口，用clone()方法创建对象并不会调用任何构造函数。即我们所说的浅拷贝。 反序列化要实现反序列化我们需要让我们的类实现Serializable接口。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的深拷贝。 1. 类加载检查当虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在「常量池」中定位到一个类的符号引用，并检查是否已经被加载、解析和初始化过。若没有则必须先执行类的加载过程。 2. 分配内存类加载检查过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从「Java 堆」中划分出来。分配方式又可分为 指针碰撞 和 空闲列表。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。 指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 保证划分内存线程安全：除如何划分可用空间之外，还需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 方案一：对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。 方案二：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。 3. 初始化内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 4. 设置对象头接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后再做详细介绍。 5. 执行 &lt;init&gt; 方法在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——&lt;init&gt;方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 三. 对象的内存布局对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） 1. 对象头（Header）HotSpot虚拟机的对象头包括两部分信息： 对象自身的运行时数据 “Mark Word”： 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见下表： 存储内容 标志位 状态 对象哈希码、对象分代年龄 01 未锁定 指向锁记录的指针 00 轻量级锁定 定向重量级锁的指针 10 膨胀（重量级锁定） 空，不需要记录信息 11 GC 标记 偏向线程 ID、偏向时间戳、对象分代年龄 01 可偏向 类型指针： 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 2. 实例数据（Instance Data）对象真实存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 3. 对齐填充第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 四. 对象的访问定位我们的Java程序需要通过栈上的对象引用（reference）数据（存储在栈上的局部变量表中）来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面也只规定了是一个指向对象的引用，并没有定义这个引用的具体实现，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。 1. 句柄访问如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 2. 直接指针访问如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 这两种对象访问方式各有优势： 句柄 使用来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 直接指针 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机（一）]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[第一部分 走进Java第一章 走进Java一. Java 技术体系sun公司所定义的 Java 技术体系： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 JDK（Java Development Kit），用于支持 Java 程序开发的最小环境，JDK可分为 SUN JDK 和 OpenJDK，后者为前者的开源版本，代码基本没有区别： Java程序设计语言 Java虚拟机 Java API类库 JRE（Java Runtime Environment），支持 Java 程序运行的标准环境 Java API类库中的 Java SE API子集 Java虚拟机 以上是根据各个组成部分的功能来进行划分的，如果按照技术所服务的领域来划分，或者说按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台，分别为： Java Card：支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。 Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。 Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE。 Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台，除了提供Java SE API外，还对其做了大量的扩充[3]并提供了相关的部署支持，这个版本以前称为J2EE。 二. Java虚拟机发展史 SUN Classic：第一代 Java 虚拟机，只能使用纯解释器执行 Java 代码，如果要使用 JIT 编译器，就必须外挂。但是外挂了 JIT 编译器后，解释器也不再工作。 Exact VM：JDK 1.2 时发布的一款虚拟机，当时已具备现在高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。但不久就被后来的 HotSpot VM 取代。 HotSpot VM：是目前 SUN JDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机，它名称中的 HotSpot 指的就是它的热点代码探测技术。 三. 编译 JDK 源码开发中使用的是 Java8，这里以 OpenJDK8 为例，在 Linux 下进行编译，开发常用的笔记本为 ArchLinux 内核版本为 5.1.15-arch1-1-ARCH，可能是由于 gcc/g++ 版本太高导致有奇奇怪怪的问题发生，下面演示的是使用 centos 内核版本为 2.6.32-754.el6.x86_64。 下载最新版本的 OpenJDK8，下载地址为 传送门 1234567891011121314# 先下载一个 jdkyum install java-1.8.0-openjdk# 下载源码包[root@localhost jvm] wget https://download.java.net/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip# 解压[root@localhost jvm] unzip openjdk-8-src-b132-03_mar_2014.zip# 切入 openjdk 目录[root@localhost jvm] cd openjdk# 给 configure 添加执行权限[root@localhost openjdk] chmod +x configure# 执行 configure，若报错，照着提示处理即可[root@localhost openjdk] ./configure# 编译，等待编译完成即可[root@localhost openjdk] make 若编译过程中遇到一些奇葩问题，可以参照一下后面的链接 传送门 编译完成后会生成 build 目录 123[root@localhost openjdk] cd build/linux-x86_64-normal-server-release/jdk/bin# 执行 java[root@localhost bin] ./java -version 四. NetBeans 中进行源码调试下载最新版的 netbeans，下载地址为 传送门 123456# 下载最新版本的 netbeans，我这里使用的是 11.0 版本wget https://mirrors.tuna.tsinghua.edu.cn/apache/incubator/netbeans/incubating-netbeans/incubating-11.0/incubating-netbeans-11.0-bin.zip # 解压unzip incubating-netbeans-11.0-bin.zip# 运行 netbeans./netbeans/bin/netbeans 下载 c/c++ 插件，点击 Tools -&gt; Plugins -&gt; Settings 中选中 NetBeans 8.2 Plugins Portal 选中 Available Plugins -&gt; Check for Newest，选中 C/C++ 复选框，然后点击 Install 下载插件 创建新项目： File -&gt; New Project -&gt; C/C++ -&gt; 基于先有源代码的 C/C++ 项目 -&gt; Next 选择模式：浏览 至源码根目录，我这里的根目录是 /root/openjdk，选择 定制 然后 Next 预构建操作：我这里把参数一栏清空，然后一路 Next 到最后，然后等待运行完成即可 下面开始 运行源码吧。先创建 Hello.java 文件，内容如下： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println("Hello JVM"); &#125;&#125; 使用 javac Hello.java 编译生成 Hello.class 文件，并在 项目属性 -&gt; 运行 的运行命令中指向 Hello.class 的位置 点击如下方箭头，运行，并选择源码编译后的 java 命令运行 输出结果如下： DEBUG System.out.println(...) 的调用将由 jdk/src/share/native/java/io/io_util.c 文件中的 writeBytes 函数处理，在 154 行打上断点 最后使用 DEBUG 运行，现在我们就可以随心所欲的查看 JVM 都做了什么了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解JNI]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3JNI.html</url>
    <content type="text"><![CDATA[查看源码时多多少少会接触到 native 这个关键字，例如 Math.sqrt(double a) 方法，底层使用的就是 public static native double sqrt(double a) 。那什么是 native 方法？ Native Method 其实就是一个 Java 调用非 Java 代码的接口。 JNI 是 Java Native Interface 的缩写，它提供了若干的 API 实现 Java 和 其他语言的通讯（主要是 C/C++） 那么，这个方法的实现是放在哪的呢？ 这些方法的实现，实际上就是 C/C++ 的源码（后缀为.c和.cpp等），通过对源码进行预编译、编译、汇编和链接为 .dll （win下）或者 .so （Linux下）动态库，最后通过 Java 中的 System.loadLibrary(String libname) 方法加载到内存中。 下面介绍如何通过 Java 中 调用 C 的函数和 C 中调用 Java 中的函数（特意花了一下午学习 C 语言的语法）。 先创建一个叫 JNI.java 的文件，放在 cn/mrxiexie/jni 文件夹下，定义我们编译后的动态库名为 JNI，对应 win 下的 JNI.dll 和 Linux 下的 libJNI.so 文件。注意：Linux 下的动态库格式规定前缀为 lib，使用 System.loadLibrary 时，只需把前缀和后缀去掉的中间部分传入参即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.mrxiexie.jni;import java.util.Arrays;import java.util.Random;public class JNI &#123; static &#123; try &#123; // 此处即为本地方法所在链接库名 System.loadLibrary("JNI"); &#125; catch (UnsatisfiedLinkError e) &#123; System.err.println("Cannot load JNI library:\n " + e.toString()); &#125; &#125; public static native double[] sqrt(int[] nums); public static native int max(); public native int min(); public static void log(String msg) &#123; System.out.println("In C " + msg); &#125; public static int[] getNums(int count) &#123; int[] nums = new int[count]; Random random = new Random(); for (int i = 0; i &lt; count; i++) &#123; nums[i] = random.nextInt(count); &#125; System.out.println("In Java getNums ： " + Arrays.toString(nums)); return nums; &#125; public static void main(String[] args) &#123; JNI jni = new JNI(); int max = max(); System.out.println("In Java max num is " + max); int min = jni.min(); System.out.println("In Java min num is " + min); int[] nums = JNI.getNums(10); double[] sqrt = sqrt(nums); System.out.println("In Java sqrt num is " + Arrays.toString(sqrt)); &#125;&#125; 使用 javac cn/mrxiexie/jni/JNI.java 编译或者 JNI.class 文件。 使用 javah cn.mrxiexie.jni.JNI 获取 cn_mrxiexie_jni_JNI.h 头文件。 .h 文件包含了在 Java 端编写的 Native 方法声明 JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max (JNIEnv *, jclass); 和各种 C/C++ 中的宏定义（#开头的），文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class cn_mrxiexie_jni_JNI */#ifndef _Included_cn_mrxiexie_jni_JNI#define _Included_cn_mrxiexie_jni_JNI#ifdef __cplusplusextern "C" &#123;#endif/* * Class: cn_mrxiexie_jni_JNI * Method: sqrt * Signature: ([I)[D */JNIEXPORT jdoubleArray JNICALL Java_cn_mrxiexie_jni_JNI_sqrt (JNIEnv *, jclass, jintArray);/* * Class: cn_mrxiexie_jni_JNI * Method: max * Signature: ()I */JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max (JNIEnv *, jclass);/* * Class: cn_mrxiexie_jni_JNI * Method: min * Signature: ()I */JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_min (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 单有方法声明可没什么用，现在我们把具体的方法实现放在 JNI.c 中，该方法主要实现从 Java 的 getNums 方法获取数值数组，再通过对数值数组进行遍历，求出数组中的最大值，并返回给 Java 中的 max 方法。 在看 JNI.c 文件内容前，先科普一下 JNI 的基础知识： JNI 基础知识基础数据类型： 下表的 C、Java 和 JNI 的关系（以下关系可以查阅 JDK 下的 jni.h 和 jni_mh.h 文件，我的是Linux系统下的 /usr/lib/jvm/java-8-jdk/include ）： 123456789101112131415// /usr/lib/jvm/java-8-jdk/include/linux/jni_mh.htypedef int jint;#ifdef _LP64 /* 64-bit Solaris */typedef long jlong;#elsetypedef long long jlong;#endiftypedef signed char jbyte;// /usr/lib/jvm/java-8-jdk/include/jni.htypedef unsigned char jboolean;typedef unsigned short jchar;typedef short jshort;typedef float jfloat;typedef double jdouble;typedef jint jsize; Java JNI C int jint int long jlong long/long long byte jbyte signed char boolean jboolean unsigned char char jchar unsigned short short jshort short float jfloat float double jdouble double 引用类型： jni.h 中定义了 _jobject 结构体，代表 Java 中的 java.lang.Object 1234567891011121314151617// /usr/lib/jvm/java-8-jdk/include/jni.hstruct _jobject;typedef struct _jobject *jobject;typedef jobject jclass;typedef jobject jthrowable;typedef jobject jstring;typedef jobject jarray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jarray jobjectArray; Java JNI C java.lang.Object jobject _jobject java.lang.Class jclass _jobject java.lang.Throwable jthrowable _jobject java.lang.String jstring _jobject 数组 jarray _jobject C/C++ 中定义的 Native 函数，入参和出餐都是上述的类型。 对于基础数据类型如：jint，jlong等，可以直接参与运行不需要任何转换。 对于引用类型如：jstring，jintarray等，需要转换为 char*，int[] 等，如何转换呢？所有的 Native 函数入参都有 JNIENV *env，静态 Native 函数额外有 jclass thisClass（max 方法），普通 Native 函数额外有 jobject thisObj（min 方法）： JNIENV *env：这是一个指向 JNI 运行环境的指针，我们可以通过该方法调用 JNI 函数，如将 jstring 转为 char* 等 jclass thisClass：静态 Native 方法所在类 jobject thisObj：普通 Native 方法所在类的对象 JNI.c 文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 导入同目录下的 `cn_mrxiexie_jni_JNI.h` 头文件#include "cn_mrxiexie_jni_JNI.h"// 导入系统中同名的头文件，可以理解为 Java 中的 import#include &lt;jni.h&gt;// 求平方根需要用到 `math.h` 中的 `double sqrt(double)` 方法#include &lt;math.h&gt;// 输入输出#include &lt;stdio.h&gt;jmethodID logMethodId;void java_log(JNIEnv *env, jclass thisClass, char *msg) &#123; if (NULL == logMethodId) &#123; logMethodId = (*env)-&gt;GetStaticMethodID(env, thisClass, "log", "(Ljava/lang/String;)V"); &#125; jstring message = (*env)-&gt;NewStringUTF(env, msg); (*env)-&gt;CallStaticVoidMethod(env, thisClass, logMethodId, message);&#125;/* * 把 nums 所有元素开根号后返回 * * 入参 jintArray nums 为需要开平方的数组 * 第一步先把 jintArray 通过 env 的方法转换为 jint[]（即 int[]） * 第二步通过 env 的方法获取 jintArray 的长度 * 第三步循环 nums_intPointer（jint[]），并通过 `math.h` 的 sqrt * 开根号把结果放在 sqrtArray（double[]） 数组中 最后把通过 env 的方法把 * double[] 转为 jdoubleArray 并返回 * * Class: cn_mrxiexie_jni_JNI * Method: sqrt * Signature: ([I)[D */JNIEXPORT jdoubleArray JNICALL Java_cn_mrxiexie_jni_JNI_sqrt(JNIEnv *env, jclass thisClass, jintArray nums) &#123; java_log(env, thisClass, "sqrt"); // 将 jintArray 转换为 jint[] jint *nums_intPointer = (*env)-&gt;GetIntArrayElements(env, nums, NULL); if (nums_intPointer == NULL) &#123; return 0; &#125; jsize nums_Len = (*env)-&gt;GetArrayLength(env, nums); double sqrtArray[nums_Len]; for (int i = 0; i &lt; nums_Len; i++) &#123; sqrtArray[i] = sqrt((double)*(nums_intPointer + i)); &#125; jdoubleArray doublearray_Ret = (*env)-&gt;NewDoubleArray( env, nums_Len); // 将需要返回的数组长度len，作为入参 (*env)-&gt;SetDoubleArrayRegion(env, doublearray_Ret, 0, nums_Len, sqrtArray); // c_array 对应C代码的数组指针 return doublearray_Ret;&#125;/* * 求数组的最大值并返回，数组从 java 中的 getnums(count) 获取，count 为数组长度 * * 第一步通过 env 的方法获取到 getNums 的 jmethodID（类似与 Java 中的反射） * 第二步通过 env 的方法调用 getNums 静态方法获取到数组 numbs(jintArray) * 第三步把 numbs(jintArray) 通过 env 的方法转换为 jint[]（即 int[]） * 第四步通过 env 的方法获取 jintArray 的长度 * 最后循环 jintArray 数组并返回最大值 * * Class: cn_mrxiexie_jni_JNI * Method: max * Signature: ()I */JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max(JNIEnv *env, jclass thisClass) &#123; java_log(env, thisClass, "max"); // 获取方法 id jmethodID getNums = (*env)-&gt;GetStaticMethodID(env, thisClass, "getNums", "(I)[I"); if (NULL == getNums) return 0; // 调用 Java 中的静态方法 jintArray numbs = (*env)-&gt;CallStaticObjectMethod(env, thisClass, getNums, 10); // 将 jintArray 转换为 jint[] jint *intArray = (*env)-&gt;GetIntArrayElements(env, numbs, NULL); jsize length = (*env)-&gt;GetArrayLength(env, numbs); jint max = *(intArray + 1); for (int i = 0; i &lt; length; i++) &#123; jint temp = *(intArray + i); if (max &lt; temp) &#123; max = temp; &#125; &#125; return max;&#125;/* * 求数组的最小值并返回，数组从 java 中的 getnums(count) 获取，count 为数组长度 * * 注意：流程跟求最大值基本一致，由于 min 为普通 native 方法，入参为 * jobject，所以第一步需要通过 env 的方法从 thisObj(jobject) 中获取到 * thisClass(jclass) * * Class: cn_mrxiexie_jni_JNI * Method: min * Signature: ()I */JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_min(JNIEnv *env, jobject thisObj) &#123; // 通过 thisObj 对象获取对象的类 jclass thisClass = (*env)-&gt;GetObjectClass(env, thisObj); java_log(env, thisClass, "min"); // 获取方法 id jmethodID getNums = (*env)-&gt;GetStaticMethodID(env, thisClass, "getNums", "(I)[I"); if (NULL == getNums) return 0; // 调用 Java 中的静态方法 jintArray numbs = (*env)-&gt;CallStaticObjectMethod(env, thisClass, getNums, 10); // 将 jintArray 转换为 jint[] jint *intArray = (*env)-&gt;GetIntArrayElements(env, numbs, NULL); jsize length = (*env)-&gt;GetArrayLength(env, numbs); jint min = *(intArray + 1); for (int i = 0; i &lt; length; i++) &#123; jint temp = *(intArray + i); if (min &gt; temp) &#123; min = temp; &#125; &#125; return min;&#125; 内容中都有注释，就不一一讲解了，需要注意的是，获取 jmethodID 的时候需要用到方法签名 (Ljava/lang/String;)V，什么是方法签名，可以查看这篇文章。方法签名 最后我们需要把 JNI.c 源码文件，编译链接为 libJNI.so 或者 JNI.dll 文件： 1234567# 编译过程中需要用到 `jni.h`，`jni.h` 又引入了 `jni_md.h`，这两个文件分别在 jdk 的目录下，jdk/include 和 jdk/include/linux，编译后生成 `JNI.o` 目标文件。gcc -I /lib64/jvm/java-8-jdk/include -I /lib64/jvm/java-8-jdk/include/linux -fPIC -c JNI.c -o JNI.o# 生成动态库gcc -shared -o libJNI.so JNI.o# 以上两条命令可以结合为以下一条gcc -fPIC --shared JNI.c -o libJNI.so -I /lib64/jvm/java-8-jdk/include -I /lib64/jvm/java-8-jdk/include/linux 好了，libJNI.so 动态库有了，JNI.class 也有了，可以直接运行了： 12# java.library.path 指向非Java包的位置，如（.dll、.so）java -Djava.library.path=. cn.mrxiexie.jni.JNI 执行结果如下： 123456789In C maxIn Java getNums ： [3, 5, 9, 8, 2, 9, 9, 2, 0, 7]In Java max num is 9In C minIn Java getNums ： [5, 4, 9, 6, 7, 0, 5, 8, 0, 8]In Java min num is 0In Java getNums ： [0, 8, 5, 0, 2, 9, 2, 9, 6, 2]In C sqrtIn Java sqrt num is [0.0, 2.8284271247461903, 2.23606797749979, 0.0, 1.4142135623730951, 3.0, 1.4142135623730951, 3.0, 2.449489742783178, 1.4142135623730951] 下载本文所有代码：传送门 官方文档：传送门，其中 JNI 的方法可以在官方文档的 Chapter 4: JNI Functions 中查阅。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java方法签名]]></title>
    <url>%2FJava%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D.html</url>
    <content type="text"><![CDATA[Java 中一个方法签名对应一个唯一的方法， 方法签名由方法名、方法参数、返回值三部分组成，格式为：方法名(方法参数)返回值。举几个栗子： public void hello(String name) -&gt; hello(Ljava/lang/String;)V public long getTime() -&gt; getTime()J public byte[] getBytes(String data) -&gt; getBytes(Ljava/lang/String;)[B public int[][] getPoint(int index) -&gt; getPoint(I)[[I 可以看出签名不是用数据类型本身，而是用一种特殊字符，其对应关系如下表格： 特殊字符 数据类型 特殊说明 V void 一般用于表示方法的返回值 Z boolean B byte C char S short I int J long F float D double [ 数组 以[开头，配合其他的特殊字符，表示对应数据类型的数组，几个[表示几维数组 L全类名; 引用类型 以L开头、;结尾，中间是引用类型的全类名]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中静态代理和动态代理]]></title>
    <url>%2FJava%E4%B8%AD%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
    <content type="text"><![CDATA[身为一枚程序员，多多少少会听过代理（Proxy）这个词，然而什么是代理呢？ 简单介绍一下生活中常见的代理模式： 我们需要购买国外的产品时，我们可以坐飞机去国外某店购买，也可以去代购中购买，此时代购就是国外某店的代理，当我们购买到产品时，实际上是先购买请求发送给代购，代购再发送给某店，某店返回购买成功给代购，代购再返回成功给我们。某店我们可以理解为委托类（被代理类），代购可以理解为代理类。 那么使用代理模式有什么优点呢？ 解耦调用者和被代理类，在不修改被代理类的前提下，对其进行逻辑控制 其缺点也很明显 由于调用者和被代理类之间添加了代理类，因此有些类型的代理模式可能会造成请求的处理速度变慢，而且代理类一般会有额外的工作，有些代理模式的实现非常复杂 在 Java 中代理可以分为静态代理和动态代理，下面我们来详解这两种代理的区别 静态代理代理类在程序运行前就已经存在，这种代理模式称为静态代理。一般情况下，代理类和被代理类都会实现同一接口。 下面我们创建统一接口 IProxyClass： 123public interface IProxyClass &#123; void doSomething(Object o);&#125; 创建被代理类 ProxyClassImpl： 1234567public class ProxyClassImpl implements IProxyClass &#123; @Override public void doSomething(Object o) &#123; System.out.println("我是被代理类 : " + o); &#125;&#125; 创建代理类 StaticProxyHandler： 1234567891011121314151617public class StaticProxyHandler implements IProxyClass &#123; private IProxyClass iProxyClass; public StaticProxyHandler(IProxyClass iProxyClass) &#123; this.iProxyClass = iProxyClass; &#125; @Override public void doSomething(Object o) &#123; IProxyClass.doSomething(o); &#125; public static void main(String[] args) &#123; new StaticProxyHandler(new ProxyClassImpl()).doSomething(5); &#125;&#125; 若现在我们需要记录 doSomething 的运行时间，或者添加某些判断要满足条件才执行，我们则不需修改被代理类，只需在代理类上做修改： 123456789101112131415public class StaticProxyHandler implements IProxyClass &#123; 、、、 @Override public void doSomething(Object o) &#123; if (otherCondition()) &#123; LocalDateTime begin = LocalDateTime.now(); System.out.println("嘿嘿！我是代理类"); iProxyClass.doSomething(o); LocalDateTime end = LocalDateTime.now(); System.out.println("方法执行时长为：" + Duration.between(begin, end).toMillis()); &#125; &#125;&#125; 从表面上，已经解决了我们的需求，但现在需求又变动了，要在该类的所有方法都添加同样的逻辑，若该类有 100 个方法，那我们只能当个 CV工程师 了 由此可以看出静态代理的局限性，当类有多个方法时，重复的逻辑要反复实现 程序员往往是很懒的，连 CV工程师 也不愿意当，动态代理就这么诞生了 动态代理顾名思义，动态代理就是在程序运行的时候动态生成的。生成动态代理的方法有两种，JDK自带的动态代理，还有第三方的CGLIB，下面我们分别对这两种方式进行实现。 JDK动态代理使用JDK动态代理需要用到 InvocationHandler 接口，创建调用处理器 DynamicProxyHandler 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; /** * @param proxied 被代理对象 */ public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; /** * 返回代理对象 */ public Object newProxyInstance() &#123; return Proxy.newProxyInstance(proxied.getClass().getClassLoader(), proxied.getClass().getInterfaces(), this); &#125; /** * 代理对象调用的方法 * * @param proxy 代理对象 * @param method 代理方法 * @param args 方法参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String path = System.getProperty("user.dir") + File.separator + "proxy" + File.separator + "$Proxy0.class"; addClassToDisk(proxy.getClass().getName(), ProxyClassImpl.class, path); System.out.println("before"); System.out.println("被调用的方法名 " + method.getName()); // 调用真正的方法 Object object = method.invoke(proxied, args); System.out.println("after"); return object; &#125; /** * 用于生成代理对象的字节码，并将其保存到硬盘上 */ private void addClassToDisk(String className, Class&lt;?&gt; cl, String path) &#123; // 用于生成代理对象的字节码 byte[] classFile = ProxyGenerator.generateProxyClass(className, cl.getInterfaces()); try (FileOutputStream out = new FileOutputStream(path)) &#123; // 将代理对象的 class 字节码写到硬盘上 out.write(classFile); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ProxyClassImpl proxied = new ProxyClassImpl(); // 生成代理对象 IProxyClass proxy = (IProxyClass) new DynamicProxyHandler(proxied).newProxyInstance(); // 通过代理类对象调用代理类方法，实际上会转到 invoke 方法调用 proxy.doSomething(5); proxy.equals(proxied); proxy.hashCode(); proxy.toString(); &#125;&#125; Proxy.newProxyInstance(loader, interfaces, h)方法用于创建代理对象 loader：定义了代理类的ClassLoader interfaces：代理类实现的接口列表 h：调用处理器 invoke(proxy, method, args)方法为代理对象实际调用的方法 proxy：代理对象 method：被代理的方法 args：被代理的方法参数 method.invoke(obj, args)调用真正被代理对象的方法 obj：被代理对象 args：被代理的方法参数 main 方法执行结果如下，从结果可以看出，equals、hashCode 和 toString三个方法都被动态代理了 12345678910111213before被调用的方法名 doSomething我是被代理类 : 5afterbefore被调用的方法名 equalsafterbefore被调用的方法名 hashCodeafterbefore被调用的方法名 toStringafter addClassToDisk方法把代理类的字节码保存在了硬盘上，字节码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy0 extends Proxy implements IProxyClass &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void doSomething(Object var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m3 = Class.forName("cn.mrxiexie.proxy.IProxyClass").getMethod("doSomething", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 从代理类字节码可以看出，代理类继承了 Proxy 类并实现了我们的统一接口 IProxyClass，在静态代码块中，使用了反射把接口中的方法和三个 Object 内的方法实现出来，在构造方法中传入了我们的编写的 DynamicProxyHandler 类的对象给父类 Proxy，调用代理类的方法，实际上是调用父类 Proxy 的 InvocationHandler（即构造方法传入的DynamicProxyHandler） 的 invoke 方法，并把代理对象本身，反射得到对应的方法对象和方法参数传入。 现在无论是需要记录方法的运行时长，还是记录日志等操作都可以在 DynamicProxyHandler 的 invoke 中完成。 但是 JDK动态代理 是基于接口的，如果我们需要动态代理的类没有实现接口，我们该如何处理呢？这时候我们就需要用到 CGLIB动态代理 CGLIB动态代理CGLIB (Code Generation Library) 是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。 导入asm 和 cglib 的 jar 包，或使用 gradle 引入以下依赖 1234// https://mvnrepository.com/artifact/cglib/cglibimplementation group: 'cglib', name: 'cglib', version: '3.2.12'// https://mvnrepository.com/artifact/org.ow2.asm/asmimplementation group: 'org.ow2.asm', name: 'asm', version: '7.1' 先创建不实现任何接口的被代理类： 12345678public class CglibProxyClass &#123; public void doSomething(Object o) &#123; System.out.println("我是被代理类 : " + o); &#125; public final void doOtherSomething(Object o)&#123; System.out.println("我是 final 方法 : " + o); &#125;&#125; CGLIB动态代理 需要使用 Enhancer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class CglibProxyHandler implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); /** * 代理对象调用的方法 * * @param o 代理对象 * @param method 被拦截的方法 * @param args 被拦截的方法参数 * @param methodProxy 用于调用非拦截方法，可以根据需要调用多次 &#123;@link MethodProxy#invokeSuper(Object, Object[])&#125; * @return cglib 生成用来代替 Method 对象的一个对象，使用 MethodProxy 比调用 JDK 自身的 Method 直接执行方法效率会有提升 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("start " + methodProxy.getSuperName()); System.out.println("被调用的方法名 " + method.getName()); Object o1 = methodProxy.invokeSuper(o, args); //Object o2 = method.invoke(o, args); 使用这种方式会发生死循环，因为方法会被拦截 System.out.println("after " + methodProxy.getSuperName()); return o1; &#125; /** * 生成代理对象 */ public Object newProxyInstance(Class&lt;?&gt; c) &#123; // 设置代理类的父类，即被代理类 enhancer.setSuperclass(c); // 设置 CallBack 接口的实例 enhancer.setCallback(this); // 使用默认无参数的构造函数创建目标对象 return enhancer.create(); &#125; public static void main(String[] args) &#123; // 该设置用于输出cglib动态代理产生的类 String path = System.getProperty("user.dir") + File.separator + "proxy" + File.separator + "proxy"; System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, path); // 使用 final 的类会出错，这是因为 cglib 的动态代理是通过继承来实现的 // FinalCglibProxyClass proxy = (FinalCglibProxyClass) new CglibProxyHandler().newProxyInstance(FinalCglibProxyClass.class); CglibProxyClass proxy = (CglibProxyClass) new CglibProxyHandler().newProxyInstance(CglibProxyClass.class); proxy.doSomething(5); proxy.equals(proxy); proxy.hashCode(); proxy.toString(); &#125;&#125; enhancer.create()使用无参构造器创建代理对象，调用该方法前需指定代理类字节码和指定回调接口，如下： enhancer.setSuperclass(superclass)：指定父类的字节码，即代理类字节码 enhancer.setCallback(callback)：指定回调，Callback 是一个空接口，在 cglib 中有以下 6 种实现，这里我们使用的最为强大的 MethodInterceptor 接口，其用法类似与 JDK动态代理 中的 InvocationHandler MethodInterceptor NoOp LazyLoader Dispatcher InvocationHandler FixedValue 生成的字节码跟 JDK动态代理 类似，不过 cglib 使用的是继承，并实现 Factory 接口： 123456789101112131415161718192021public class CglibProxyClass$$EnhancerByCGLIB$$e0eebff4 extends CglibProxyClass implements Factory &#123; 、、、 final void CGLIB$doSomething$0(Object var1) &#123; super.doSomething(var1); &#125; public final void doSomething(Object var1) &#123; MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if (var10000 == null) &#123; CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; &#125; if (var10000 != null) &#123; var10000.intercept(this, CGLIB$doSomething$0$Method, new Object[]&#123;var1&#125;, CGLIB$doSomething$0$Proxy); &#125; else &#123; super.doSomething(var1); &#125; &#125; 、、、&#125; main 方法执行结果如下，从结果可以看出，equals、hashCode 和 toString三个方法都被动态代理了 1234567891011121314151617我是 final 方法 : 5start CGLIB$doSomething$0被调用的方法名 doSomething我是被代理类 : 5after CGLIB$doSomething$0start CGLIB$equals$1被调用的方法名 equalsafter CGLIB$equals$1start CGLIB$hashCode$3被调用的方法名 hashCodeafter CGLIB$hashCode$3start CGLIB$toString$2被调用的方法名 toStringstart CGLIB$hashCode$3被调用的方法名 hashCodeafter CGLIB$hashCode$3after CGLIB$toString$2 需要注意的是，CGLIB动态代理使用的是继承的方式去实现动态代理，若被代理类为 final，不能被继承，运行时则会抛出 java.lang.IllegalArgumentException: Cannot subclass final class cn.mrxiexie.proxy.cglibproxy.FinalCglibProxyClass 异常，而且 final 方法犹豫不能被重载，所以不会被代理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中序列化与反序列化]]></title>
    <url>%2FJava%E4%B8%AD%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content type="text"><![CDATA[在程序运行的过程中，所有的对象都是保存在内存中的，这意味着当程序运行结束的时候，操作系统会把分配给对象的内存全部回收。 那有什么办法可以把对象存储起来？ 序列化就可以帮我们做到，序列化是将对象的状态信息转换成可取的格式的过程，可以存储为文件，或者透过网络发送数据时进行编码的过程，可以是字节或是XML等格式。其相反的过程就被称为反序列化。 Java中准备了 Serializable、Externalizable两个接口（需要序列化的类必须实现这两个接口其一），和 ObjectOutputStream、ObjectInputStream两个类来帮助开发者实现序列化与反序列化。 Serializable Code只需在需要序列化的类上实现 Serializable 接口，即可通过 ObjectOutputStream 实现序列化到文件系统中。 123456789101112131415161718192021222324252627282930313233@Datapublic class Person implements Serializable &#123; private String name; private transient Integer age; private static String password; public static void main(String[] args) &#123; String filePath = "/home/mrxiexie/Desktop/person.ser"; try (FileOutputStream fileOutputStream = new FileOutputStream(filePath); FileInputStream fileInputStream = new FileInputStream(filePath); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) &#123; Person person = new Person(); person.setName("MrXieXie"); person.setAge(23); Person.setPassword("123456"); // 序列化到文件中 objectOutputStream.writeObject(person); // 重置 password 为 null Person.setPassword(null); // 反序列化到内存中 person = (Person) objectInputStream.readObject(); System.out.println(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果为 Person{name=&#39;MrXieXie&#39;, age=null, password=&#39;null&#39;} 注意：序列化到文件后，将 password 的值重置为 null。 可以看出在 Serializable，静态变量还有被 transient 标注的变量不会被序列化。 那么是不是所有的静态变量和被 transient 标注的变量就不会被序列化呢？让我们来看一下 Externalizable 接口。 Externalizable Code使用 Externalizable 实现序列化要比 Serializable 复杂一丢丢，需要实现 writeExternal 和 readExternal 方法，这两个方法会在序列化和反序列化时调用。 需要注意的是，该接口需要调用被序列化类的无参构造器，若不提供则会抛出异常 java.io.InvalidClassException: cn.mrxiexie.serializable.Car; no valid constructor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Datapublic class Car implements Externalizable &#123; private String name; private transient String brand; private static BigDecimal price; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeObject(brand); out.writeObject(price); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); brand = (String) in.readObject(); price = (BigDecimal) in.readObject(); &#125; public static void main(String[] args) &#123; String filePath = "/home/mrxiexie/Desktop/IProxyClass.ser"; try (FileOutputStream fileOutputStream = new FileOutputStream(filePath); FileInputStream fileInputStream = new FileInputStream(filePath); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) &#123; Car IProxyClass = new Car(); IProxyClass.setName("MrXieXie"); IProxyClass.setBrand("MrXieXie"); Car.setPrice(new BigDecimal("1234567.89")); // 序列化到文件中 objectOutputStream.writeObject(IProxyClass); // 重置 price 为 null Car.setPrice(null); // 反序列化到内存中 IProxyClass = (Car) objectInputStream.readObject(); System.out.println(IProxyClass); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果为 Car{name=&#39;MrXieXie&#39;, brand=&#39;MrXieXie&#39;, price=1234567.89} 注意：序列化到文件后，将 price 的值重置为 null。 可以看出即使是静态变量和被 transient 标注的变量还是会被序列化。原因很简单，Serializable 接口是自动序列化，当发现有 transient 标注的变量时则不序列化该变量，而 Externalizable 接口则是需要在 writeExternal 方法中指定需要序列化的变量。 More在 Serializable 接口的注释中，提及到以下四个方法，分别是： private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.ObjectInputStream in) throws IOException private Object readResolve() throws ObjectStreamException private Object writeReplace() throws ObjectStreamException 方法执行顺序： 在调用 ObjectOutputStream 的 write 系列方法（序列化）时，会触发 writeReplace 和 writeObject 方法： write -&gt; writeReplace -&gt; writeObject 在调用 ObjectInputStream 的 read 系列方法（反序列化）时，会触发 readObject 和 readResolve 方法： read -&gt; readObject -&gt; readResolve 方法解释： writeReplace ：当序列化对象需要一个替代的对象时，可以使用该方法，返回值为替代的对象。 writeObject：可以使用该方法指定需要序列化的变量，默认使用 ObjectOutputStream 的 defaultWriteObject 方法，该方法执行默认的序列化机制（不序列化 transient 和 static 标注的变量） readObject：可以使用该方法指定需要反序列化的变量，默认使用 ObjectInputStream 的 defaultReadObject 方法，该方法执行默认的序列化机制（不序列化 transient 和 static 标注的变量） readResolve：当反序列化需要一个替代的对象时，可以使用该方法，返回值为替代的对象。 Show Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Datapublic class Address implements Serializable &#123; private String city; private transient String province; private static String district; public static void main(String[] args) &#123; String filePath = "/home/mrxiexie/Desktop/address.ser"; try (FileOutputStream fileOutputStream = new FileOutputStream(filePath); FileInputStream fileInputStream = new FileInputStream(filePath); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) &#123; Address address = new Address(); address.setCity("佛山市"); address.setProvince("广东省"); Address.setDistrict("顺德区"); // 序列化到文件中 System.out.println("开始序列化"); objectOutputStream.writeObject(address); System.out.println("结束序列化"); // 重置 distric 为 null Address.setDistrict(null); // 反序列化到内存中 System.out.println("开始反序列化"); address = (Address) objectInputStream.readObject(); System.out.println("结束反序列化"); System.out.println("最终读取到的对象 ： " + address); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void writeObject(java.io.ObjectOutputStream out) throws IOException &#123; System.out.println("Address.writeObject"); out.writeObject(city); out.writeObject(province); out.writeObject(district);// out.defaultWriteObject(); &#125; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println("Address.readObject"); city = (String) in.readObject(); province = (String) in.readObject(); district = (String) in.readObject();// in.defaultReadObject(); &#125; private void readObjectNoData() throws ObjectStreamException &#123; System.out.println("Address.readObjectNoData"); &#125; private Object readResolve() throws ObjectStreamException &#123; System.out.println("Address.readResolve"); System.out.println("Address.readResolve : 修改前的对象 [" + this + "]"); Address address = new Address(); address.setCity("readResolveCity"); address.setProvince("readResolveProvince"); Address.setDistrict("readResolveDistrict"); return address; &#125; private Object writeReplace() throws ObjectStreamException &#123; System.out.println("Address.writeReplace"); System.out.println("Address.writeReplace : 修改前的对象 [" + this + "]"); Address address = new Address(); address.setCity("writeReplaceCity"); address.setProvince("writeReplaceProvince"); Address.setDistrict("writeDistrict"); return address; &#125;&#125; 输出结果为： 1234567891011开始序列化Address.writeReplaceAddress.writeReplace : 修改前的对象 [Address&#123;city=&apos;佛山市&apos;, province=&apos;广东省&apos;, district=&apos;顺德区&apos;&#125;]Address.writeObject结束序列化开始反序列化Address.readObjectAddress.readResolveAddress.readResolve : 修改前的对象 [Address&#123;city=&apos;writeReplaceCity&apos;, province=&apos;writeReplaceProvince&apos;, district=&apos;writeDistrict&apos;&#125;]结束反序列化最终读取到的对象 ： Address&#123;city=&apos;readResolveCity&apos;, province=&apos;readResolveProvince&apos;, district=&apos;readResolveDistrict&apos;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词本]]></title>
    <url>%2F%E5%8D%95%E8%AF%8D%E6%9C%AC.html</url>
    <content type="text"><![CDATA[「2019-5-1」 单词 音标 词性 原文 mechanism [‘mɛkənɪzəm] n. 机制；原理，途径；进程；机械装置；技巧 identify [aɪ’dɛntɪfaɪ] vt. 确定；鉴定；识别，辨认出；使参与；把…看成一样 vi. 确定；认同；一致 mechanism [‘mɛkənɪzəm] n. 机制；原理，途径；进程；机械装置；技巧 responsibility [rɪˌspɑːnsəˈbɪləti] n. 责任，职责；义务 traversing [trə’vɝsɪŋ] n. 穿越，通过 v. 穿过（traverse的ing形式）；横越 「2019-4-29」 单词 音标 词性 原文 alternate [ˈɔltɚˌnet;(for adj.)ˈɔ:ltərnət] vi. 交替；轮流 vt. 使交替；使轮流 adj. 交替的；轮流的 n. 替换物 Subclasses may implement this method to allow classes to * be fetched from an alternate source. equivalent [ɪ’kwɪvələnt] adj. 等价的，相等的；同意义的 n. 等价物，相等物 「2019-4-26」 单词 音标 词性 原文 sanity [‘sænəti] n. 明智；头脑清楚；精神健全；通情达理 「2019-4-22」 单词 音标 词性 原文 correlates [‘kɔːrəleɪts] n. 相关 overlapping [‘ovɚ’læp] adj. 重叠v. 与…重叠 crypto [‘krɪpto] n. 秘密赞同者；秘密党员 encryption [ɛn’krɪpʃən] n. 加密；加密术 cryptographic [,krɪptə’græfɪk] adj. 关于暗号的，用密码写的 graphic [‘græfɪk] adj. 形象的；图表的；绘画似的 authenticate [ɔ’θɛntɪket] vt. 鉴定；证明…是真实的 sophisticated [sə’fɪstɪketɪd] adj. 复杂的；精致的；久经世故的；富有经验的v. 使变得世故；使迷惑；篡改（sophisticate的过去分词形式） interaction [,ɪntə’rækʃən] n. 互动 relevant [‘rɛləvənt] adj. 相关的；切题的；中肯的；有重大关系的；有意义的，目的明确的 protocol [‘protə’kɔl] n. 协议；草案；礼仪vt. vi. 拟定 emulation [,ɛmjə’leʃən] n. [计] 仿真；竞争；效法 proximity [prɑk’sɪməti] n. 接近，[数]邻近；接近；接近度，距离；亲近 Accepts an NdefMessage to set as the message to beam. Automatically beams the message when two devices are in close enough proximity.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker上部署常用镜像]]></title>
    <url>%2FDocker%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[简单记录本人开发过程中，各种docker镜像的安装部署，我个人测试习惯会将对应镜像挂载的文件夹放在root目录下，例如tomcat镜像的挂载目录路径为/root/tomcat，其他镜像类似也是这样。 一、Redis1、pull最新的redis镜像 1$ sudo docker pull redis 2、在redis官网下载最新版的redis，并把redis.conf放在/root/redis/目录下 3、修改redis.conf文件 123456789# 注释掉`NETWORK`中的`bind`和`protected-mode`，为了让在宿主机中能够访问`redis`#bind 127.0.0.1#protected-mode yes# 修改`GENERAL`的daemonize为nodaemonize no# 修改`SNAPSHOTTING`的dir为/data/dir /data/ 4、启动redis 1234$ sudo docker run -p 6379:6379 --name myredis -d \-v /root/redis/data:/data \-v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf \redis redis-server /usr/local/etc/redis/redis.conf 5、测试redis是否已经启动 123$ sudo redis-cli -p 6379127.0.0.1:6379&gt; pingPONG 二、Tomcat1、pull最新的tomcat镜像 1$ sudo docker pull tomcat 2、在tomcat官网下载最新的tomcat，并把conf，logs，webapps放在/root/tomcat/目录下 3、启动tomcat 123456$ sudo docker -p 8080:8080 --name tomcat -d \-v /root/tomcat/conf/:/usr/local/tomcat/conf/ \-v /root/tomcat/webapps/:/usr/local/tomcat/webapps \-v /root/tomcat/logs:/usr/local/tomcat/logs \-v /root/tomcat/pic:/usr/local/tomcat/pic \ # 配置存放图片的虚拟路径tomcat 4、修改root/tomcat/server.xml文件 12345&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;!-- 配置存放图片的虚拟路径 --&gt; &lt;Context path="/pic" docBase="/usr/local/tomcat/pic/" reloadable="true"&gt;&lt;/Context&gt;&lt;/Host&gt; 5、curl http://127.0.0.1:8080访问tomcat默认主页 6、curl http://127.0.0.1:8080/pic/song.jpg访问pic目录下的图片 三、Nginx1、pull最新的Nginx镜像 1$ sudo docker pull nginx 2、在nginx官网下载最新的的nginx，把nginx/nginx.conf复制到/root/nginx/nginx.conf 若我的需求为，通过wx.mrxiexie.cn映射到8080端口，则修改内容如下： 若你的域名为中文，不能直接在配置文件中写入中文域名，需要转码，以下为转码网址。 http://tools.jb51.net/punycode/index.php 123456789101112131415161718192021222324252627282930313233343536#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; upstream wx &#123; server 172.16.0.7:8080 weight=1; &#125; server &#123; listen 80; server_name wx.mrxiexie.cn; access_log /var/log/nginx/access.log main; location / &#123; proxy_pass http://wx; &#125; &#125;&#125; 3、运行镜像 1$ docker run -p 80:80 --name nginx -d -v /root/nginx.conf:/etc/nginx/nginx.conf nginx 4、外网通过wx.mrxiexie.cn成功访问 四、Mysql1、pull最新的Mysql镜像 1$ sudo docker pull mysql 2、在mysql官网，下载最新版的mysql，并把配置文件mysql.cnf文件放在/root/mysql/mysql.cnf下 3、运行镜像 12345$ docker run \-v /root/mysql/dump.sql:/docker-entrypoint-initdb.d/dump.sql \ #把需要启动容器时运行的sql放在`docker-entrypoint-initdb.d`下-v /root/mysql:/etc/mysql/conf.d \ #挂载配置文件-p 3306:3306 --name mysql \-e MYSQL_ROOT_PASSWORD=123456 -d mysql #设置登录密码 4、进入容器，通过mysql命令登录到mysql命令行中 12$ sudo docker exec -it mysql /bin/bash$ mysql -uroot -p123456 五、Nexus1、pull最新的nexus3 1$ docker pull sonatype/nexus3 2、启动nexus3 1$ docker run -d -p 8081:8081 --name nexus -v /root/nexus-data:/var/nexus-data --restart=always sonatype/nexus3 3、nexus3启动过程有点慢，稍后在浏览器输入http://localhost:8081 六、ActiveMq1、官网下载最新版本的 ActiveMq 2、解压，并自定义自己需要修改的配置文件，若不需要修改可以跳过这步 3、编写 Dockerfile，把 Dockerfile 保存在与解压文件夹同级目录下 123456789101112FROM openjdk:8RUN mkdir /opt/activemqWORKDIR /opt/activemqRUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt; /etc/timezoneCOPY ["apache-activemq-5.15.8", "/opt/activemq"]EXPOSE 8161EXPOSE 61616EXPOSE 5672EXPOSE 61613EXPOSE 1883EXPOSE 61614ENTRYPOINT /opt/activemq/bin/activemq start &amp;&amp; tail -f /opt/activemq/data/activemq.log 4、在 Dockerfile 目录下执行命令，构建镜像 1$ docker build -f Dockerfile -t mrxiexie/activemq . 5、启动 ActiveMq 1$ docker run --name activemq -d -p 8161:8161 -p 61616:61616 mrxiexie/activemq 6、浏览器输入 http://127.0.0.1:8161 即可正常访问 七、Gitlab1、pull最新的 Gitlab 1$ docker pull gitlab/gitlab-ce 2、启动 Gitlab，以下配置只为本地测试，使用了 127.0.0.1 本地ip，可以把ip换为公网ip，部署在云服务器 1234567891011$ sudo docker run --detach \ --hostname gitlab.example.com \ --publish 127.0.0.1:443:443 \ --publish 127.0.0.1:80:80 \ --publish 127.0.0.1:66:22 \ --name gitlab \ --restart always \ --volume ~/.docker/srv/gitlab/config:/etc/gitlab \ --volume ~/.docker/srv/gitlab/logs:/var/log/gitlab \ --volume ~/.docker/srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 3、修改 ~/.docker/srv/gitlab/config/gitlab.rb 文件 123456# For HTTPexternal_url "http://127.0.0.1:80"# For HTTPS (notice the https)external_url "https://127.0.0.1:443"# ssh portgitlab_rails['gitlab_shell_ssh_port'] = 66 4、浏览器输入 http://127.0.0.1:80 即可正常访问]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gradle打jar包的几种方式]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8gradle%E6%89%93jar%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、不借助manifest文件 若有a.jar，b.jar，c.jar在同一目录下，主方法所在类全类名为cn.mrxiexie.jar.Main 12# jar包使用`:`分开，最后指定主方法所在类全类名即可java -classpath a.jar:b.jar:c.jar cn.mrxiexie.jar.Main 二、借助manifest文件 若有a.jar，b.jar，c.jar在同一目录下，主方法所在类全类名为cn.mrxiexie.jar.Main且在a.jar中 修改a.jar中的MANIFEST如下 123# a.jar的MANIFEST内容，jar包使用空格分开Main-Class: cn.mrxiexie.jar.MainClass-Path: b.jar c.jar 执行a.jar 1java -jar a.jar 三、打成一个jar包 使用gradle把多个依赖打成一个可运行jar包，主方法所在类全类名为cn.mrxiexie.jar.Main 12345678910jar &#123; from &#123; //添加依懒到打包文件 //configurations.compile.collect &#123; it.isDirectory() ? it : zipTree(it) &#125; configurations.runtime.collect&#123;zipTree(it)&#125; &#125; manifest &#123; attributes 'Main-Class': 'cn.mrxiexie.jar.Main' &#125;&#125; 执行jar，即可获取一个jar包 四、打成多个jar包 使用gradle把多个依赖打成多个可运行jar包，主方法所在类全类名为cn.mrxiexie.jar.Main 123456789101112131415161718// 打主jar包，并编写manifest文件，编写结果如方法二jar &#123; String str = '' configurations.runtime.each &#123; str = str + " " + it.name &#125; manifest &#123; attributes 'Main-Class': 'cn.mrxiexie.jar.Main' attributes 'Class-Path': str &#125;&#125;// 复制依赖包到libs目录下task copyJars(type: Copy) &#123; from configurations.runtime into('build/libs')&#125;// clean后，执行release即可获取多个jar包task release(type: Copy, dependsOn: [build, copyJars]) 执行release，即可获取多个jar包 执行主方法所在jar包 1java -jar a.jar 参考： https://www.jianshu.com/p/5bb1e87df15f https://www.cnblogs.com/yjmyzz/p/executable-jar.html]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之firewalld防火墙常用命令]]></title>
    <url>%2FLinux%E4%B9%8Bfirewalld%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、firewalld启动关闭 启动：systemctl start firewalld 关闭：systemctl stop firewalld 查看状态：systemctl status firewalld 开机禁用：systemctl disable firewalld 开机启用：systemctl enable firewalld 查看是否开机启动：systemctl is-enabled firewalld 查看已启动的服务列表：systemctl list-unit-files | grep enabled 查看启动失败的服务列表：systemctl --failed 二、firewalld-cmd指令 查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 开启一个端口：firewall-cmd --zone=public --add-port=80/tcp --permanent（–permanent永久生效，没有此参数重启后失效） 查看端口是否开启：firewall-cmd --zone=public --query-port=80/tcp 删除一个端口：firewall-cmd --zone=public --remove-port=80/tcp --permanent 参考链接：https://www.cnblogs.com/moxiaoan/p/5683743.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap底层原理]]></title>
    <url>%2FHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[一、JDK1.8之前的HashMapjdk1.8之前，hashmap的数据结构为：数组与链表的组合 新增的元素会添加到链表的头节点（快，只需要指定下一个节点） jdk1.8前hashmap的put方法： 1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); // key值进行hash运算 int hash = hash(key); // 根据hash值与hashmap长度，求出数组索引 int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 如果存在该key，则返回旧value，并用新value替换旧value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 链表中添加节点 addEntry(hash, key, value, i); return null;&#125; inflateTable方法： 12345678private void inflateTable(int toSize) &#123; // 求出数组长度，其值为2的指数幂，若传进去的大小为5，则求出值为8 int capacity = roundUpToPowerOf2(toSize); // 数组长度（默认为16）与加载因子（默认为0.75）求出阈值（临界值，默认为12） threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125; hash方法：hash算法，减少hash碰撞，进行右移运算，为了让索引分散（添加查询速度） 1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; indexFor方法：根据hash值与数组长度计算出索引 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; addEntry方法：添加新的节点 扩容有可能会出现死锁的情况：http://www.importnew.com/22011.html 1234567891011void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 扩容条件，当hashmap大小大于阈值，而且新增值所在数组的链表不为空，才会进行扩容。（也就是说，不是当hashmap大小大于阈值，就会进行扩容！） if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 扩容，长度 * 2，重新计算hash值 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; resize方法： 1234567891011121314void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 初始化新的数组 Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; transfer方法： 12345678910111213141516171819void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; // 重新hash e.hash = null == e.key ? 0 : hash(e.key); &#125; // 计算新数组的索引 int i = indexFor(e.hash, newCapacity); // 该元素的下一个指向原链表第一个元素（第一个元素进来时，该值为null） e.next = newTable[i]; // 该元素成为链表的第一个元素 newTable[i] = e; e = next; &#125; &#125;&#125; 二、JDK1.8中的HashMapjdk1.8中，hashmap的数据结构为：数组与链表与红黑树的组合 新增的元素会添加到链表的尾节点（由于每次添加需要遍历链表以获取链表长度，所以直接遍历完链表后把新节点放在链表尾部） jdk1.8中添加了以下两个属性，根据这两个属性进行链表与红黑树的转化 1234// 数组中某一索引链表长度大于8时，将该链表转为红黑树static final int TREEIFY_THRESHOLD = 8;// 数组中某一索引红黑树长度小于6时，将红黑树转为链表static final int UNTREEIFY_THRESHOLD = 6; jdk1.8中的put方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) // 数组为0时，则初始化数组 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 当key的hash值对应的索引数组位置为null时，直接把新节点放在数组中 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 新增元素的key与链表的第一个元素的key完全相同 e = p; else if (p instanceof TreeNode) // p为红黑树节点，说明该数组对应索引的数据结构为红黑树结构 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // p不为红黑树节点，说明该数组对应索引的数据结构为链表结构 // 遍历链表（为了计算binCount，也就是链表长度），把新节点放在尾部 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 当链表长度超过8时，转为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 当hashmap长度大于阈值，则进行扩容（跟jdk1.8前有点不同） if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; resize方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 链表，并没有重新计算数组中的位置 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 示例1：若原长度为16，扩容后为32，e.hash为108 // e.hash &amp; oldCap // e.hash = 108 0110 1100 // oldCap = 16 0001 0000 // &amp; = 0 0000 0000 // e.hash &amp; (oldCap - 1) // e.hash = 108 0110 1100 // oldCap - 1 = 15 0000 1111 // &amp; = 12 0000 1100 // e.hash &amp; (newCap - 1) // e.hash = 108 0110 1100 // newCap - 1 = 31 0001 1111 // &amp; = 12 0000 1100 // e.hash &amp; oldCap 为 0 说明扩容后位置没有改变，还是12 // 示例2：若原长度为16，扩容后为32，e.hash为25 // e.hash &amp; oldCap // e.hash = 25 0001 1001 // oldCap = 16 0001 0000 // &amp; = 25 0001 1001 // e.hash &amp; (oldCap - 1) // e.hash = 25 0001 1001 // oldCap - 1 = 15 0000 1111 // &amp; = 9 0000 1001 // e.hash &amp; (newCap - 1) // e.hash = 25 0001 1001 // newCap - 1 = 31 0001 1111 // &amp; = 25 0001 1001 // e.hash &amp; oldCap 不为 0 说明扩容后位置发生改变，位置 = 原来位置 + 原长度 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 三、JDK1.8之前与JDK1.8的区别1、jdk8前是使用数组+链表来实现的，jdk8中使使用数组+链表+红黑树来实现的。 2、新节点在插入到链表时插入顺序不同（jdk8前在头节点，jdk8中在尾节点） 3、hash算法有所简化 4、扩容机制有优化（解决死锁问题） 5、JDK1.8中旧链表迁移新链表，链表元素相对位置没有变化，实际是对对象的内存地址进行操作，JDK1.8之前，如果在新表的数组索引位置相同，则链表元素会倒置（A -&gt; B -&gt; C 会变为 C -&gt; B -&gt; A） 四、面试题1、为什么hashmap大小要2的n次方幂？由于key值对应的数组索引，使用（hashmap长度-1）进行与运算来确保数组不越界 2的n次方幂，其2进制特点是1开头，后面全是0，以16为例，16的2进制为：00010000，参与h &amp; (length-1)运算时，16-1=15，其二进制为：00001111，参与&amp;运算，前面全为0，确保了最大值也是15。 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1);&#125; 2、jdk8中HashMap有哪些改动，请说出三点以上主要看第三点区别 3、JDK8中为什么要使用红黑树？链表的特别：插入快，查找慢 完全平衡二叉树：插入慢，查找快 红黑树：基于链表与完全平衡二叉树间 4、HashMap扩容机制是怎样的，JDK8之前与JDK8有什么不同？jdk1.8前是重新计算hash值，再重新计算在数组的位置，1.8中，key要么在原来的位置（index）上，要么在原来的位置 + 原来的长度上（index + oldCap） 5、为什么重写对象的Equals方法时，要重写HashCode方法，跟HashMap有关系吗？为什么？计算数组下标的时候需要用到key的hashcode，如果不重写对象的hashcode，在当该对象为key时，则可能会导致存放在hashmap中的数据get出来后为null 123456789public static void main(String[] args) &#123; HashMap&lt;Person, String&gt; hashMap = new HashMap&lt;&gt;(); Person p1 = new Person("MrXieXie", 1); Person p2 = new Person("MrXieXie", 1); hashMap.put(p1, "MrXieXie"); // 若person未重写了equal和hashcode，则返回null System.out.println(hashMap.get(p2));&#125; 6、HashMap是线程安全的吗？遇到过ConcurrentModificationException异常吗？为什么会出现？如何解决？HashMap不是线程安全的，在使用keyset遍历的时候，移除hashmap的元素就会出现该异常。 12345678910// ConcurrentModificationException异常for (Person person : hashMap.keySet()) &#123; hashMap.remove(person);&#125;// ConcurrentModificationException异常Iterator&lt;Person&gt; iterator = hashMap.keySet().iterator();while (iterator.hasNext()) &#123; Person next = iterator.next(); hashMap.remove(next);&#125; 1234567891011121314151617final Entry&lt;K,V&gt; nextEntry() &#123; // 由于 modCount 与 expectedModCount不等而抛出异常 // fail-fast策略 if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e;&#125; 应该使用迭代器的remove方法： 12345Iterator&lt;Person&gt; iterator = hashMap.keySet().iterator();while (iterator.hasNext()) &#123; Person next = iterator.next(); iterator.remove();&#125; 123456789101112public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); // 移除的时候会把 expectedModCount 重新赋值为最新的 modcount // 如果直接调用hashmap中的remove方法，是不会把 expectedModCount 重新赋值的 expectedModCount = modCount;&#125; 7、在使用HashMap的过程中，我们应该注意些什么？若知道hashmap的长度，应当在初始化的时候指出，不然当hashmap长度大于阈值的时候会resize，此过程需要重新构建数组，重新hash，重新计算索引，比较耗资源。 12// 默认长度为16HashMap&lt;String, String&gt; hashmap = new HashMap&lt;&gt;(16);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[峰凯小程序二次开发]]></title>
    <url>%2F%E5%B3%B0%E5%87%AF%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19hnAjrj0C8gKK0kofoB3R2OE3BC1Hgo73o3MZidszHw5Q/C6zmfDJ4N0UVCzTwT5/uSejdjpI++mmt8ccHawCli7BlFj6HvhxtR4g7Vszz0/9a2YwpcvnaumVI93NUFzZqEaLRO0vJQ7Gp8sMsqjFgJIXQNqfDef0baoOsa3OcCJE8COhnHktSWPTmV4C0rqODhl5XUKET8o2sfR4jgslElmfF7w3UhFzAmc2udp9a3DCtvdfnjXXVbED0vefNMN7NRnXugy9Jw1Y3+7P5+LM3umJNvehOlJRe/RSB9ZpAhQBUXarcMifd97DSTAXcEQ79UQzAmzxpPz9PaTnJNICae6mvqFH6wlFOfkindwNa/SXfa+EcHRocoNo5w8ySq/nmf+GkT8jneDAipYIUnhb2xKnpm3Sf8fl3tzIBWpOWheln6Fn/v3Y6gXfioqkCeQLR9hL75ld/Vszy2xlcS3lJyHGbwdkWg6gAHHbD8KKKVxmmg4paH/nfs4Oe4NFQA1bn5LDfzqhtLCAPaOjHtv4mDSdUNSDuikriVlwSvK0p8Ca1w4YS7SVZTzAVzwrYdwnkbeyZmr0L385TM6jQ7p1GnLttCIWziW9yWpvxZMZvEwGvNJ0E2taE9fkdFlWxwuHzGVvqgtCCSHnra7jg7EhYJqy0zVRSkc4vrtQE3Vh7wAQYqOS8aaWXnY3DgjwI4nZme5pSrnqE4zgX69yruFu+h5THv2sL04cymd2TW5pDwm/H4xzncrAbPZFSTEit9SKNjYMQTjY7JHryPjhMdP22/J7XIT/OK9NmOyWXKiHvew9YnwXImlnuPTBZjyixqhdxYQBIVre+mKjOzNM2jKA/9g6cyV3CnkvJHfnzQaOaMx/H4U0LXj70qF7nVsvfUyqMIuXVhdcco82o6110jOvSbkCFumiw5QXcxA2vpkzKCPzo6b0uAsRAuOI3mlKnQEKlAryf0svuAllwc5ndBAmELU3y7Y9qk7XcJX1o59Pabie2cbzcww/Yh1BxQjRlvvsOHnMEOFMMX6rvHduNItwqaw/CQ3YeBglrEOJT0F2M+aK2nR5PELJHJZUpnTDRk6ZVevIDgp8DJYkZx+NFh/uVqzc13qaOLqGwBO7oiybrLj+CjO1598ZyveFa0AoPUe1TXojdu5EH8m4TlEaLCMRB9nhcUkQ4E9sXErObbbEGSRFpMyz31o9AEoUbNdTa9QDAlDjkdcRQb7QXBSXE9psdUCekQyP5OrNK2LmdpYO/aVq8OfloOPJAT5Wm1fXXWwc/Gxt1UaUSjf6r4oRtXfpNmEJA22aZTJvRNwFDuB0jxkoRUN+PJ6rMMEqmuU+n19dxqT8a9LfAyJ8WDXK7YjKwstCJ04niIFprwCGmRHMfxhv/+lFOlKoM75h7ItxmPLpYNHkjw7vPfTmRzONtapzOHpbA0uUnX16myGTpAO0u9Eeyxzr03dGJalYBjyC1480FM0T09IKVdks0nIeBXLpz2yj3i6Y1TebqtwNLTNpvM48qdCKmGp200Hz4pkgNhUxs7vunD3wPrQTkLKrdwodG83SqvN+2efF+JsbY0CH0NiDiZhqMzTC9IVpAwcncX7nM2qTCcY5vBQxUtUXav3sFkF1Zqz3F+6245FRitqKex3g6YO1mYPnvSwgRFbgle8jxGkgfm2zvlGkn/U47b1ufXLt/5yhbMmWigIkGHSQxTdWSEG968vi2Q+JyPB92cY2XVyWh58FA0SJf7p98/IiH+p1P5vidD8QZD3MDYy6K+e1w0HM7kRwFZQcR49U3kmnAOitMf3qD0ZVmniP4voyl2BO1M69SL8zzgfZI1l+h5qmtzWL8QfZsqaE8b4ByixU09opD6tx/UrEZLQ/thfhw3wxfK06eJ27q+C8Yovxlt8ciOPS/fMUDcmKIFOqvs6ObL5FzZIF//9dHDu9uxpE3BLbPvcxPIQTD+n3PM0mfGawzL/URZQKG5vFuPn2+SdrAk08GHF11w3KI9LOzTetaDaKdCVjNIa2jeXzem3M7fVxFQBulpkWcKxUYf89ufM66xiVet77KDyYrZsIraqqeNkifA88Holyf/h1bkHMIytlj5W9gHVghfVIMFDhVw+YwRQTxXf/I39zMxdFXPxREDHGE621SD0On8xt2Dz8QKM48VHhO0Gc1Vy0CZPq/db7mnnww2LItfQuxWcs7gbcrea1cE524fiXdXFwt2OBQx+fOl35bHX7qYPQ4j6/bBK2w3ixAy2gb2xtmOR3GcjgVDa/tZPpMyOCPCpT1qXe7o8GoyyKROgkwFp/qIY6kzzXs1ZBfP/FvIghWcAjux10k2rVJw2H2kBqk937XNEj8Bff3M97V51ynmBLaN+BMDh/OPonf3EJrd5YXpqYo2fk2iNDe2rXR39wrZxTQI1jEznPDqWFGRvEvWK6ld+sddREZpKpq5zgo0K8ka2b2MNKm8N8kLXHeW7iVbLI4MxEguShskkTaRf8s2sPNdC6Vc1/+tlQotRt6cZUL0/jxLQJRloFErVWvPEtNNgrt6eWk+GuzHD5A6dfYmMyq4937YUzb61rcrEZ4+AoHBbeNBzvKhhyLKsDJM+btQ6oGCjFv3ODEXrBcu5r2raQQF8r/vFAFyjfcXj9sO8Q1Wxx30cVTN1Hy6crPtHH0rmr4rkabD6Ga0b0t4oZwNc54PpTeJpoQxQNGsUkaVEF5MZzcdnZ0Bd/O+HkxvzYxbR8bRpK/G8lhjqqYFzqlZSJi87Bz/HoBZzIRO8ntSGmlTLz3hmdtffrVm87Wc9HWqw96PV9HKZLxo+QrjU+tU5nE7ZQ76NLVSKU9WYfgAeNYX45ljLsMvsxToVe7xj2JGpSgA7vWdtpVEyOsB7DPa5vkbKGu13ErkXjXD12PJ/eEuRqR9sMcbRb0imsIYQKtZhvCHoN0PaRVm0axDhR7DrMxYsCTiYS9/KRzMls2Urqa+wlTkTiW1EsNQK8yHvanfCn512DCt5vKNJ1oikZMOWu+cbt9+6BSkpdBA7Psg+nrtCNKfRhPu2/umO/T9UEByI20kXciQChB+jd9ixf0zxzf21GWDlR6U8DNxqFF9dmHeVeOm4C3I22tt3Iz6m8T1PJ195qeXRPWlaWSK/WBTFx6BQita34rgzcxFcUS3G09S7C576CumjBdM7VaWUvfMAwFUXYavjbk0gnPHy9oyZgISUA8pCDuGJp4ZhFG+/Tr3UNykxOJtaSSqZzjyT4hI8v7UlgIOeFqyh2b6mouDNmHBYBrIs/WXLZ/j8OrXlOHukmhMYCbVDSF1qo+k5mgmNpnnTIW8ymxZFgYuVRhs5ghD8mEf5CuvRaBFcX9MyfDTGLf1t/kFbqFNKm3JDUIJeEwdX45iMDYOBMbDqSuZLTLiAmKl8j18qUlc3jqrGRwvWy4+L39Cc2VHDxGAaYeWP3rJ/C1FRNXHqOusJ27DgM85QB6r5H7JWshHXRnRsas6k7cpG7072v1j/NpnEa+NsaWA7gXf9YDQnMEpQ0KybWWdeJtLu1/a6CIpqf5TquZ96+ce1ZY3CLk0xiZrz44bbXSzYl9E7jFlSEa5YWO5Rjq1THuQiWZTGDBMZrEZWXAU+KXu/cdQKmYvfWK+23/ISdaf8Cg91P8kntX0i+rkrKnQNW930Xtk9ylgDzhnOsBeriKwQdE6F9ZGvy9gGR8dd3OWXtW/bHF3l1y4h3vT8bGo9WfAeSNzdUgPQKAGbOsJYWifpAwjrZMaSMYzFekQgTORsotgc5URdsDn31LEGUhl1Vc6PZtvTuisAd9rekrIKSuFM08HpOTqZz9aPIDHt2qbcqUtHo6wYQZBZtYovnu7zWZ7Y4dSA1SSQ+KYvGEKqT66mMSh21ARxW97YEyhDzoZjSJYtwpj53DjeDoqc0VNu7uqD6xXna6YgrcsnGbxGypTTSBpvSA+ciDr/uBaUMSMv5HD3b94pBbc7U5mJ8MzwvmqLE7Pj7NGwMT3D/b3HGPdZa89Si0bBF+kwRbjsJPqdhojR6YltwWkVQ2uqZW6YgCZ5JCfqXciywsSuRMrJW3gLtC3jgGzWc8rB5jVzrH0sCJXN139LeMQNlA1y0ln94ozCbAk3v9JjMcMA4qLh5JzH1b5nu0cHSt0Ya9SqNcU84nz+74R3ZUh6bkwI3L49ZOYHcyu5OovYil7v6CF2rjnAvhiLL2XmIIG2pZ1ojXK75rNk9ikBsP6Px+KegnwVKqaV9P5JvNgcyJUhXB3COt7QP8vc09oJ9efThQygJCYdSPa/JFDUg50h4MWyFRGECO2lt0C6Ui7bUlckA/4kC5wjmCitwbr0fGIZ0dJ9IBrB36NzJmuOVD0qQrVDW9lrfRngHHCmToScTs1WA1BU84yPbQc48NypjqMEPuMq9Jd83bo3jAClLWfCjQH6zmVbX1iaGh78hDuhjvyfetJM5I9Gfk435jo+n7vLLB8plCO0qr8JAeq6+QK1xTJk+GzntvIUPlHFj973ZbeBTysxOjVChe5NZEv+lqjzkpZ82efQWo7SRhhepkLbS5Ur9zbKjs3B/sYu3ZHsQVGvYoavrK5xMJaMw2XNulBJuAnVd2RrFQhRilGwqd+22ODP/K0uOUhy34ZmcxiDk/mQwC0rflMx4Wljvs47dDbenrXYiomjRGhKc6dAXX9Pf1pgDRjeSvXOTrNwfhg74viWagkTxpNnLT4kw9DMlEd1gV21YZbWKZm96dtiGcBPrlGLiTTnZ0PW/rx3HIqoajZ02Bdm0lKo24bbOMiVn/H7ZvzTIPGH3a8UpH/zL+dC6NoRLdhmKjI+MJQzGAZaP+keTN4Iv7MeCmtaj4urwTSI80vvRiIBFQy+vIfVJi/ZwFZ05a56YGzJnuXzFLzES3ctdeEfNuVCHTbd50FA38pZDuf9sBEYDGii07UrrLIeTBdEfxwWn1j7eo8JAWPuehMgsPl6kFfHqSuR5dLu3jPC+gkXu9jV5GrMJgJA433pweJlPy+scaRs2jtGaehZ0oTLWBhr3gyVQ/WDI5FjrjipMEByNgFASJJQYVKHJozKSSIo1Es00I5cxqfE1qTaKubId8snccrJ5E0iLWEZ6/UCP2W87V88TvnY5Yg2IHYGOPuD3OE2JWaZDCC000BiJBXl50lC/FvMnyyiOQvgLIY7gSaV9zrS+i2WNP2NPBC5yY1WNZynJBGoXt+bS8SPf7BLSJshVrg1sgEvza3xOEUUufb7LTH+IaA19Aav0O1ZY3BCCgH7uwh5te7N40OOWUZbOdNto7nFKjDJoQvp2SWM9Hvzt1Lb8E75YYDIn4BnpxVfSEjb3wkDSnZ6dfJwUlatQYdnVThsybKZ0ajweO9yxrzaj2TNr+tiCx9RltwfQuh68WmAlDYWZAnuOrF6x4xdp47QZbMR0fvtuB6zpEswl5UWkh8Ir4qXL02WvyMkaijgKyzgasII7TL0vNkYGP6dWQDoP66j68jU6Yr4h9lEsThr81n9PwkZO8q9++RhJnGMses8l25qrCUH+QtStlfUqxs98qimIfs9XJG3IGXL58BQXS0oN/VuhmyOXcdXP9w6tPOGBJpDTbh8wBHnOJscL2xAG/u/9228+3Eeh2TRZKzJLYMDu8/Y5p9vyPVDKlUfzpu1935kiPiaqAp4tI/yuvrYMBjk5BlWSsto8+174QcEdIIiaJAXzcmdebrZFM+ZBmj/9uSssH5GJYz8ObpeNgsitGwua+Yf6AO0RM+7QGYTF3Of/LkpVO10K/NIpij/GVDs/aVk4DKF302PI5WzpwV3F4m7r77AiBPu7fnYhFpnH8VIquCxCvOcFtSOQk9iQKl/rSESulIjXIt5pR8fWMkjrJ4HHrnSM4NrD71yUAvf/syHkAQwQ5wJUNLq8RumgbimC151qmxf8gDkFEb7lA1Z6T9wsBP8diKwFS3935z6LvXnFEK38E6Sg0V6Ofh/6FgS0Ix7Bf/4LDpLT2oAYmKmYYNF8HShRXLpWpcqpN1etPyYKM/cY5m19dCe4J05aP6OGbdGCv5hMfb1/IyaUypQ7d9e9V+FFZLPCTMdveyFR712zXOxUdZ+ddn+7I94OvXb7NLNjCo2yyL6vvvkg3yoAEZmO55SIEwoH8vyONHYZvNJbI7TDGqa6wTYAFU5sI4uT0qFHXATQWuLhwV1XPFuGR3GBKsZ/YYGl/Otr7D06DVPIryOGlQYcYmqL2vekR0t4zNzTDNh1wdCtIoAP+eSoVXdf4Tp5bZSn+81S4b3bMyfoaSa2bXM6OSJwoXCxsrF8ItUP5ThQXmsPUtCauBxvgMZI0fNzuAcIlG5ewYzyQ3/jYQCyvHf6Q5+4l+o7lex62JKWfJ1nhci0DDfOVb80U63g++/L4RWqSdb146PK5++0kRgKHrHWUUjS2FDfjByEzOJ+vbP6C5/4IQqOjouK3RqZkQ4ZGMW03ahCc7j5Lw9I1jB8kTUb5e4vPOvFF3jl0sx2UNK2XByOR8BpTuq0S9kFEo8m4bhaOwBLnrw6Gj+Iy2mpkIYXnLm2cQxuJq3fskTlWX39qxhL6Ivy55RH/Q/XZ9RV1mmQe8VRm4wr2C0++IkNlGZ1R59eOqJxW1wK7qfx1KngzIQQaOftA7vsNh2Irx5MSh+7BjqsDM44zqCupfFmmh+4+lEZcrEofrxz3ZxuggCw+cDzLsWOfoK8Vv6GjrJjKje76slOajejOVmw1i0cjznHmTmtNgAn3Wmbg1sTCdwCGx97KDeHdvo3KCH0mQeBrk4mmp5rkahDpXUf4ApMH7TwhQowqbbbX95I2kbwsFX+c0VIog5HAYykeJtY+hB3LYUhDean5QJBNup9KlPvS10dG/N7LvVUbJtxAifv4j9VgVYCnG4hb7Xdd0tD27qGXlSomUcEZ9Zh9cp9DwX+L0JapG0FDSbIwQ8puAFhpbfMtS86v3SGTUWdaageg79Z0xnpSQ19h18IzwG4zGxpZbpL0mW5c1juZHcmx5nyx1/6YyTnR1vwaQlwmMJxzDHzKaIzEkrTXUWk7eW8EISR9q5cd1pVtwLDEd3cvn9tsYnf45emat+qdHsgTu7SX5ZsTso72dVSsDr3SCJpXj8jFN8NdKUlo1EZCSJ9UI7jehIotwNxCba3ACn0WwLpfPmyeum9+/IgoVzPuja37bEx11L8G2a0sy4vOUcgOjb4TRgXq8xMF9uyTXIb2+7wz56d+ccQqzxRx6pBC4gg4Y0Zhow1bCKsfSa1kfU9Z2XM4LaUTSXQHfyotSzEpNOAdn/wi3gMU0GXsc2Ftc3RqChjwlddY0umpE1lYWV49eO6bQ5mwL5QEAmUuRHXHyGSJokjfzyQlUBJDL7gSl+Dcf7Dt3if6+p00dHSGJCRn56NRuP9XGwi1apCw2ztwd217i5PSPMF7Hazs5BV23/UlDmzBhdiJGFq+bftP0Etq44qWmZiZ2JA5hUYVjrcdzLOqdfHsswfhep6qjBQQc4LukJpYhXsqHhg1AP6c8aKI7ywLAX0WEtViFLD5s3nIk+CpcsRb7KKky2fpHkMXpYL6CDynTWGTcuwtEeFLWjbYJx+TuJcIJ55GzB/avyT6b/NygnbO8YE55d0FSAtPWkaxjsGxIyKhkOpa3LXw7emdZYLrid9q4gt30abLOBVczsXHCtPA4fSluzqKG0gU94cJ6IOCd4Y4hcBoXdp07YFpyCqYwWtM8810Mbx6YrHLIsAVsneKOkZ1t3JEo/bhm3/wduYOMtQB2+Di4188c2VkfO6r/mbhb2wSiVKdYugcRTv1D1AceHtWhA9KNheqfZ/smb8VKt77ELg2/3m0nNDiUZdil043IlptrNEjLBREQ4VxwlHNG4u9tMsjFLmMXXHy4c6PlgkTDGT6HUzBU/xDgHO14MX7wT6rDrmRXsGxg/suA3Q7CJ0BNa6lGW+63b5gkVlehRU7GviYG3kqD0WKE7gHu7pMk5DWyQ536OwmsKI6+qsdtTsoIEVNd2e8/7VvXIZl43LMM1jtrPZ9HZDoFz/+tMRwLv5xCePUZq3gTiHwgDdehsomykwY5ptOgC4AFb5EkzrGq7gmidce9zVJbUFfUAZMWdH5Ts9/QXgD0mOxnsRuwN2F0twSknRTlt+DQ8Dh8R2k8xYdx4vOROzEIUO5WvLe7s44poX/+mS26WmU+D1ZSf8cGvJZelEmxBt1aNMzVRm+Bzzw9SWffYEr1H7ZC6WodO0q7v526hcqMSEHckFcfauG07E0CG5xtBsLclSw/EuKm4DQOFzLijwLZUiWKIWnDmxomQlndjijsFIWiMY22I12TcZwu076FzCCtAcRxZseflOk2QAaFT3klKuuIvAiOQtVCk0YWb8p1I7U8Y6EBmtkDGmDeJkums4ly5Nlo2FqnxZZAOw2r1T9vsSJ292YEEMj4jPl0rmknJFHZqSTaFx0FMHfevBXEzxqQsnC3Qf9bihisULdNF56eCSHfclNml2IwtlS/Ul55dI3xxtw+POUWpNWTd3zSjS2gl5wll+8GHcwNMnleZYqTQbOE2N2coNoSX1fPpylhZAhVMSqrXNl5u46mBPv8LJFTUql1WT3Em+a1x5gmRZR1fv6M1zcX3M2N78yxPl/LGEpbvtzrgGImObXLNBrDuuw0Te1i6jIQEtHUQ3Xl1RaoxWlNpB+5eR099QSPLqGTsOLf+q890PFPEIFCW0E1qOzd2Y/jmRwRfWkHlgefmsuKOwHF8pNeLVLceMyRP43H/VtBYbt6Z/zVMMgtbixcwPS9rtBefBuXbzX1aD0msX9RwUkLmisdmdw1kDTZy7/Uv7/2+4uo7ykx9sPvCQu0dYHgKrkC94mCHNChv5GhddX9JKZKf+GambuFVKGcmKiYP2K+LZNUuPJXfnj9oQ3tm4sIme/2m2OBjMe11CDeEuX63k8S7+/MngX6bhehxE4N3fqR06sdeC7SY0d08KC8apBh4QUQ4vuGxDxpkQSL00ajMoFlHWr4Y0c/bFCXU7fSD9iBoQkeM/iTmoQPtB3BWaNe0qBpGDVYKjsiscmyLlwqX6/t1rW1EEhXn738a4hYj5W9Zs+spWnzEeoqvqvo61CPCxloOEJ2BPC2g4gBDb55U15pijFpo+5dGneVT1uFqwS+/pAQTHZCQBnSInXWEirpvLOcSGV+1TiQ7rYVffjnmtVOCAXWwmFi1RGCmJnwWPk91k7CbbtKamtjDq7FOLnrx+HgOrn4lt2iLdVSYrOh9wIsPtHJmUBZl4837oIPaz5WwqXUqGmZttjBHw3LTwdV3CJIYVNbxAnBUg+UCSZxvkNaTj+sMv6YP0AUwd804IRylHBuhYVtyRh/Uyh4KQ2C9+P2i7F/hS9uNgEngJ94r75vWbPLLRWn/193/VoymMlml9Iuxr/5Dy0IGVzTDr4at8+YKFd/pEafFBqGMiMrs8fv+SOA1GvyLh8ubJZR9WL2JuaZTOSPmcLV/OK1F5yEmQwQm/z0cO7oRghwmMtmyhmWkP6KDLiwaj4R96Xb9jEFpdYA/JBoaqYYuIS4M92i3T7rwlPohJGx5PQNB1ybnG294xqdiwJgzrlKyt1wukq3T7bHshQD1t4KxNZkwu55M8f8PZen8znUq2n2AMarBRwm3xL2cgd4xhkRssH8gBs29wpevG+6Xm38hyLbCj2unkPoP+32d3LPvGvBfWRi3Lwb41yivkqF0P6oV5qLM9VPL07gU8JfLj1LkzzEFPLApxDzeVm9W5QdwB47kvN4eJnFTYSPszxgiw5mmtdI5QZY4TdThi5eZWJ6S1gFQtx6+LcLkphq2wuUsXhS7wmvjxvaeQUkegXzdn6dm6qqHc8Y5vUhs8s7hR50ha//wIOp8bHv6wssEdainmJduKKzCVPTGkOckYxBXQ5e1UREeUB9uOal9YAs3NZeAkfWampxWy3+a+e+pjo6khPjvYwy5D2kGWxzfdV8ot3nkp09jfdiwFJSs5TTeggVtOZUf1fBlLCggBTGzsP0gfieOaRJtQ7mCGu2R+jLcFrOB1aYhIDY2Lh/mGPl6z3yoolCLh9XDdV1LARbLX4u+u64EySqgM2zVpMX+QMbzAjgHLtxlz5SlAkk8RE/XdrDExm/vOew8V/yfBWBHL8uE+mROGqxKBcpah3y7sZnTKmRXXQVuWusDTPwa1zxev1ercTHJ8PHQfsD2Aq1PxglltAnLL/7wFS+9L9Ev52lEnDR2pkpyiiDoQxvtMRBiXragfpG+5kad+PsIIYZgWZ90Tg5iJhkPp7wgegmgUcnui1qZSvIOSGTBodF9/sj8nLB9WkOhTOwuaDW+lIaJqiezhLvYnbpxCRcua1zQ7eQKB3Rw6ov5q58LCJ/WjFCk5r/ncAqDF6UnQq9vVnVCZqzQYBWOXF1at8hi/Bc4iSk2EHyPmaVX6KMEcG9hqjvBf22FcYSETCTUlEcL/2hYdzUyxx5SxTiDzPErczLYBOsLzCZxM39kxTSKgZSxJtp75SIDA8N1O8MUUwuK/S8w+bFSqF/yzIHvgO5ySWYmiz3mU0mQ6t4USpkjJOUqk6uYvySnM7gJ2xFURJI1qsmiccYF1/f3/V7tI7o0M+JEqoMzPkCdwXf5kNvDYUaEVbf3OYM76g9IQTxrJ531bzHZDV6yC6Zn1kE7FLdpCm5LaGif9NKkRTZ9QMqYHYh1w9D597IcdWHhwRPP9dFe46CZxKYfqn1/8sBEhK1H7/PHB1zui1a1vHz4/UaOO5YfJGAmVgWjKO7pAGFlCtRV5OyGdA4hA1P4n+9MZUk84TQqs24ZdeZv37eq1qmAX4CC7jK4qaTXUembDrUbzTnLt49bVd91trZLl9GGjoLWWBE0ovz+cyk2Hb05L3Az0wXlk07f/XgmfVv8HHktAe7C7uXt2T1CMKes6rcEKRe0zGmEf7YKejAoU6qiIIwkAilv1IyCJhanBnRgJPVH+fW8OMNdPn75z6Ye/OiyK+4FaC7UrvCOAuzI5LMCq4MuxwY5J6E1th9L9DsH8pHpN1IRguy3ma+vBc7vQNFYxOwiSg/1Ms2CarM6dZ4RG+23Rq86RxDkK35I1+m60pWHuGK7f2Ui07uM9q4rexjWM2XSFnBDo25oHOQOjzz094MTtiOypkpuxwtj032nbIVaxsMRezy5BAhX0JwaPF/dV9PybwrrEKM4VrYwXflQ/uSZIHRSNSC2pIfoWulZpLfCPVyNTsWnHpNO4h6O5aaLZhgAkhG5pBjaLMo99qiy/ipR5iS9MnweNsvPecMcwAxXsytnRI2xroqDLaQJ9wS6r9sR0tEFcuoCZhOYMA4Gf9j9z62DOwyqjQcoBaPGxOgS+AVUh1vNXCBewDFhUxTZ6ErKRzm0rJ3yncov/gNyeFwxMk8bYVF7ikuvkovxz+Zqd+WoxWBkFK7JsFIYmZ1tg8pEfsHl1LhbEZDLUgfuKNG9QtcNAVofuEleN0PHmjYV8WwFeBru2TYtp4ojR0zizuWvpTSD4qXg+ZQg50ITS/MiB3ZDjn9ARYFQqvOreEeS78HhU2z1iCej6xTTANJInMYiD+OltDlA1WpywFly9px1GzjuwFVz4Cr/Oy4Lxc4+JPY+z/B0/U5gzSYl48bBwbSg2rHy2D5qLN/GTGH0PnlngzDPsC+gLXaCUCtFLt4wKrF86zD8hDFFf7BWsX6pr8BBTOVwNkymaFeG48BYm10vc3AILVwYVt2w+NZ1VfzZW2izYdmVhY2MpUyNEz09MekRshNAqJKEVTd3Stc8FI6FntidtzitM+QMS84ZzZTX3mqj6izSavIvMtXEraIkvmS0lJdvzTNzBxMODLolH01+USVCYt9FnARUsZ3GsHCx1i+EvniCvb0rwdvw316CqoCOQ82yz+84JAIv6mXM/REU0qdxwvDlbH+hzRr6jjWspQDZ8bRpiGOs9/36NbRvnFe5u+naAooLIwsgomhpBxYE7vDhxt/pyDg6nonsuzFgkrYl7rwcDDfCTblGrtPbPqejpIbPCrnXa0LMLBcv+RoARtfWMrSf9TGK92flZFFi7F0owQFjBO7nBaXrtTfzmG97kBzIJffAUf7KyrcphTwQQMVwxFJAZSNybbPBeqG1ilG9hexrgAhTf9zN5foEqV+fyExv7rBaKC+ARNLir8zTiS/0woL0ndxzxa7aODbUOUh4c2jbXnkPojg45EAA1FXN8iLuw/xrZt54Aa4MsbSgH9mm3Hlj0QhQLcHXtkA2/9BGCIce1i9U7j9ikuOAwFnkUKXZzpuKtY3ENXCrAztkOv0yeSmq+XUIt8e/KIQbbVjzKwQoF/k9kzx2mKpvMxFxWGFbn9Uupj4nzleqGsc68qdR3QYB+Hi3tCOIq0kQX/vq9cJ+PTFzY956cdThd0vS1BwYZ8QInzgNHBzgyKMLwYRFe59Ir7qfKjWl4a6OtUzks/71W/FXGyAsxtg2jOIibUz5aLPMdyB5mg0N7q/1fj2UMQLzcdXwSdD7YoDxCgsEAGRlSPLgivmn04sxP/YP8NEuxUPyTgRALH3Ov4QZ6gM3oxJEWkCfWAc6GUdXXCEEseSodmm9I9YnAZZbq2a0LoEMMn5eqZb79MY/esndcFLHStXRz30G7CnYyYfsZ9hIPzjr54QT5BOsBhVZElvwXtuyKZdlrA60W0eIuWvmyJQ9DN7aHNvs6Vy0lwJcunIMPIK631HM+ESJOoMSNhulFNpcahEHT6PFZkSSi+UXIpoDmhMxhkwpFo96S9wchLN2hlP6UY3HvXUfjfnjDMvHZqa0L4gmIgBjuZkhXw9jOD/Mgf3Y1REaT50GhmJPheKiOpmqj1jC88ZUeHlPrCWs7Vgco9XzmvVFpQud+dXSdC+MwhPdR/VphQFXVWLhqRS73vCXQ1e8VYzgzbV6qLKU/oZWbjfbc5/GEq2mDr6yw93tfAD+NA2N7Md3GrFhlt/IEQGP4ITM6Vi+pEZRt5Ztr5RGzx4rxhN4vYpmgiESxVlZXin3La5dBcpT+IbyQGPN5fd6kGS+s/u2v6iiZERDu5Ui47NeyC98CvVLdn/yBzQY5gSHJp5dZ0ech38yCBwxUXKS8Rjdidwc9ur1Ybuvqy1i4NAFM1/mQMzqbVbkFsvqCKSGo+DMzU+PHvrMUuh527Mps5STqasA7HyRriW3IXjEG/NCmLQ6bd9a9TW6O5jrYZqpzsPNKSf8NChVurUMb8Vc4TnpeOPluqewA24hDsgCVAcULY3ZR+0ZEyefHLqzRIBH2EvbyoAs/JVlCd8T1kIgv+gA44T6vXYqi+Xn9m2tZ+kuzYA7v2MbaksdmfTy3owELuZl6KH3yAsRuQVdU4mH+F8tnczNNv4PxPI6sr4wzhIgO6s+Qcw/erGFlJhxvWI5lHNFMxtqm/TVgf/15Z6ygTgPC/VGH/TcmDdyQ8J3y7vdZH262AXpw0U57rhyvKuTIGT5diu4OXSTbfOwv1sYhyVGci8Ceaq6EVZ6yq0OyZaaO906NRttX9WSqstdHyywHgRvg0oiKBHaBmu6LJSq/KH+ehpKkRx2cvUBXAtf40f/stCS3MBI06bRc42J68REeloXqO1nKesocZm/KvWs6ICG4lGwVXWxDLG4jwMaZWTwAskI8qzIfkOLK2wumR3Fb7oK79pcerZ8WPZVDRnm63+9koe5bwA2md+v/vy2Q9r29zVeinzKnIblxQB8s6wSA/Xt9gdS+TItmRjxl0LLXH2URI7p12mmj+ORjewOI+prDpF8K7Kcjezq/zvjKTZA14g8Z1gkVzMC7Rjm7gUGYefFYR4gzlU7pGOrNZT0MdC3Da/vLgQMD2uHdvFWec+2m8S7i3Waqt2muPv14zDz4l9cT5X6XsPTm/uYtCojxbREizsqxPwKyg2c6CZevrtYg1eCryi8xk8Gu1U5eSW8jYKcTtgcI0/5xQKLH0v3r/EYy7z3u+9Bw1KGI8GJI8USE7W4tiC53BDJRJSA2VX0NgoO5JrBcL+Hl93pPfGO2y5REuH70xfjnsI/SwPSntcIoNWhNBLgSN+xXpMwQdx32dwitxEXf1gBaFK2MqhpH5H4EPS6Tk7n+Gpk6RxLjc0/eyGIEuAfgR1GLV2lMtIcpO0gYRKklIYE0OMMofjIuaJqNJC78AANK9AWp7rkxJpp0EQsS2nVTOhnXkf9Ckv0BTkoGDrwx4cQ5jyBz48ivPdzSsRBLCmHlDNYVtVnPJcZvJt06zee9S2sApeDpmyJogaC2KsM1BHAeyriqfp948a8Pw0o5R12Bwpz1PSVLYL54oT7nA7LM0O0sAK4TQ10p0GqfRV32XdjAFs0Be2R3Rb/caUECFb+2pbWEXRxv7ND3uB436mI+7WG5Ogb9ETRaEP0b7Uc9SFEInRRljt1380IZ9bBbnsV80ykD8F+KYHCgQNIOu43cMF0ZRgRfGS+PE0ISrmNKBsk/3E3tGs4yTEKNpAvzNPuL/Vva64idENZjnJcAh1eP5oDPNJf7b5K9nd+BDaEny5IQvOE4O29MEKq3Bi+02zrkGiN1pFcO0MXS6GOn/w2MKeZOkqpNs0a5rYl/puUgkcMG/3aYvRvEa3lOHWVbd8sPh1q87bge8Ua61s0yWy9V0YsyeuWU9JM65knJi2hj4FojbCOJfFWEserGCjfR5YjqN3kAgnQ8z99gCFsQo6jCx1bp3WTEfkXivcF6pco/Pe5gK39wsmgHmXMvkYzgHfUBZNY7FKD9QvmoBCVZ6Oo/Dz44GYiYPBqe+KShcNqmte0S53blzQqRjcHlthqgk+HpzqJAGLnGvBJIhe2h86s9EhVVkH+OaOGDx6athj2d7D0PpldaeRkRkTquyCax8uxIscGCeAElr0CJkN5JBL0gO4oU7I4Syy7AChkZ+5HBHlZom9hCtM/9cA0XRcGhWvF3HwDmi9bWi+EwDvc27ARvBUgK6gLQkol02gPmcyDymbm1EyXJilDvKobWs6Xgl0V3ejWZAhNQR8wYZpOu8yKThyirbFTucNRbdPI0DAEgK35Xxq83GfiB2NER0DnZZO/Y8wKl8wtvow8JhxfVZWd/ydCrKwQbKeywLda/Dmcno3j79vquYrU2ZBQWIawqKGeVEEJUZKR0eQOTknMb2CI6oFmlv4tMvHl6OH/AhqbeKsGUKOqxGuyhvTSXBGXqO8TdGa2NwhTBYjiCPp5cwcW+UbZB43S20VLKHDrJOSWLcv3X/AN+MVyCazTphPeAjvz31RwH2IYNtKeIdkPnjfG6lI2+noTNStPAVdDU0H+bJuGtHE5XS7AV281XsJdeN/qk5qU1bek/tkg64laktIOqzAYRQepkJaXPwWY/S9YckJlC73Ic8L06PQpRGrVdzSrlSj7njk6vmLtAvLIMaNnBkAUGN8H1OT6N92XOUtQUKR9k6zuPKJyVvIadkuak5dGTKIQZ2SRRrZnJJvCmd/4IoyV4O2CXg8Hkfl52Q3NKGYHFI/q0wkEKyZD24rHR1WjpnpW2+gV4zDXvpS2gIPuPEVo0uqp7gDJowsaSgxyxUI0TwHGEc+zM14oo0LkNdKVMAK65WgVBxlv51DLnDBN+QZCnYQnByBXBQ2iyiObe1gO4GQqRQuK4iYyfCUFtY51NIhgsO+6mMd+dDcuFwp2sfLAtVV9F9R2hTm1zoHB7/4uMKP0NTb82SMbBX8A7fviquoK/Mk6/9vOenRwaQ4Go9adPwuddwATumNzdRnxqjau9nfWU/XXW5FojYt8vvlQNiD+Co9cU+0/uc92KhKxYfma7JAEBHqYtwxfvYzNCV3S6rGoA5vStblmzGsQZrYZuoKCJDdVZzyZ3DkEfxhwbHNpm+jbGf0G9hqg7SbWq7C394ZdWOwXdQiWpjYapwAbjKMvNdY/dkD/PIT85/5Lx7Z++GgDxRZnaETm+VqKbDSZvBJPr3HZHwJVAKIjb9R84QkAGYu+ykoozIPbrHvNxo72FjT3kbsB9apiOg75DqoHaCoYcIcrzhsGIe95gF7Sq2ASdYSoRH1/ahqylJzUdw5e1U93UA6It8W5R1dfdZWbpyboYDfI4LWb2cScg1KYLughj1iznByTuqQ7MxFfyHs1fsioCOgm0HmnAV9wFc3xR+toz5S6vW/yp9RFAN/wjbuY2YMyRP2Mti0UyHAcv/ZrXWjSJSHkrCfZWke2dkFA1xTymm/XH6kbEPl+51+uLBN/tDGGJ9SxTqBOS75+VSh0okPo3zJAIWbNwFTjZR4XVNvKv8zT/McJclYdAYYva3yivBfnmTOJfHjtuwFPo7UWIjBQlEiBsfFRamUZZ1tvrEuYwZLwcoTDRlIJE50NADhMHN62mtFMrYq9Z4wsdlGd8DnAjKbD3AY5IkRhU1NJbazzSGpsWca06896O38pbQH/DjxhtIB3g1/WTC4mqvRk7GzuS1UVnKrIQQLTZ/cI4QNAT/cC6ln+gblk/89JduqyHW6TCDpbKnJKFO9czKkac6XAdVATZGWs+ExA1YvCTfi8MqPDOlqcYZHif/gORokQxHGEJONtpqI88BOFxa3ffPU0bv/s7n1woOL8aoXLNcR4r1jO5TvEjyyGWTfAoOX4ebqodt+szBzDlzy7VJ0pc1VYusuX1HQdSf1lFPhrbuQV8YNNujqqXYM+akp8nIdFzpFIDM4cem+vreg09sNh1igFYU21l67pT+tFBqt+UI0uTmw+BHPNDnHTN4VPwXUsLauapwn2B0R9xXgXlGxnbKQFerbRm9CYDHf3DBl+1QkvKjdA4VCjKS+78fNag6GLyp25aS8bJGpdp65nR9J6RkKR5k5BfcrjjS8zDCRL1jpfyvwKnTlwlPtuCJNv/QSc2nVA3JAiQLZrhNWiy31l3K98nvXDIqNDDZZFd1BB2PTiQGB3WdlRx2QSCgeK4CrWKNetNHo4JQiKbmwatsJnmrFNj5p5cwyP8SSa6Mo9eM58dJTy6O+K0HBYBZ5t+LPof54LarTZhNY3RAmgyR6pGQkWqtsNJ11GcgxjOE68Nby3yLSgM0u7v/n0NVBVkfpPVHc6XDqhGjDLId5O7gq5uewtZl5Cv74e+2vVKQ1lme7ZjnVp+6tshD0CetUSQpvF7qG6RZnjZM860Z+uH0yRFOLMX4T0PVYPWpiIAzAgugQT5We7hB8diKGM1YlZX77MsdTfsA2XMrbpDWTbq9MGsv45/JCYp74kfaEwTA9l6S0wETNHMQvnp2kF2fkoilGrvL2mqhKBYDFJRewl4DQfb+vqttA8Q5DBGIWENmfSLkUMc+Szp2QnSdoRhqHWUyPZ8tJycN1zwhmpDWyRmEIAXx/MQr+nXZqUgKOJIbK9m9CqwEysg5NSHvBU6AcLa7FySuLdaQomLCJXOSqfPs31msN856oD4scyMD5oSDOZIKrWjN2MXZualzLtobZFkMF5jzRpPSGk+eXLJNTMdvtj55uEkQDTf6zxnd3HhPSkoZQZBNyJQKOEIfoq+2GIEPSUiotJScVqsdwFlln8wGf1zUnUchKYSSS5yJLizZb+WE4qo3TF4Xan/8tIUeN9hvNH31cuIUk5gZ3Gw9VBvIR8DUbgcLtGnbSwRvli57Nii3buup8yo6EP20IrumyaLd2r18ak+reqXzPjmxGMZrBQZILfNzwFeburM8zEbdwpKhN1CvzYu55/Ela55ZKIvxiHlY9eZ6cdzUXurkH7uEeVkTF00iujvKR4q5eu0e5giLaBbSpMSsoeirD2PykT2G/6lbJeJk9ZP4UMfRF6zLfOZAtEeaEpsp1XigGP49M+uqNHsQ05wSbhHCTJv1ZwwD5bIx2kCrr+LRWj6a2TYDDBTPBBkFggiirfh8DDIdKPlMtqioht53ta4+fju5rNnyxGt58x28XtSaMvEoMU3/N929KNfPV7scNplG6WfqovSEE735AsXbTgjafDNBJx1OkLGvmPxopCLXP4VXE8pz+9MDqEELMcs5S9lZMpXCWHJx51U/fcZkpgDNCOLX/6TEWE712JcjFaOPI7enK5pFb4ti/r0LuvUszfHIbEVOhrTwQNSI3CF6KChnxxuC/AgS7WKpwJaXb4mtwO6ytvzgiOsv+xR5f6p+1kIhX4Hz/lIUXfulMCW1fke/eHNlYo07zhTW5PDQyWeabhAxjC2uF/bRpGFqz7lYa6UyLrfyVmv+PAuK1kDHU9S9hkklXIdrmnNDrfxQrpIyYMZ+4t6X6LY5rTYlM216Q8HeXsEl5saZbM7k6clpVpZUy5Tumea33EKjmCrx1DPO6xWin6zI3LHVx7oQNoMtLVd1zE72w9wBLDRo7et/8UhtkKpuDYClGBscV0WXZxvrCeH//LG73FkXJrJ8MKtMOv9It/mtAIsXxJ3pl9/qX1QUe5jnqcfJF02D3TK3KxG9A6UHzsHz6isFKWT1s+dIbUnpbKNGTcsoSfMRAMu61o79042JIccwAkeu1CFeY4B5gVaFgpJRdsw77BY4+7C1gQu7x35oORYSf8eee28Qw1jsG2czg66I7j/zT32RZFj8R6W4guyNNM/7Ihiow3SRAGJMt3JqGsSdf3YRSfNPP4/L1zo1hJC6+PsTtj5FBeKH16OTftSG6iqv7I4w9tXU/JIo/KJsZSXMR4tUFkIZbFYvXvayWSzcq0HiPazrZSe0faK6nJgujvxHyNF1Ew5DDjQNoHwu3Cq9N0Uv43wXfjkmVmMDkuFT9INQYbGyK62sXiE/xX2ZTrd69kUDoePiCjteXX9deI+a/FU+eiAow1YpzFR3jod69MoQu1l+SycfXoOsArWxMkBQXc977nWE4IlYFA+HukTgCRZ7hPih30FfRBD7htZ2qfj4mypB0GBclKfFR9KIZ4UtfSiD04olsLBU6OuNtWYRvxasmcMs2SqPTH2NcN8uMK1tOageaKkGX9RMKCEh+QwkvcwA3o/U7Z4ABMibGSzitRb3szKVwIngYa/MMJTg55DSLEGLPfPtGO9Wpk7DsssigWB66S9uICqx8LUr7Dc3Sg3LY+dWMj6RY3xDCtDzjf+JHaRt7gqp+pCZFRZAiIw5HMCjdh3w90wtPvvBQJBo6frBn4tXslV4DP7G5pXPxo+uDT1JHfRXBcrZbM8rTvyf0WpADtqhKDLj5lNAxO9JWwjN4g7O89JPb+CDQ8X1QuS9p80U9UWbLFr1NeKO9uUmvVTcPwNxV3VokPHX1CVhpUWwUXBGhspCq1mNzVwSj86zqo5U3YWFrLGZRZkhn+w65/Qcd2HaP+ugrCuaYRMNb8ZlCDj+2pQCtp782qfpBfnPLhxZkx4FpjFL90VxutY+466pmT0oQESqxNn4+0hP6N4TRtdsakDjPspqhkU30SfczUQTUkzj+Qy5TdEuCdHaSk3aEsJi9XUHV6FnFtxSQzlI0zVhfnrXXeMor9r7WVV8Zrzm+tEvt3FrSKgQifYgxH6vmMxXdayMDNiXJK7mC46YLEr4J6OFAQLqX9FsNcPX37Rk+0YvLhLyf+f69u1WVwpVLrh3R4Td9aWq9IDqDGvp5FrkLC+7oLC0lCwUjXU0Xv5uEo4lgU+F9AkfKbNOYm9jGcSmKpm5bDthmoDuzxlvIMpTsKrMV7lYnp7cfKoLYdvrwg+xDd3Yyk9uvvly0MuM/NiVuBlt6G6NlnSHL82iQg84VpW5IuVZCKFiqLjlHKG2zj7eNRRUzhCQTRU+0r1X54GaZi/8Xpk1BwMjDmzneXhxMdEuEc6+eZDrIA29dulc7+x6Q6Txlrq+7Cgep7PWGHugGxF+LmoY3Efx6EfeCl112BZRSwrjhQ8mqR+riXIrNWwOof3Z8TfOP9Ax3ZOVmnIbVQ7K+QjUHThzpqjXcaOyjChogjbj4NPWz3YIwc0aSH5cTptXEvUhb1ngjjDPjCIeu15vfd1fy+thnpzbICVDKhgBvnL2vYhZQILDgLLeJzxtI8aT45TbHCYmahS7Hp+msNTfIXnobeqbbp3RxtJ8i+tAY7SkUXyargqGpYKg+4rCcNClBEWvyq8KhiyqBUnCXjYlank9YcnibdWBLV5hIyTJSr1SKOKaZtKAVFGBlaWXZIW28DKKyiq3Dp2XQbs3lZ5HNlPSQ4ePTNF8Sp5IVFGNCmJXcNQulL3OFWeY6dOrdNIvqDt1LT3OiSTTTSw1JhgPJq6SIFOaOUfJs8msgYllO8nAFW+SacwFHL8p3s14ISjQvR/zgwrkVvrs9m2nXzke0SW1Gi08ZuZN51jt8HmaI5mys8x/p1O1mPcRyS39PPzFjYq0bTUNEu+IRE3KN9oBPRBCeLkSaFVq/J920KTVtkOC5CukX14W6AunQ4BdonyQLz+lAufVRxKnVGQS1bhlB6JO/Gpw2+Zkqpx2sTg/RE65FegJ3mUTEA2u+khaDCBYvhb2iTGPmDuOFbASjZmJKj3gNuimRnYJTH0NoLkT2U7WzzFR4PkcNBm4IgjIJjPOCEH1569OoE/KJYbOBKMFYKg22ovTWYowfIWsJhbR+yPS5Nle12NNYBfA+UJKoZtAVScIzkUq+ZumOujv5k0UbPk4KI8dIytDZYjlf7SJUH+9a3c+uRCDwgZ+lKy446P+QhVpmVR2wKH1ONXW6OmIuOQ9LBFw7BQvmJQrx9V+XzomD/ixKhNLG82+L9Fg4rbFMwFwkA3SH7dtB6AHecldBGZaYC5KaPBaizCFQYaeoeYMe8PU+coYMBAuwtsJvdq8UtoSivocfCxSd+x8pcPfilmEbQ25mQ7e3zME5159eBNLH/7QG8XIie/fcN1re4wfq3OVB9w7mjWEe2a6pb/jVxBuoHw1X//vjx4mBDUvtK1RVvns/ggc4aSOIiznwigNlGAmmBs7A6YJxPbP2Gf8hrU4fPPG3mVosLOkxtWqtoy1u+fL4YCxyP4Aqkju/UOAVwxUwdApCyOFWZf6IzG3l4Go2Mk+ultDGyMp/mOHnpJ4uz20QJLau3ZePAsnpwNl9tZyjb4cx8nSdmiAfkAcUiL5udaZu0QsFeTwA+6owIA0O1Ruibn+tQIjdQSw98dauWxSCoS2j4sUeUi3sDhohBxiJtZywujgAWYIISC01jXX52iQwnI+AlpcIXxImGEwlBZaFH/AbULJU10M1Gi2vxtGdgDBxpox20/AkvsMHG4+OPJyTEQWaoEum+KvaLOR/67ibhIuOC8ug5n4TcmJE11ggpemhQFDa/3v5L+/IP+Hsgh8JK1f+ZaIGuKinSvgjuF3RDN72xaxqmeo99rvKjmvG82f+9JlhAf4mMth0AFvgiGslftOfewBIQ7oySbPU+PTID2qo2g+O6UFKa9CAV9a9esjl1UD2ooRuPaKBazwErotIDQmSYJDV4WkgabNwOlR+TeoWktwVKv5yhqqNERvujMUDsd8miaxILBZ4pdYXhhKBdHfRBiZJK4/u/mnG9B9oZrVjlvU63rEZup3wl0L9XLbifqZzAFL26LUIIQg11eTcx+/I06kXjTAzmeQSy2LgG9OEBlVRONRdMQS6AEg70je0W9Dh87SD60KhMEEkR4dALwlOG/BjOFwoX/4pqFLkuOrL8RcUZWHSGyE5+8tNuDXZL97DK1/IYqj6sGB4Qo4WkTxIyOPdaxYfauG4m8WDw9aKiVJuudkHqyPoVfCLdqj6k8AChIK8jcwnzaKTPM69gmDKOoJtrXejnCgS/pZd+EC8dzRoODy7vsE3Wh97iY2AKpyKA+hLvSJINVR4ky1uJcME8iNsNctbzNrSESRkEdUqACM6HniuXnP7u1Zv86g5qdItv0105M2hNASHqAQKfDXY8D86c4EXN0RUot+EzW/RfvOWEhx09CeykjpJBTyOd7OkIsIyggle11r+WVO2SsIuxzWYUrw23+Pfj6t4yYUEy6W+igHvRtm/lGWVeQGwihNqL0H3tUboFC7CzEClT0BLHKaBBXqdWiRFaZNNqdgZ+0abfPNnjd7zHO45e5smyQd6Jux4EJ8EkzW0lbliO3t0yQavp5+AeV/8/xZLnsjhYfJLXhoZqXYw4gO8sweXuVei17PEgcG1eat/ypo1QX97z6+kc64pJFjczSadidMB7nUOnxq/jQ1Yd9NlIxa8pP53cuvYJtOZrn/NA1GrRB7z0xKCjPV+jMXjdLsJKzlA/6sreNzbB7/wuSqpj2LRspogn7RLuZeeXSL1vwu2dhMLftiUB3u3DLQh66wUPiBjHSqm29OjpRn3A6nNbfG65HoKLvNgwoKz6uG2r1CI+Z+rJ5jvJiJnDXThW/8HIpPXJOVotuMgMiMYynU1yF/9G7vyJS9V2eHEaH1HMZn8ADdDAJng9QIHUCKgvKeKkBKN8cBenu7z9nIC8LXkcb+IxO1X3ofuDcO219cf8LabWvmUmDn0Jg0hrpD7FuUd6/BgFqwlIKNgK0jJalzDT7xgEDzSw6bThDsIjA6VNAC9jdRJt5snW45lH9jY2r7H2TWTIYv4DRG8IG1HO2SsxYLW7kxRQKMEZT2X/0juYe9ckNbaq6Sww+dUIO8uPlUPVmNnSIp0dUiGeRiyFYv2FTgcB+4nGdw/UuSWUjvUpWCQ8r3SvdBTbGBxL2VCHX2hXFr4PRSbIiqMEa9f2sPZw0obNL7njm6t1OVDRWh0hI2gZV9ylmTcvZH0wAzYArk1JN4sg0s4Rb3hFByo6lSZtK6dXujbFbErcRERwMDemgmT33lr3v8PkgRduIzfWoOznCLg2uuEMd/b/HONEOydMp4i00Tlr9WpVYK89jReEKvMydGzGZNH/nPJxRn+gSvca/xXz9eCekbGwxJKwHoQogcgZxyMkTI0ZI2c7A+Fq+QvIxlyJXIlvWIRQf4srLlCZWVB5jg8C5JXGC+m0YRDHn7mkmNX7tBoububUXQ8VdmlhjmLuQlll3rfm9zkK7lu8gIzaqsGTFVJ2VtSmGo2AU3LbsvKl58MXOGa7O6xc5T5XF8Rgv5VhgHcovL+P63G8sbMih6C42zEg/967ylsWVmI6oq9BUsi71Q418TJSkNirKUqRffpkG9/rIarMLMGQBLF3R38dq5hbXfmhOXXR6paLMxIHlDLRcOeMroTlu27rN++sXv71evB3qSqRw7R967Lo5FMWB7leoZhqQjkZ6Ow740/DcpRzVhK21Yjc+FdbDPau7qj+Ut/OuWy7FbSpytenZ8EnTSxZfllIkIrehu6zfau3DOW4UgnFzBwI3pqIDNXOBtrwKjUEwwAJdRS+OtfF/KK15+PRFzC2RIKmo7/HtWsLoA7PaIJ0JCnOgWuAGHOg7ATmC2agdKqOqKdR875uNEI8VT0UN4vMvju1ROXkJhse7+wt5Pfr0XrlEqVd/ziVFFUa0RD1nmQCYmLDXDYBxUUGiZ+UCh/7ddPnIV7DGYo/sxWJmYYnnQ+mRYjl+0LJ9hkpaUA0qkUVAu3Sq5GkM9MxkuVGt2wVgPmS2Zu91QIoFBuD3DC6sVrUdFjybEVr7RzjGZNBDZxXW/PguO6NxiiEzeUDNzvtR1TEmaNeQS05akongiWaLwU9tftXo1JP1BhJvgyS9GvX95WfJqqya+1JG9pnGKshfOoTqYNXj9+2f0ucd0rr9w/frjRbk3F1OY6B93Ee/v2GrSCPc/Pe5P8qp0SbMAe9Pq2GT5gyjqIbnPeaMvq3xRtxJsE4CG/H1n8jFf/RDvKxRIqu2ulxNzEsxHffTgiWlSB9DI4LC4GhXNWdZtQHjSxwC5J4anNv2iIGyP7O36lv04+D0m9CLQ1EaneDMUkg2cLAUVAb56olHEkoRklzRL9XBNaTSPd98ayxT5PPd7WBYt8tqhrPWoBR55++wUdBwpXfMpzYX2ZHHCR8TH+SgVHk9hdkTsLSQINvoFmIYkaI1lXAcrXgp9l6P3qnaJoCamgbbrD5sNyf1CpBEYIed60AYpr+6WPpr1aDdQb5Cf+SlOT70aK9btAUq7jtyk4fmdFZ1pd0IlxtYJ7BteSY6vNGq8OcTzwJBy3cQvmfXvpcTsnBF5l3Z7nzymkSvrNN2ZTAftYV+Ww0mbXgDGhKFM1aXUjEwrecT5ir9LiCowiAdxhPnqwUjHe5qb+y5XSiVxpUZ0PuyuRmaPKiecM/RMwzAI1rzRcgzYFsOxiiVtzO1OFvuPrNynEo2Wanau0Z62vwSdAJgH/E6pLCwaMFwkm1JqfYgEaBgMxZJtDzfIYWdg1UKJxGYxyriaD7vNnfFM+nhFZM5YQO+SG/tjKlccypDisdl9EwdSCmAgxVmHPeBPVLGEhYGf1JjlAsGn5tIxXORnqpkv6R8TuV8q9Egzc5ycAlDURjmAV8CIsdZJE6v+/4KbaxjPr0HxMNDt9lf+KDPfpKb9LVrS/KDSTYW8FK6eE/V3dp/UC7UakNPhW3XclWsUbvOJe9k1haSnvOChFZby8EFdklS2rT7wbwi+w2RusnT2BFO67Ou/YNdR69smHunFJy/hJnu2abwFjilgVzERXNPfjKXypQYKP8QmEFxXosHuNZak1fzr4QkIg0JFz4/NaObT7w0lTstkG6psFfMgegh6XdnZOH5gtPp9cUk9nIOWWU6a7nhAqcg0RU6mAbrqGLYZFgzYVNGPK/4kJQyMdWWmtlFQ4b/rIo8/MRAfZ35hAzzlgHhqQOL8ngg+XkEbcdpMNOAaF2kTCHMb9eUEjTdYMVlsc58xqvlolzdhVu2KSIeCr6wmFZCTAB99ZPLtaVy9VtR3/uH9MP2X6wCtZjSa3CzXJ7xj4hzppYPTWlQlCVvmaqcDm/1bnJ3d/gKGJeA7V/MNbTkQnUAnYeZ5dRNajELB1LtUkxprYl+e+H3C8PNFocIo6h6JqJE0BtMwff1XigK9j4yAQ4Kz/wQqkmA2pvYYfNuTGFA8p6p0oPoZVHkyT1TXyTvLXAgmfUzC7eRK4PHiDeN0IUQeo5jFgEOqsGqNLQhT3lKuaHuhKs47AXKtLAhXZV5EiOzDSoX37rX6/mU2oPVHpWaIBA1NxRhbsTf6KnqADKPLz1SsEPLJX/0m8e7hHiDxGvShMR1jBUuMzER1T0puLa0I/S2ZjvoeWhrzvyONi5xVbYcp/WYuGG+b6UahUN0743NYubdLOuTZ4+0H6HKV1yJly0U5gtTUasAa5SET03TwCo6JbpYRkhVoF3UFf/VMnV7R/oSmRhH/7K15wB+xnbpI0mvAgNVOS/OGyEJHKAp6YrN79HPhZnRINM6OjNtS/P5cRuStrzmwXzgqD18RZb7ExtW2HuK7iAamiIKY0prv4BDUtSrDYy5W28WcN6evYvpkubmZOZhVnBZFMZptkKOsCH1hb4rLLn7L3dgyyhHmTpjFSXyvlBWTCjuJT1Oif9AubbGPqRQ8ibA9zBHyQodjHZUfiysmtU0DtEUzs0zWY9jVpK9o8bwH4/u/4yNGygJDI1t1CzEH/0UBDyzJVJJCjK/P6ZBysZSVX0xktTSqKPZyKEgYc7qkZoIFJbHxyc9Jg6DwQzQYW3znliGEaGY5sWwusYfsS1izetBsbyB6acu1vP8utRDv07AE6A50GStmOtGtnsngoTwwVc4Gmz+cJupksT0v0tbHCPaUc+yRfjBCXcz2f0amwuGwCaYB1XaeqzE1yDvcG8tABW0PX17i/VtMw7gpVw8mBETRs4kxSxlMDknHUnM2Kg577dLcQH9+Yfm3liwL1VuI5nSKjn6k7s/M1/VLmTWiqmzJd/JGtohrWdAhTvdBfH5dFfWQxVNtixscqJJnv6kBjfwer4I6jwFV5cyXcXDCtdypsftOEBwKbB5N4YsKuBUzk9y0hoWYPasz/NsprGfCRVUF6J7zEi1TputgjdHLMjnzy4FN0eFR5dMTjonSNrgUqge/lelDDg/w5ysdzYFrkUCGr4i0/vUD4RWGzk21MMsI+/ZRC1Nlh987rnQlcN29KcRr6cWOOM60qLQzGvc8tsO82pAIHctcQDQUXR3Eiy24LBZ1fSAniyr7IteI7jT1CO8Y9PvMnrV219gMyFWTRCIxPYQiFvlguvQYXk9KSx/ehIP8dy9ABokUzz3ZNMV1FXo5p51qI8yDv2I9RAx3TGxFJixgq1EJgE6NBd2sJJ3Lyys0K12PwzYeXR+sb2Bg2nZIje3i+obmiA2Ozhx1tH9unwJD14oJi1Seu5VKtQRqRp+InKbAGwfbq4wO2lsn+c3v3SOjfqlkUUlKty75hnReVZrnw4TSmqXbkxO0V4ONu9hX243nqViEklzZUAxEydB6k7oW2V2vM4Jugtaq04m50/Jxb8YdaYNCgwVBnFSdvwRaL4y6RPvLR8wp0bEoS5iImKV1hU8xFP+LaUm+OJh7VOmX8GIlVYfJQQ+ffYvqHqw8/1iUKWnY3Bdp8uTISEm5RGaM04vcYwTExKAyrEQrm/Utx6fGT+RJFWulY1TBVr9+COjqtGaxV6bXAL4hTBd0Fx1MTzhhLNH6sweC6FB43unxb9EvUkVN7anrVoBSvUtva9FknLyr3qGw/bnrxk6Gf0DmwLr2m0d32BXFMHeo2kvBbEowhDuPrlBsGgWTy5Vw04OVAjZdV5WP5TleTzQVmKM6yspWRnstXU3OkUAu9jiHKOQTnVFL3sMtB5uTC2VeY1m+C5Sb0/yhzs9+LqX/tixvDlQBtnb1G4wPpEZP0gsyy8T396Rm+VtvdlNqrVH//RoKuXQOhk4NRhzVfL3pd/bmjlKpexsKsIiI2t1DiM2GpDGba1YJ5845TwQETucoriorg9q2huK+Pmh1Jv/cOAaDUEil+8OG3zbP1d795693PUtFpl37gJFR4oOFQboaeiY80bUPNHqsv4Z807SoVddBF7SFJiMxCfajAlIxkp3DiP2oJB3EM9/GWcMFm733aYieaft3JygQmbeAKCC/Nxi5mTPU9+e5XayCu57gNPJcwzKF62Z+YdA/PXvvbdJP2yl2JbQjUBfUmawvkgSgrVlLuIGZGcvWfxmrudgrWm7kEUJMrUyDpwRgOH6Cks4dr3V09WU5Cj0mCt31Qol7r5mnHPdOAuBz8I2ykodtkWuTEvN5G5C8OixvZYnkM20EwkN34aIoahJ7fAhdEPMXwGC2eBFHqPuaO3GNQJsYS8xZppBnxSJWVQl45IYGCbj8vKBEIszL5wvg8tLbYBIsOWL9GACxhHyBgUUGcas5+SnzX7iOO/lm8Zqex2X8NKqp4cksOhyvZVMlI/gkWexjozRmewhgdCQ2YqhVTtAljtNLgk1HPTftyATZ+Mgj5g67wlBMxOK1gXiz174JY6BSA05oB5bTIBRF46k+NomSgMRCdUAVKJWxI4KXVsvlT32NZsJbjirCVamyNKscO2DagG2ScPCVYiWS40Fk2ogdXhBa8sVpmwwMPA5+rtMRjqQx/WuNPMK8NQs+RM2Cz7Osth8mk9aDXJRAUoVJZRY8NRzwNpjfZt6sYHO3XWsfkevt6lRtHpzywtCNg1K8Cpdur5YYQaPOXJHUzWjmD+LM59aDaW5lJ6NztgACmzH49SoFpwRInqmH57b4TcovMzgDdJ2iYLTcOB1rII2JTxOcWhJ1km2pI9JZHVZH4FDI2K/sgmxTG1mMuPkPhRtSxOqscb5Lgse5aHnGZEdyf/H82x0t4oW9iLvtY6E374gV+KzI2dEXA/3QIRkzOIjWa1dZL0xHi1yh4P2fH4cJnoS3MxSW5WMpLsmfnXajSBzIXMFGAxC9dzoVoazflCXnBUdLWsKIWbnTYh04XMZv+bIZtU4dX8DJE6dB5ANjQ8euDvEPA0sStFmM9OqPGQxCc0zfaDdxb2KAI5JJhxlw+rtINpQS/QXFdhZtPBqvwV0YcvnX30pUEp7/0bgBMaLGK1emIP/RWGIGZxpZMhYHq/1IL2C0hywBVfJ428UkzIIrUxXDoh9OQVUsAbavv02FtSy+oqkKu3WbolGw3h74rLydUin7MvsYmnWwXcJBB24+ZjmHf9jR9KNlrWJmKAaF6q4DCpVKak0YeCiN8oatUMbGPuMMQ95p3S9jA0hWbmzc6ACADQD6YxpwVfRL39RBl4RoN2vV+jbXVSOwsafWLCaIieUKGVNzapD0oA4+zrPgAibvwxuavshr7/rYYu3hQafOXl7nRx9vlesGrSJu7EdnmvUzDNAODONSJ/T4muEmAyygzxrAqxTOsoWGcuRedbktpKNSOU/oISTHkm9dQgPcw7cLZzOZMDoaYIWjyazYbUFYPQhm1F0M/ppMJ8Iz7gSqw/OYamLrx6/ERIWGlVIGcIe/B39lRg9ulT3IbBfTWi2b01XOW3aM7QjruvotRvLYLIJ0TxSYz88wdNpv40yZwO474ABEBTni7nLL3kAwKzlQPI1GJzg2N62zTZfIeaKfiqBRrYvSXI6zcq6RjLNmZcYGojK/qG5q5v5yrysRjVaOLSROXu2oecUrAA4JuQHsF/R/TyqD7P+8gN6KtzLckTvBL2cuANyXhpuMhTwA5TK3G0qIHTLuTHQHQKoSOmSkCXeI78AMm/5ph/mh7WN3Th0A687IMomrjWL1O1d6MRftKcgv02iBPHTn9IutO/oQ8lvfnJ4Hg1ZdwSdXb0IQsHnrsGfSo5XIhkY7Y6u8omn1WsDX0nYIptyA7NXtuxV0bIfc3TAsaEyYi9IQuz0mtAlss8S6A/9jfSUtuGPYhL4PgIqZK92tJwkAWouc1uOvXaafbTv02N4bWnTs3yqRjqK7+jsnbOUoCFLhVpMK7jJ13FJ8UZEkM9nFreKC9Qm1WkY5daKCjHIpxvP2nsmF6+omWMV5GopXlze15dv4M7Ewr3rb+2TsY4Otd7S27iZuBnwtGlgy2Zmt0umHT+ihUVsqRaZWlEPfeAlg5Gkj3SGEwfZHMEkI1O1fb782Ul1atnxN1nhDI1qqwCMdZpBNBHS5ATWmozD1thKn0cBLZasJK4n1+PwB3+QPjHHU6B0PLOcJSAoASyWRHW+odccHhrS8ln1vOHK702rbIgA2ZPfNrU8BErfhGcropdHgURsnYb4+Yqngv9BM3L69l8j26RkcNOqGVeWwiZfyzXVI1wJcZcDXCxVFc5EGx/3pKwgTJJ9QsIIudeK4XmLb0wxmEpKoEYmtACBQLrRrAnhBOcGSK+4gsjGrG5B1Y2ycguC0vaXDEVRka8tciQDqKv8hebZ/+m+ElnHLQXyOJTpqWjYwgn4DuRoWc5SABJOkfudRZKUpQ0FeJj6yu7fAaPWVP9OVR6Tx/vDfNx+6DI889e4h8QcsAjdJWKsHJ7bFgIDKX2IP81M+zSTFTBML6UNOxwhDOlvG0ir3YNEUl3AhoxwRWbrCXbxazYNFI1tiv73uTWV1ks8FDuk58iD56G+4N58mgOLsWOS9eork5IIb3Et54s3feV8ib2Gc03eXdqW8LBWAGh3tjMXXdAsnOCVsSmQOYxyijSqHZMimYAuQ5FV+g58lG31C9J9pMxvLnlB0x6VSYjrR6Uib2hAyFLnmbLJ5w/uW2z92XdABpOYWz77oZU0vkFyc6B5yuQmPrwu2Tcsr7uCC4jPX2tyH25t3oiTZT7Sjtp5Orlu7a6X9ESglo6j6x7X/dvnzKM54JErVe04T476rjsxD3DdpJ64bA7RvytTuySpP77u/C0m8v1EYwviPTIUPhTsGU18fZ+cWRsJ5wLXM2WvXgR++2dTlA0SiLgDlmRfKlRLIlZoN224BFjWaEwFfMgyVS7xVzh8jEgdwwZ6GfnpunIxSG/QXg2IjAwdZ2HP0dBaw+t9HaTewjKd3WEebUJpPTn3xxo0eZYB7DHgX4iKEpjVDmDvtJliN1hlBINeT2NiF7gzov2DUNPE0MRZI+HCRjphiWDyVPP0nZ500fqFcqBRMH3YxGV37S5LaX1A8k5PDGFfnyQ3NVs3tKWGComRE7+C6+DlYX1ePkrwwNV70N/tlx6l/x4qFI51qv52e/kA1D1lGNpXEByFIv99WBCQpM3B2JyoNmhUE9BKhkrlqGarYAYYSvAdY8y4oQvOpgz4FfL/WAXSrVNPZEB5PIABCAqWl9q/OnryOstVmq1Ha5Ibwuo388c6NWikX/eckY5/rkKy2zOteSs5jazK+Yl4fyV0wsZKaTecFEPSpae37wgwj4lEEetd4leYKK8o0wO9rEVALBulCGEEnZw44GjqD00wDxfGTmjS8sLaNoiYyz/jjptktHbEYvSZE5a1SfhYQxeQakOfgBGVI1R0bbAFqlfzY8JqmKrHlUJQNZ3ykfmtwtJV7lY4kTt6S8rHF0haiC2NsTkhnkhmcogwd8VlaaGqACXibDPAp2qrfYE2hCeoBl3G4l/+ZiUPiVuqp0FEap9zH68Wi5bBP2m6FLxNYKJYBiq/8vOPyOYzXzRAeeeKCmhTXpZFtgfbg5nTHl8bLrGH5im2w3dBJxBoXuqraeQd7LpMzsXFMA95VXGGdX162eqkNl4PUd4Xzs7+E/0AB+nSOUog2/0iZRh2t3ADHQ3G158+qLEGzlGuRsmj5z4+N8Hh/WrgpYByOyBqS4FddO1oJ6O7sJx49azBSflEhiDuiMj9EQhMgMlGIcSiFPV3GETYH1N7NFR6pT2NiH4ux7h8B5mrSJbrJyREXf04uQrvFTDLeozPxQm1fRaBKkVtJ3m/QOdFIdPcp7XJqw9lEP4uqYGwvaWD/W+LuaTm4DI/aGOO5PBnhU7N4pZ3FpjpQ1dH8gdEVMPZi57P2UZJ9DN5q6qhdPBlNCz0TBrrUPM8zs7pRQWy0T30Q2C2vSBQSmb07DRBCLnXyDmiKQAkWcMjGzq6lY7PnuYjNI+bBp6HhOEqsxwHQc8TakMvQ0oO/r7vRzEI5wpdbG+qt8Myu2bB0hCVgul5OSuGdo/GN4J4lyFHLUgOBg4C8eXghG9kQCLnvx4yBr2MjpGwqlASfRM0Mv8ZxX704EdFd75we7XLrAQorBAdcZXopnO/I6G1lEtElsN7UkdEtqisUIA84nyT2Ow+HzurDrCfg8VqRIJ7eg4DSLSTNMTQoCID6UR6YEWz9DW8RfY1+ub4qf4tD5ntHUJhC3Epbyl3nTe0W7rd7NboplpJ1Ra4kWlqS1kEM1XkXVHX785G8KicpfE8Yqm4ckPCSwKm2Sz1X9uVhSzCMvpJxUKnx+dCbH+Ymk7KugJf/CsjcIUooLKT7zIKo5UNF/YtJRfgMJAIAVicFXLYvxXbnpbEcVRQPWRdjfG2KmW7+A7youI3veHVzw48ZNqWhC+EwcZYB4NPVAXBD4QxoY7MmGAbOpf6TqOKCPPwK/X/4auiIOqZHuLS5j9iOzNVz+3HPHvkrKcvj6KHMM7aDok5+pCJOJYA7lt7GrcsGQbMudOY82OJdYKDXu1hWolk2kkxcl7xW24Bx3O780stMjvMVVdrj3Bq0UMkiEFUZM9wOXRXaMgaSCc0W5RMKAOzIu5IZo5qU8wpJef8uPnyu0AAWCPrz7wI6uEa03O4ly5LqeqniyfpAePqeLhB90cj3R9gL2YLiW/Sk3xkQWaqmmRElC/CUVT96r5M5Sh1RXCtFGZ3lDMDovjb1bhETZYs4tAxrRaYzCqXSuQkoaiJiNIsCL5STqDEBNEVQkrStksVQNCK4fMV+SPkpa/PaScTSn2j7H0HwEprEBa8N4w02hP/j4pQv5B92Rr3HOB9nTRJtvjucahGoBQSQpwycQgc6glz66QRvJpRjgTQx47h04O+GxTEbxVoVT1v5MyKMCDydtwoaiAq7SlFbwkVffLMo6nGmnA+GW0KGtSpNj65REE2/eUiKpaRUyy28fmDIo2TfU6/BmZbmdgyeJ+lrb9SpWgnmMJ8kZMkNkH4NcOJ9Fitugkl84glxoDVc+Ai+ZpC+KezNT4f4yEQxqi0t/adw/EHdeWhJKEwMCeguJ6soepNlr4rzjr6k0VJPofw6JcIm6l4za8dTQUDsDoGdIl+9OwYTUjcLSqwv6G2WIx4wHvJYDQ35T2ayrNukgxRExg/9soTiRaO/WI1UPYLeqtdarvMl1uj+bwpmPl2GMcZcBT7hAppYcH/A53g6ZHBp/k0JiJWaVlmqoZLcv/3tcLvbioeYFchnzB8yFEd3viNWK9Iwm5JafTuSRw/KQxRbe4af7Svsmzrmw/oe99PgeYlSLPR4rhGjsLi6JIbR2MpAK0x2l3oXxRNO5+MAUOYaJiM7m9u6A56QkqyUgZ4AOpAZb0TFfJ6HCX1tC4X8IQ5Luqp3BSsYYKjjyKh6nfvQgt1tACV0dAmByZG3rheTN0vd6BFNQj9W0hjUgGbEaZ0avwLTwN+EtQtjGZobzyTrAfbq/bOZ54msj61HAauU2lDH5vmnJLXMLeyyauz64OITA7x6ddgcxbTR6ExQ64YJfqoyGWZNmo5Dx38CSq3IlVnyT6d9nsT8NdkwXk4pOmjWbyN2tq9ShAwzQwIOO7Xw5Yt8kiV0IcnvIKApJB72lyD9d9wcWvEAKA26SEnQZShvP+X6V+gC2DY921PScenp1+K6XB84QRgB/KWGhaZbGimUHh55PqA9Xt0yrnYeBf1iODlGgGj+cvw3bE7UsVzhHJFqs7Q/HlsJb8uvPVq1+TH0YIX3c0zA43dDBpkW87HEKLQMsvYNPv5/NaK2C7Xbv5SjYY1KNEdsMQDwilzSOMawCLY+Q/AsG7PQHuz9giKUghwyNUSs04IY1ROZxZwciFUjznuy9mHBfgWXyemCo2fGE7uxumHUO1VIcx5XDCqqLEr8GBS0BTKA831LwxdK6d9+HH/SDSgZUVn7SVd7zr8UNRWuN9OcAJglUBFuLVIyz5CtYiVwooDqqSsTwFcEya30oWXvg55JV0bMJJtTErst+NUpgS5TO2lYszAuZfDfWOcG9zdng+tNJ9TlkvdViKCKTQIulRlLJbIg7ClOGSN75AlOqNRA4BtjIBWOiRPLAKL9G8Dh5SL9wTx7tewGvHbE8Ze1dH4UBOXOBcYfImbuWZ5VBXkrqDozguvm9i9oJ87YyvkdnQekFhjaBLpWY8SDSnrQL/wAVEuEfN/+BHzT6mqEH88f9AFrs0ai8HgGpsy7w/IgS8Sz95AyfX3vuFQK9sLyYBQR0r4W5CQFIVwGEYQfWSsZrbaZ/EdVL5XlBMqRlJysVVk3eNNepNWVLQ8kdmNXXxu8PW2lZhsAq6tMIZ9NCaPEX4evZlwFuCtZXsFgkhN/Bo5WrGmE5HE03/NJxITEUYy/4AWSgCrejGH95iDa3Dj9RTBrjdN6It49byVRVkYIuDfbjBG+fr0NXjlFq9BYJt3mcI9oaffYnuP8ss6eZjKo82fG350txDnwHff9A399cH8vjtLZbNx3v+sX3EOZS/XbNtAjmFt3/d+ZhWK/9eERAPiBvSOU9O72ZsygKhtX544EME6ASVIcWpBg0uQKq7XdVLuFxxLWjAVm5JUnn1vWLwlg7G7q+NJp9bqsMNyDMFl3ObswUA7wBEAmBFF87oMPCnW3YfnytWhwZW4whAexh5+hR3KJxHtpfYmVSAiwVVXnTHsOebQ269dWbhkRvFGDgC4yFQUOI6YC9+Pxw2OZ4MkocwChK7LYeW3++rKcCvahHNm90M3OiwpC5hUZlTQh0iVe+v/lNcF0Z0ovMBXsO5vEBjdqORd5hkxPa29VUk5QcxTROWz4cn5Mc6JYMuQXS9eIZ/QNPlmR2YlMz1TT5lu1p/erWu9szUEXil61XhMxLtK6Cxs7CemBPl5DP0SLxvKCzJbp/KGfnBgLaxZoC3aK6DtdzSaPmpS9+sJbjaw31k26U3VP8fpa/h+i47UWopH/wqqypywvY2pQXGIwsWoCb6D46X/4W598BauG7huDgDbs0enRyChMoEQMWO+MZT9jXh8mXYkVscFyoUSYxw5npyXuYUzjePoXcpPcvqmZ6E3tbfjJgTCcAMwNBnmDoOC7F8UdrUNp4NxRrW6RXPhnH/9muOruio/QsYA0hSJBoWdbb2+mtDTWnHVYWe8rKouEh6a73PouYPLuu7XNakr9b8U3/+G60/RUDZ3j52Fj5UQgtzmgT/7R421nRRvAkWquCB28U1MIf+4Ga5iUv5GupJPZw23IACXfM93zfuWN18XVKVLGghfdMQIdt3oHrL5oLCzRZZAzsXHtjoWc7C+/5v2eWVtSmPfCNTWPggeUUE3XCN1srCc+vfzmg6gIIbDjg6R/eHzfJ3OzEJfHtxm/3okDkm/tfsCsGS57dqNAwPFPJYy8TmrPhNf3LflaS59t5SP59+IrDmd/GYW8kN2LUfkH9zEt8tw/lMfQbk9K3gRUMdwS+PXxhz+2F60u8MYJLISTqlQ2TlBqpwZ8YMSeCXAPVwJ5jsf53y5M0Ye0L/UrV0fbvK2+UTB2xREmn7RyZeYvNO0rM4SYu2ucj04JqafMzvU2W4e7ZNYHoZhjmJpahw7Jy4iRYmgpxKNPD+mLWl1I4Oh4FHYiiQiOx1WYmzFfSNA+YNtObrmDbviooR56+HbEcd8xa11p+GWeQAlPB5AQVqpLZ4aCdUDgQ9zbcQi6pZUYwiFuotOIqGdxFnZcPGbJPAA18deHFZjyYUbJ2WGqqLsLvp7oaov0xfM0WfnBdGiswZ6ckIjCZVkwvbXstpf8gwoF2SZNLDNlcDARAscZWyFTwsD+Ue0cusDqDuzHEB+Rlvh25DkCitGSFmt+rxcRbVRexPg6BrRNde8dscTs4ucMZRM6hXfDE2+095bcoecltEqeb6m7oxksjVwijwlUHtpze2vV6KfnefInXpp5bCh33lJKBw3++DQUDU4JOaJS38HcUNpqsRxEK90EqY8F9/ZuIrGe3soDfVsstIq9O6DASS5lfhNBTcOWxwe2wUX84npJ0VCWQhmvXefmCTFkE8LC0x4y984msu0OdW4tRdsYYBl5Vhuq2m136x8/g1OV8n9wrB/t2GUyCghjNvxIJlJzLlZeX60y+zrrhMuh54cc1h9ZOAMihIp0SrdqdvhhBXkjuwQYT2AtyvnIYY6Wm/opKJ4PFetmgn607eD3jKCRs/2HnZP4OgIJZBBDQ1n54Nmrg9MgMkxyG6f0EE/ayM1zzDdIESDOiahj8O+x+oXTsiKUZIcUr0Yvyt/VsVufPAA0aEx0xRS100YQvpe5MtU2Qsf1zYjKR9Ukc5tcvw0uENQHXEIvRX36IdoJgY5zdUIcBqh+Eq2/Dv5fuptjNFUEK1VZBTKCBsjv9B0PHDjHfc1Pec1xKtaEmvfpqJAEvppvL2PUZM55fWBweJcdGXZrjETDDjtyKzyQ34lhfm/1EG6zq7VfRpslY5hoccCUeUT5K3oTZeZGDGP4jJTrc5IRvA19MwxOg/GROBFZJanNMiK3YQfCcyvcbizNm6Op3CegCcl5Q7f/7+ZaSD17HP4j6MCw57wMp4nX5x8qEVxYCJ3FIvdhsGKi2XigXJjLtHGpeNgLLCuK6dyiRVUEoerwcBvGv0Omv4IhRctOb+cIJz6m6z4LVFv1tjxQZsYAt6LPpphXPtV6MbT7yuJZq9uk0YfcxJyFVBhF2Du8MmvKTsjaDfpba2815qwaPJR7byDnSyfqPjJ7PgrBH5VtRgoKB05kQvT5+X/ALACPVI81h9SRiQDjC0U47VhdkXvY40WtOjP8sR3/q1Zy4hMW885yFENOwszXS4ZPpn427xOYxp7nAuTbNKljs0Kdjmvd+K/Fo53Sjw8ARzARjRMj2wL0JM3oVrk57iSXx+76XERLKSdJzqLr02VzDC2FVI7mgX2pbZqmObrkfJGm+l08hbbCEdGQH6Cz9uoTVQ8xDmcrdYqtX+IaMdus59rMEcJfliBsRyjfmmgq62jx/GMfav+Jce2iFdWczo5mU+IK9/+Dr1EUiZclviI93mh1PdkLbS2Ftt6IbmpyMdbn1DXrNvp1rmn0e1/vVQLMGEi2kuzVwo5D+oSljrjFKrn5PT+RIlRIBHV9iiDJa8R/LoL3qNRtucNe8l7Ka5NqD/L/epH64IYVkA1xn2m0BoabAhbzUQEHrN1btMxsStlMsFChjdxo+F6yReRDCgY5gGxX1XALNmEtl0Jq9JtoXLzzEAPZM2TFGVwcv41P++z0j/VtAnG/3sYc0cgGXyYWQDwhokRQVD8uf68ReTBMoIg68wP/xG+/gNfQLf2pe5wT+yEBHXpNwoU5TPl0iLB09SOIIQLHDrjR3WMcjulfvQP5+H/H/ESMooQtFpMJZIiQR5s7U2wVrcGhYKKQ+F3uHz6BlMlflp0Q6sK0pdi2JX3hV1NkJdo043voQrWAKsdexrnwEDGvOwu/6FUpys8ZNiw4uC0dPbGL8Obm7P1T0dU/Aw+zuCBm+ZxjZ7drF9fdTbXITSfT1/zIs3utyPtr5ZitpZhs3iZqPASl7orUHVmZyadyhbKaRrZB9ylZLLdZeSUVkSBQ6WAqO1bxBCiFe/4v8xdRWghpFGKqLabIpGz69bAGiHVjNjsarB1NDq9XmSriqmIxV1qUR8fWN7rgVWNYXi30ULBhOwKv0UbATUocmGMvlK1SuPjs9m3DAD0gSzRE+7OW7tRcqkxlWUzjIVBiVpCXA3kodVumB1auNvgt5qw5rm9mufHfQrnfH/ChdDBpXtrQmuNy+KhRZ3o5Lgl+tAeRRvTfTEBubVxcRqPF5e+5MOvO9D1Pjw6/5/OHU+RcBAldqKpZYiqDYycL/0T5Jnw2wXUXjGAVsK9GTDQtb5sYVTsqOv0TiZ+qPF+weVtpKv6pXKiLti0ZO+Bu1dMqyBumQk7n+xRvSuRn0VkPiM1JZp3NUvRA2QS3AJ6qV1a06vHUynZ9fqhB0MddzjFc+zNwFhJ+bM0gYWoCnX/1lxc1BD+6eOAuV14yF/t9C6EnMauqCpU0Vv/xxKTsLI2iDNezskAB/Zmg6AOlTOZ1ayJ3D5+mhSdB4pyyZ1TbEnLZwzIHM7ILv3ko593tM2Srfvg29i5ch/i+bKlsUFDB2B3d56e6NvUu967TDUOlZeUgFBra81N7x695Pz2Te7kSp+VFmvFrm7kzpYftNGDKCCsrLiCV08J2qPVaTbhmfbwojosqVkW2bDbzUJugsFQzoLHzavSWfgz4hPvHkcxUsnftYYEwBfaeFblSHEIZF1HiyiLXwvZQUbiGzTvIONvIjNPl3lfGrwPVft+3ejWXwLlAQPsL5LsIh011NQ1GeAsZo00vUPzG0UfytEBQ0P0+A1uTWmUZqHVducSTE1aWhMN5gu+iRzWsyLYjnEzWvnNDBU9LysoqYjqGihRTje3NzXA8xV2NPHRE/CU+bkfzuWobZukrLo1mBFaj/2twLF4quJANsBks7k/XWeOAhLrA3nQox08tkPyjp/O7508tKPUqh12arIvP+9iHoGmONHUNrhKyvqznwGc3klLyrZFM/c6ieVLq1D3Rje+1bw8tEPC4xpCdNsWFfx4JrR4NevT+M2aB26dK2utx9MOQj0rLXpZepxu24HnJQVjU/pdX18gFzEQRDuvVCuPF5Kiafj4pCr7VeE7p57z93eGfo2dnX2Kb3Oy/snyzkSBRuzgxtyeDUAUleYT5XzH7qlSS2fjRVrrDrGNHHgskeWLAcbDkabYsLoSC+7dODjKBsyKNIDuH0yRWhu4e3aHbgyKPbViFC+Km4J76HpvNtHKrlDB7BNLksU9f/Fg7cml3BHoR3rvKaMpviHi7WwAJCyhTVcj3gVvY4IGXbgmCmP9qq0lUdQ4z13uWqLDU5UmaM8j2HGd1sGUi1EYUEILsSes7k/Gpmm3esupaRl08V2xUqMi6LuHQZPkhnjHbfwK8uY8P61+5/fggXETmXitG1FEVhU6HE4AenLgD9VbmlwWnWCY99NmoXCZsHfpPTcsMAo/tj+iDHU3GjNgMu8Pm6mbQ2YaTQMARau436s0l9e2GMCAZwspboY4QAF9BZ0/IEIWtEm3Dt6mUSzU6tV7J4IX8csM9LYSuJsnuR80GcWigsRt+8rkwDFv0TkdGczhjGC+06XX17jmhLMNb/by0buBtstGWcGINgv2PYwwxM/A4Mj4f10roB+FSd5F1xXi+2fqP4yDX/TUAcULf+jtJxCFsrykVar+5uLk4OdRdknjIwOL2LLcqc9JqdE156mQ3Z+3MABBT7mLvon49HqpLRkHpKOln8lTCcRePJuHvWZyNWWVIpHS8hdiJrsspPp4egp61ZHzzHl6irkmUzl9hUtwbjuUU1u9aVx6Vgv4d0DgrQyAOp8/yWXk+DTtPZwKkNYJ+SkEhIHYr52fLbtMHR5BzhMmSK7FWKRvuQyOIR40kIIOp2PJbNruee7E2vDm9JBSPI92w91BuOTxuuoEd3DZOcxgB1h3wkMD3QE9SQ/r0VbkVja8/FQC4R6rRckLcYEoXIDiwHuel0klhO8vo5D30E3NJ/7neQHrOjnhNwUZb3nEty+rpLqDi+AxdX97PwV2UBIlaiJDTuS2f0ZevR6rYjkV3RerokGgWu7i7Kg2fIGuY2OqXWt7hRdwkC0WHWOS6mmo4qoKxXAfNkV9ky9qA6NiDwoTaadysHWx3W9TDt2hJq1cZagE+Sr4wkxHy4ELM0mZiRhZFu11qfLUkM4auCsbBJSCu7yei/KhRGsseASkLbfJI09ngzUjg+/JEa2rPNJrux7exZ5mdzLE1jyFpXcEBo7gyENh2VVd+6ez9OvBHo3tT/Xv2XLPs8idk0WJaR/KxBu5N6NLIV4/a5QAToow7ImTdFMiFM7g5pO3JwalPUfZqGIrcApX++T1Q/2md/XRuQ/dL/T58DTPZfTBBPpXQZUWIYKIpyTNDmRZ2xt81GEhiROCqgHKkZGDppfq0XkrRffc4fhsyrC9AKBGp+ZsB+TBcC67e65F9lcFhD5x9FpNvqwsbGPWvxi7u1RG0R2wq/qTC/hn2XQyyAbF3JmtBLbSO+JFhNZpmxLi+tNr/QffVEDrXM0NZmSLPy4RS4m9xanB3rpHpMRc83pAa+2wC7dkUBqddF6VUjfOrmQaB0kGGk6gYmiLeoDwfNPB/0hGaPD7bsRLfzdqI4oun/uFy92AAzs0tPJJX9Z7SV712UwDGEFruterkm2NMjSBlmpnQmEzz+O6k8F/DzQyR3jbRn73ux/rGfa7lZ0RnkwqK5xYjWc18sJ5rR26JsD63xCYb2up7ewXFP5W2N50TnIAWe7E48sTngaERwsXztoUFcOF3PF6hxA26RyFCRV5q1JmdRTW0JyTGPxq10KAizxxW7Ose7QtpMzOzHhBSNi1Uy+MVY5IsTlLdAsbaBeN7ouK5UYyDgOqNiX0OPvJLG6HB/IYLp6BANPLLhZpDCKNzh/iq7p10G6peDFGL2k+KWQvPJ1BhR625p3eH1B4VD+v5RRN8e7/woXxP9d4xif0rjtnvXOmqwWdBOA80EfpsHedfYrkXEgQnbOczkywNcuv7t68FX4nqz9EeaYwDOWUU862k81WWwMfV2yqlBRXGPeWUw5eL4KHcHGFBcmxDGoRgA95KGnLIc2y6HfrwlbKKID8/beOTZ3n35pOnmpwNYVgxGsZIlOSfZXUlFMTdjNtNNLJV9BfS5ZNJ188PBmtpEJXaGPuaTKTTsTLrUtrCu5QZNQ1oVlKHYB1d9J3xE+yFxKyeEaUuJftBoMSoaMMKuhno9Z8dn8yR0FVe4Mw1k/zLEFmmjLtCpKGxv40/CbU9QliH1Kp8Xt4fmxELd29oBn/Y7HznDbIHDtXIR3QExgGA0ChohiIBRiDUWzaOkOvmvlEq/GqVyzP/jX4kjynOpJmf1BoIksTX8lMfHP8Nzt914JeYlhK3NMdNYN6aw0e0pPx5iPWB1eo0zfvxM9APzm0W6n0ZID0HalcxeOU/5Y7uMcvxrDeavIybLRWROkgLQW4fGmvbV6k4mci7qDy+B/ECR9RV9/3Rg8O2zHGMgJvwduQqfdASV5ZcedoaXhQ2uZ2n/gPpZ4B2fl/KCSVm1SCTPKOuhkbMhhOSYiC8kfkOh/w1AnY7yQchpUUaELkhGrodRdgB/+POHNHTyfjt9SR3Hc+qbM1D2xY+N3RUvm7Z4VF5bF574YbwFSgRz3B8L723Gnr0V4zPwERcQnfs02W2YOpmABryPXhPAy1J5z7E3sauQndM1t+WCCwg18XvEed3QK1opn1lIdQgjRoEf2K0dDCpQJs4UAI+BGAJRzzIpqdMXAakxPC7Gr8wJmnsnLsIdjZX9uFh4FDysOazMn00zyHiq4Xby4Yk+p5/oWb1vakP3XhPxWYhE1RdclNo207SlPAXhfTwtLnG1zugyRZtNTJ25dABXwI8lDeHIyvpnPl7r2gCaw2/GMoQNoDbfEf6Wqe4t6P0levnfiHx53am7IgMvqvBIPPpuQ/kRg0CygAqF5M1Stbdf+NpF6uS6n+It1a2RjPkKbNusTVTM8TKEfgSKok7sOb11n9O9wm3JKNoPnD8/tabOgGsuSvTlK8NLzCSeQAajbFWQMWodBMjcb+eZ84TqSXWozXSD1aLbV1tdpr7S2m81GhQPtdLQzNQc7iqKTbvS0zFlWfzeOXKYzZxZEm1TToqbEqr+zaNrVyD077udj0BHHvz/lmQuph7ikkQUyclxygFlN8WCpjIIWEC6YLWuFGtW4dUYbeUDOynTYQynoqz+qUE8PDqynfsekyIuD83gFaUmt4zf/BDAaNvQQdZNW10ZMS8I95gKpqRNsciEkTXv2eliiex5r3gJhzf/lmwXwayb4hcS4x+70rEsjhhOg4t4n/nB5yQ0YqJbaDgIHHUlk5cAIPsoD071yr3jsI51Q6PNpDGnL6Zg+FODghWNg7xznwpNOQxDZA++T+fkNauLFO8fTkO0IJ2/ag5piZapUh5V/Uf+7TKIZqxS7S+015+PrCzx5EdqV/hM4VoPFChSM4MfDtpdgN+RyXKKdHHHrPmrxSfK1QhdcsFNvWGRueBwBzaU64tkBHWfAvCrlmNj1ciicm5FOPlD9j3fdGoZBL8QVUu3+4FqvuEpqKB0qw5w4CfbgIDfMqOagx8JAREV4cdKHO0tzZOcRYSo27sj1S3g6XQEmBVE7VZ/nU67m1FHWYjqwtPXVU540FjpTkGAp35WaSIzIHx/8Dcjwbcd9HZbFaAHgTuHaFh0qO7qOMrN1eSJy2dtrEjkAh2YBtX8HHyFjfW5Myfq+GUzs2aK1F9hkmdhg4YjGdW5mQDD3MUSs4f0uDJqHJvzdX6R0jU7U+GHRFD73QMIp4qhaORxuXmhVPW+WimixAEJ255BtY5vS9RV8iVeXUvSZlvKaiL7y+lnSRV2wnRa/gtJzeQvL6t8Q0pA+xXF0ipoTNepDBHSJoV4l74GNyykxx1lt6N0Hl2dkVXjIIxCfm2IIfeHe0kU7wDuGL5SWmX2kSG9GFug/lQx2+FEhFIpw5KZ4Rk+BFx0Q2wcYy7j7iYWHjivNL4bq8FIkgPbw/uC1d9jTjDFUAxi5NR8HVMwpF/YKIk/08cKgGsPoq1GfiK2gPGjUrbeRIklrc9DwfkAzOYcyzxhN8wcK4lxHEzJkQ7ueNDPBtsKyCgblnrgOvrA3b8JylPXW4ZxFA47ss8B2Zo1GQhEghMclGSnSb5r0kw9z7qi0kXzQ/KEmwrox3DIzWtJhuD6LRoBlmIB3y1JXWrhcCY24b2BSeqV9EhpjDfLwVTTQTvvEvhP7yz0aTAayY30/c4Tmj4pHFfXIWTwGUV2m4BQA47jzPDGGtbwFZcWP6q+uG3dAPBrXZGYUdyMYstn4To+B+7NqlOBj37YcDR6V1EPyVLGwYBUknDawzuF/qkJJkNBAV7z80fezW6EXo6Pzd+X3GVCaAcpLJPghDKK2JbUS6HGhvmKdnmxDfBt4n1ei8CkprXyN+v9Vc0pFvhzP+A0/UQozleUpRre3RTgHuIUEvhjAnG2dYfkxSokq7L25ijf8xfib7j/UUDxqA4rdFo7NUmZldfnsCc2p/ACxL05tJt0s0f6YUanGLa9U3tz1dLp1ox65x4Akim1PsVlvwUjBvrm4/RY9E0yQAz82y3gEirYzkEEMAa0EaVSwgbOqeAxVRVmjM+idkSus+Rm5Kr9FaTQgQBvskUjLAiCHzxAEYm5kQ4SFlxGqET2PXN+gaGOeZYvFomlxrpK2/0PoehF9qCgFOU5F51ZnZ/KcYahrVshiKrejweuurpcfO+3lt/QN52Sd6e94bidV+pC6ndZvK7zVBOJEwBBn/ZXXM/K7jwkMPLjZYqJvjIj283Z8jOrEANqABUXI1r+OMign1bbfHRLhQech7ZCxNlCdMcQxuZzVu9sog/z56UFqmVpL0uDgISgB3ZI2wtqHyz1PbZyAg3ARNPSwoY6LHSgGSuo/a8kxBKQ5NkDxqt82ctRCCufCUEHiOlMIRbOnLR60gZ0p4hSMmeEmktL1MPO4Cuyl+X7zJ6DcaM9/FtaPhF97ehIGFc9lS17o0wuTlMQnGHwL+7OkbWv1zr8M8N/zWHNNfLRDaACiFBz89OVHMChOu9VjntwXnDzcGifZ7JukCYOpbjFaUiWuxKk59+dtItEKNjg05eT3pqNdLNBeU5llz7fPK8Bvhvn/d5J3g3JfBl1+GRjfJY1hLL9JQamg0+BA534V4I50WpFD4qGyKD+cW+/9N6i0nygUxs8S8YQOEcQXs7PkxYEC+KVi2lLVe3x/SCYH9TPjSSd/bkiv17sQz7bmgnof2vgItUzLEBM0hUmVbzF6U0wUyIrSsyV3ExAQ/mnUVnFG0j2aeUY26fr34iYczKT7/95yMvekGixkBliBACJRYdv9rwisLhnkeseZSGUniZ6vltm0KxbV3NqgNGVANchUwu1Ode1aqZR1jecME+VTqTFEjaYPFgNbl7gEm6NiskRHYA6hPT/1Ss78kvytdhA1UKfA2F/+AZLZk0KTRY9vASaxtNOvNU3MXkSoI5o/FfMysUnI8uHfjniMXYW83PhdRq6hupy75FJeSx3wZCCvZAySNrwMemJE0qOoi8GJiOKn/zDw0ex7hdtZlYu2gyCJpCs21fzDDDXj7TWds6QYzQuWfNj4KseNQ7rTqeq7jPdhQlu2Ptf4G0aweC4n7exT4/2uCwaZPT5hf9XVB4Gf5CJzRV9Q+6YjS/I7pH3KIKFm2hYVFTMNmcZN2JTScJvD6mK75wFqBtIvZmruZ+SECe7z0PncYuF3YN1O68c7cj+KB0tqA3k+GINrgIz3Qc3sRf8tUM2WCtzbKho1PBoaZYrJwt+cQSiUQnhR4jl3t0DSVDNeewbxoktanzK08FM4Y5WCKaM3xdMf2iIOVMSdhAViDb3NChJUhrGW7v8M37x22/312pCB4iUxxlq431mEWIWlbm00HbUwc9fi8W+YUd0aBMIVkwa60iKEF/xPU4UKUge+85N6fhOHheMrwnOxAVqTnbTYUm3yI5Q/WRYc29WV0FCzzEbiRlapmVkBiriO0KdkTo+ip6LiBkMq6iGfEmkZfP2qiX6rIa+UXFmSkkAtQy/YmAB9g9DZje++KU3MtbWiaZlRHETJXF2iNMWBr6SBqsTwdfsk1JzuCjS4Ssa2EhGkOjq+X8kAvu06fdu/lYHrcvbPdciDrFGWw+wNImBf1xccALjrLxtaOAE/zrKdhuukfnTWrurykT1SNOns86c99f0cmQxjZco1dYI6phaSdRwB7CMA6bJggQrQAWXdtSz4BP+wu0h8X0SSJelabt7iE3Gu+5xxzOmYlg7IMrIaIAklGHz6iKiG8kBU41glIacymG/jzJFMDGcr4MgkS8nlF9z2pugMc1qdC6hBQ2L4aIhIGPKnMWTOxMAcXYTeoYMV55uSyRJZ837J4lJq1r3ECbEF+9jn/dNWVamk/5GUJf7ekIByKSscxah1qMOepHtB17XdhIYqsZax97ErvgBac8z81sFEjbhKA2A+fO8ftGRjDdf6QKAcgqwu9jDCS+9iwNzTPcqEkOOKpyVFLRnJeH+i8m228s8JsAKmIh26X8nU4fE5AKyGQnWNvf84LZMQlGC/SywgxRwcQVQOn2wLnLQrtvRq883VV+CYnxomj9ZuimVScmpInVATyjsgIGxDdW4eE2mAdNNwToI6xcJ+9kj5uKUEFxP5/j+782zKH5goJXedMtNfq1o+yG3vD30+6wUQhyKowE6XPG0YhviuTdOU9/HZ3ABkMLsas9mHtJflUGc8e50coRDFFqaLV1uS7uj8/nEQdYrp6erIilcKLl0XYJObiB6s9Zayfa288LWno2E1TbYk+ObAxju/+z+tU7SIGq5OdhGxH/pJlFShPnTxp68KGY2f4MsN5ffqIkPrN0nG7JbKpLVQOyTQ+OFrXBYLkkVc+BSgC4EQoaWhQ20qojVMsYkgkPu9C+xUJ5XKPoErmjkR2Ad8y+s4PKR4ClxmLo2KbIMm0p8iByeH+u+5UCcOgnIQ93QgVB1eVUSj+cTEp/dgOgDI4+drX62ECnAa7ppovu6yv9qw8cbCLR9jBVFqXjxjjs0Q9ETQTOncu4J38fcXke+qvhCMUD5gd4RkYD3+NGknXkrB3irUdgQxOS9JOsSzZxBLmsRYZy/NZnt8G/Uu3aZhZizRTQgw9drTnlD0J7+7+rFGSxdx6XV9w43ax+Ob0A51SCwZdHXngmSJ9HxsCee7wkkLYXianNJkfORlNdeO21q6rbuiHgXW3kUL0lEpu8lqrAxe3L0gpHRm73RzS3BdeR2NOH3cuxOtQyBD7RPJcoRKlToTUE/xvvwhMDSqZ/+iKeD9e1yBd5R5TD78Of8bher6rWPPZjs/ovqBhrp4ThynPg3ddGN8dZv6pbpU6m5KFma61XYTivuc+fwnL2//Ov6SRN1r33RdG5zNUucNa0jC6ylqUCPuXAKx9cS+Gmy1QfN6mnw6pqadXP6vvfqrVYaeEB0O30jGJNwD/bPVS3OdWnfFMqHk9ul0iKTcZ3eMTtaN16N52y4gP5JX3W8X7AFUo0AkhBj3oO+Ar4bVEev69N7ixI8VI4IR9+yi/o11Qf7616c3VxJJHr7bNvegGceL1mYX33S8Hn2q2cDX+EYrIEJX6/Pa2VlMldFX4W1fwhcyhFxvBV/TuSWHYhOLb65CK1OZroqm1Cx3fiFZOGg7NrE3FwMGKP4md2jeWVGAy5wITGpmsiW1VFUVfnFqNyfA6+S8ntSil8SkBA6pHz+DuQZTFc0tXgSmdC2NVbtft1PPJ1IBmOGq+AsghPrVMj8JcmFzgHqg1nGLhx3F3EJXzbpULYTzJ4QQRryU3Gz+LdMEvz06blcvEtT5uISUyBn3CUTGY7PzzRF6N7ZaQGQJ1Iu3WmQumUShvctNEXviIdLIYXH2Z2zzWmetoDSOfFZSrzbZUBfmZfPlg3U77Ia+DyFrN5w+mloP3K3kx1Sg3bagZV/ZqRyOXhAxqSowFBo5LVn0sdnezNoCZT24y+5OVDrXgI8vDKLafAlcjdr0zo7ZD/8EFGTu4F6FUlcqqDyw+n+dUQCETljCHZRtwbkt9j2PoCTogCgm8jlrVEnoSqJtCChJnSPRFbAvmTILwhs5cqvjcZGy98A7ohiEAEGxgWOMk4VoXwlw0fUj9aOV8snlVIngkSVF2dhycp0q6N2kp/CF3m1LShfpWwyqszrp9ALLvHFo1NLcSY+cv9kQugv+tqhNxHNlZzYhwZhO/VQJvhVGmpABW+11Eg7APXDNKfNBIWjZrnfd5sAnPhavqs6pFAuMYes3aEsQglIRnjAqOtvqxw0q1I268K6KIUh0D+kb78KCzNV42FeZXpfmDRoGxFc1wI/i+aYFx8KdXQlo24yP35DnjdQthzDOTXe7YKh7LEdxSQU0SUp1HM+ooFGh3L9pmHB6DhzA6L21DSRoy7OdUxi8kqqZJ7QlG1A7mSt+/6Sn+HIsGLrD0pugbMTlEKuuXd5kf38179cIyITBimWoBu2XvJhmIKKjcujzbivFdS8vN0bdbr3nc1obVSnMHPb3zREo16XULgwfQn7n4TZqaq8owtiB/TJZibl+QWr9YQbfAo5De/1RO2L9bPp4rym5vG9Oj24dHpaLloBEZ85LDsBEi1fyXjtRXlvmlBLmSpekd8Fh9dTd0ID11Wk8zCoL34qQ9m5S1cQAC5Xpc3EJZ/QmUG6N25VDUYX90kQ4PNoc8aP0YN6FtHIliLAiML/9Y/ziFiKu+xqVBYKkG9UqFK6myG8IaxbFFcJ5/C26/0TFo2lpgewwvXZJEmWb9WWKwtbYuRFR8un8RBRSYTYJcbqbalh9nHSYZN7sGucYkCMuDxxaPRcGlGeNl1574b0dnmQ/aHoAXVY3JKpw2FO2MdNRZIX6P5cWmvWXt9ZA+iji08TOMOLkXcgg/zTTjX6z5rMKKqW+USkeEQ2fWsK92cBEkWGdp0JUnsF79qPhYDtqxJbbfmLf3HY8pn69nmpAdVRdC8Yy8gCKPDvzn74neaHud+M3f6wNprUd3RiEzHBBkNHi8Ddi8nsEPYuMVSlIGyVb5euO8OsFkNE00JBQaRhYsXLvmBLMvzUsHiUlbtfFaEoitUnG+ffW8HG5T4+BfbrqhlLBI4lVGFe6Hjww8Mg02Zj5uqD0iQmqKD92mdW1L43bqCkt3kBfo4S82GpMMIfrJ6TDTps4SDazv9N72YXjU27cYKysVShYZyK4AARS1L1qBAmV6pHO13mcSIpi4HFIuXOUYV8fUIaocHq85LTW3G48e0533ZwB5obASxZ1RyOAh63PmutwaOoEefQSZS767mnXToGYIzGLQ6sDRAYjfzMITUQXKr+gXC04Phd69vNvQ7lmCscP5eWkFsAzOxqQo+MOVaVf7VYBe2oXx0QcDKyKh9X0IJSzVXAMn0/IKNnOaFvYQXOGyaCIukCX5b2GsRfD5lbee44FWxgwavjCN5rTduZAtyw+6HK3MRBaxXJqGxIpzhsZNGVhCgDijYuYr/QQNMW14gbRk2T2A3EK2cCujQR7nEQl0gd22jspuS52LA1VKXiCTheaFgwquScGAgyX/6gbcZxfYsizkXv3Id7QS0heikbjCMn+dl8AVXLm8QEyIWor5y6m0FYTK26zUIPb/48ujQsKE7T58uL91qvRFkeBn0mv+ILMoBCXJHV8+Lcp8itXyJH98CV05oNjtaQKvcqiEKtp++w9867/S6BPyIEU+mpSQSHEEtZ/j2lMmqRv0Lo1WxPY35w1Xcperm/wF5EryPzhgE/w2bwwv1F4SZUPSB5p9iQia/czWqwlHKMv5B7cQvYaZz//1fX0BSyyaziYTLZZlOlDYdr62TvbZgMmHcmVN4nKEgdIgFhnrcAuQSdzPex+bWTbyjwQKqlnqljwd297y8X2VF/3WJc2GLCTCKSU4m+4lwmSVsv/Oa2m2ibVyMdXm/K/wKYlVl6HI5eCxhnnT3boLfUtirUtAoau4q+Pv9NT4++jmSPoo3xeORbhxTjqe7Lh7EVgSTZ6rMMg2FXkQ8kRjwcPX0mj2bVjEFx0ypcsiWXy6KQST+FxMcch3yLjYP9YTtAo54rFgV00DtTiq7aYIegxXjzgsc5wLnA788dT0sY+1/MmlmhmyMsCirjHLuKmfRSVjhRq6Wzodlqi4S5tdkEqyBv43MWfAN/3FGaRI7tN8fk+YQ+fm4x3VDbtv1bWRI0A1/m9Vq6zeuWzj+wyOfWU88pbyL++LNO+bfVvzL16Ed5LnGDEohFud/oF62h2vVlHTO/adxq+vWdmMAOzhEZfsqVJiEUjSxl/bNzDZewkVWSrUsCXTHTtmTxAxMui92WJptZ/8nIKx0TZqU6esLmHodE8pSyIMeFXzT4XgNxqlyL+oaHFMLyHrht1i7WHFiAoGsHdI1Ft8dgtppEHJvtvHvehIaBXQE+ePgHbwA/NgNSskV0Ds61f7k7MkckskoU6cF1PsKf2vNAlIjvRa9SXb4cqtp/9ZQhJsuvRhsGlQ/17DXSdbgFklw7ZKjhHWGXN7+u8tATynL/QOiF5WBKQrvGWdgrJtpeqjdSPOw+96M4Geql1PAhOP8iGPt7lrubFt7nisc8S44QZhCNJY6STuNHRVm/G9+yr/NztbHNPJxDTYSbKoJFmGhGZjN8kI4hj/6xhIDx3I2hdJcHIEZphEblCOZoajE1UAxDafex8w1jinQtdSY5WYAjuOcsm+BjkLiKgEl9WgYzhmwXjW3S6TLwC6QXlQ7m4xVqlU/dL9t+UBGBerFAPKUZLxGdpQp2GFMgEKNmXK4jPF6A5Ee7oI2jcfrNaJEqOh7as0rjoMyfAdyNu6aJoXb0ENzQFTmvrwrsN7iIZnGuPgtABuhcmpRD7XuEKi2mPVcaZldjuPxFBXy6d+x4zx/HHYM5YOwGaMKviKNxqxeg0zcUcj58VMinBNxmKjlWmDloD1ouwtolPE7A3vJnbii42Z4c0qvAcHlqdr2bCJKgbfJW4C44TsY58GHxFglrTRPBNtrQDO4WncED3O8H/twoL7IWYS/eZ7Id4cuJOkf4Nf+Zo4BSWCUxVoWUHH0mwAvlHQHH9vUGFSRudA1DgUW/ulGN/ugFPfoXZVu4RDvTJe8b8sknv2hugralMOZeVXiBXmt1lZNZdWudPOu4ANQ+CPA86RWDx0kGWrJCCmkdBhgOx9OOqfS6GLW4VZqR6OK5L6/Pp7A7hGOWNOX7e+pROdeAlbXQ/6VOio1rlS3okv6DeizGdVzPMaq5UEUjOI1v2iLwAPxfLG0A4u0mTrgifHoc59zSQbl/OejHyQjhI2w21go0T4d9p+8n+BI2Do8ksvC/LoD4IZFX3w5P4Ruvft15W9u4w6dDRtW//xB+fsI/I0f4ojGkDy5lK55S/+NV0jiHH+c+ylhelfUIjN79cUEVxzwqqbV89d5rXkUG5Luz4n6NFecMUdCEwa/j3GBBXkHncv8whaHLjIp864cRVDWj1Dgr0BBnz2jAAC8cnUoQXRaZP2Ji1VUtHWq3JICH4c1er/NzBStW071x/bZOOlO7S7TZqtdcEmKRe/8c5wUjgPj07f9zs5ekUzYHcfqvVrJMWP8qtxuitm83k/cFrNdtDnlc20rCewPl1zuawQM69fMwKfCxLb72WI=]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>微容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合swagger2]]></title>
    <url>%2Fspringboot%E6%95%B4%E5%90%88swagger2.html</url>
    <content type="text"><![CDATA[前言 Api接口文档，一开始我是使用Markdown来编写的，后来发现了swagger，自动生成文档并且可以在线测试api（举个例子：机智云openApi），以下，简单记录springboot整合swagger2 一、引入依赖以gradle为例，现在最新版本为2.9.2但由于汉化受限，所以这里我们引入2.7.0版本， 1234dependencies &#123; compile 'io.springfox:springfox-swagger-ui:2.7.0' compile "io.springfox:springfox-swagger2:2.7.0"&#125; 二、添加配置添加配置类，更多配置请参照官方文档，传送门。 12345678910111213141516171819202122232425@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket petApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //指定api所在包 .apis(RequestHandlerSelectors.basePackage("pers.mrxiexie.usermanager.controller")) .paths(PathSelectors.any()) .build() .pathMapping("/"); &#125; public ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("标题") .description("描述信息") .contact("MrXieXie") .version("1.2") .build(); &#125;&#125; 三、编写接口文档swagger自动生成的文档，都是基于注解的，以下列举了常用注解，更多注解请参照官方wiki，传送门。 @Api：将类标记为Swagger资源 @ApiImplicitParam：表示API操作中的单个参数 @ApiModel：提供有关Swagger模型（实体类）的其他信息 @ApiModelProperty：添加和操作模型属性的数据。 @ApiImplicitParams：一个包装器，允许列出多个ApiImplicitParam对象 @ApiOperation：描述针对特定路径的操作 @ApiParam：为操作参数添加其他元数据 Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Api(value = "用户管理", description = "用户管理", tags = "用户管理", consumes = "application/json")@Slf4j@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @ApiIgnore @GetMapping("/login") public String login(HttpServletRequest request, HttpServletResponse response) &#123; String email = request.getParameter("email"); String password = request.getParameter("password"); log.info("email : " + email); log.info("password : " + password); return "main"; &#125; @ApiOperation(value = "获取所有用户", notes = "获取所有用户！！") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "size", value = "大小", required = true, dataType = "String", paramType = "query"), @ApiImplicitParam(name = "page", value = "页码", required = true, dataType = "String", paramType = "query") &#125;) @GetMapping(value = "/all", produces = &#123;MediaType.APPLICATION_JSON_VALUE&#125;) @ResponseBody public IPage&lt;User&gt; getAllUser(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String size = request.getParameter("size"); String page = request.getParameter("page"); log.info("size : " + size); log.info("page : " + page); return userService.getAllUser(Integer.valueOf(size), Integer.valueOf(page)); &#125; @ApiOperation(value = "删除用户", notes = "删除用户！！") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @ResponseBody @DeleteMapping(value = "/&#123;id&#125;", produces = &#123;MediaType.APPLICATION_JSON_VALUE&#125;) public Response deleteUser(@PathVariable(value = "id") Long id) &#123; boolean b = userService.deleteUser(id); return new Response().setCode(b ? 0 : -1); &#125; @ApiOperation(value = "保存用户", notes = "保存用户！！") @ResponseBody @PostMapping(value = "/", produces = &#123;MediaType.APPLICATION_JSON_VALUE&#125;) public Response saveUser(@RequestBody User user) &#123; boolean b = userService.saveUser(user); return new Response().setCode(b ? 0 : -1); &#125; @ApiOperation(value = "更新用户", notes = "更新用户！！") @ResponseBody @PutMapping(value = "/", produces = &#123;MediaType.APPLICATION_JSON_VALUE&#125;) public Response updateUser(@RequestBody User user) &#123; boolean b = userService.updateUser(user); return new Response().setCode(b ? 0 : -1); &#125; @ApiOperation(value = "获取用户", notes = "获取用户！！") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long", paramType = "path") @GetMapping(value = "/&#123;id&#125;", produces = &#123;MediaType.APPLICATION_JSON_VALUE&#125;) public User user(@PathVariable(value = "id") Long id) &#123; return userService.getUser(id); &#125;&#125; User：@Data和@Accessors(chain = true)是lombok的注解 123456789101112131415@ApiModel(value = "用户实体类", description = "用户实体类")@Data@Accessors(chain = true)public class User implements Serializable &#123; @ApiModelProperty(value = "用户id") private Long id; @ApiModelProperty(value = "用户名") private String name; @ApiModelProperty(value = "手机") private String phone; @ApiModelProperty(value = "地址") private String address; @ApiModelProperty(value = "年龄") private Integer age;&#125; 四、访问在线文档浏览器访问http://localhost:8081/swagger-ui.html，端口号为你项目的端口号，我这里使用的是8081端口。 duang~，除了我们原本注释上的中文，其余都是英文，下面我们来进行汉化。 五、汉化文档双击shift搜索swagger-ui.html springfox-swagger-ui-2.7.0.jar下有对应的汉化包 复制swagger-ui.html文件到META-INF.resources下，并把以下代码复制到如图位置 123&lt;!--国际化操作：选择中文版 --&gt;&lt;script src='webjars/springfox-swagger-ui/lang/translator.js' type='text/javascript'&gt;&lt;/script&gt;&lt;script src='webjars/springfox-swagger-ui/lang/zh-cn.js' type='text/javascript'&gt;&lt;/script&gt; 重新启动项目即可~，此时就能通过swagger在线测试api了，不再需要打开postman了 六、生成离线文档传送门，先把swagger2markup-maven-project-template项目拉到本地 把示例文件删除，目录结构如下： 浏览器上输入http://127.0.0.1:8081/v2/api-docs，把内容替换至swagger.json 修改build.gradle，添加输出文件为中文配置 1234567891011convertSwagger2markup &#123; swaggerInput file("src/docs/swagger/swagger.json").getAbsolutePath() outputDir asciiDocOutputDir config = ['swagger2markup.markupLanguage' : 'ASCIIDOC', 'swagger2markup.pathsGroupedBy' : 'TAGS', 'swagger2markup.extensions.dynamicDefinitions.contentPath': file('src/docs/asciidoc/extensions/definitions').absolutePath, 'swagger2markup.extensions.dynamicOverview.contentPath' : file('src/docs/asciidoc/extensions/overview').absolutePath, 'swagger2markup.extensions.dynamicPaths.contentPath' : file('src/docs/asciidoc/extensions/paths').absolutePath, 'swagger2markup.extensions.dynamicSecurity.contentPath' : file('src/docs/asciidoc/extensions/security').absolutePath, 'swagger2markup.outputLanguage' : 'ZH']&#125; 最后，执行asciidoctor即可在build/asciidoc目录下生成离线文档（默认会生成html和pdf）。 离线文档效果如下：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构]]></title>
    <url>%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[/bin /usr/bin、 /usr/local/bin 是Binary的缩写, 这个目录存放着最经常使用的命令 /home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin /usr/sbin 、 /usr/local/sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /lib 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc 所有的系统管理所需要的配置文件和子目录 my.conf /usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。 /boot 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs /tmp 这个目录是用来存放一些临时文件的 。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare /selinux [security-enhanced linux] 360 SELinux是一种安全子系统,它能控制程序只能访问特定文件 。 /var 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2FRedis%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[一、什么是RedisRedis：Remote Dictory Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器 Redis 与其他 key - value 缓存产品有以下三个特点 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份 二、下载安装 英文官网传送门 中文官网传送门 下载最新的Redis版本。 解压tar.gz 1$ tar -zxvf redis-5.0.0.tar.gz 下载C程序编译工具gcc 1$ yum install gcc 编译 若出现jemalloc/jemalloc.h：没有那个文件或目录，则先运行make distclean之后再make，即可完成安装 12$ cd redis-5.0.0/$ make 三、redis指令 默认安装目录为：/usr/local/bin redis-benchmark：性能测试工具，可以测试性能（需要先启动redis） redis-check-aof：修复有问题的AOF文件 redis-check-dump：修复有问题的dump.rdb文件 redis-cli：客户端，操作入口 redis-sentinel：redis集群使用 redis-server：redis服务器启动命令 --port：指定端口，默认6379端口 默认以前台形式启动，要以后台启动，需要修改redis-5.0.0目录中的redis.conf文件的daemonize属性为yes 指定启动配置文件：redis-server /myredis/redis.conf 四、redis数据类型redis五大数据类型： String：字符串（二进制安全，可以保存图片，最大512M） Hash：哈希，类似java里的Map（HashMap&lt;String, Object&gt;） List：列表，链表（左右都可以插入添加，对中间元素进行操作比较慢） Set：集合，无序集合 Zset：有序集合（sorted set） 常见数据类型操作命令，传送门 0、其他命令dbsize：数据库key数量 select index：切换数据库（index为数据库下标，0~15） flushdb：清除当前数据库 flushall：清除所有数据库 1、keykeys *：查询所有的key exits key：判断某个key是否存在 move key db：移动某个key到其他db expire key seconds：为某个key设置过期时间 ttl key：查看还有多少秒过期，-1表示永不过期，-2表示已过期 type key：查看你的key是什么类型 del key：删除某个key 2、stringappend key value：拼接value字符串到key中 strlen key：获取某个key对应值的长度 incr key：数字自增1 decr key：数字自减1 incrby key value：数字增加value descby key value：数字减去value getrange key start end：获取指定区间范围内的值（0到-1表示全部） setrange key offset value：设置指定区间范围内的值 setex key seconds value：设置带过期时间的key setnx key value：只有key不存在时设置key的值 mset key value [key value ...]：同时设置一个或多个key-value对 mget key [key ...]：获取所有（一个或多个）给定key的值 msetnx key value [key value ...]：同时设置一个或多个key-value对，当且仅当所有给定的key都不存在 getset key value：设置新值，把旧值返回 3、listlpush key value [value ...]：左push rpush key value [value ...]：右push lrange key start stop：从左边开始获取指定区间的值（0到-1表示全部） lpop key：左边出栈 rpop key：右边出栈 lindex key value：按照索引下标获取元素（从上到下） llen key：获取列表长度 lrem key count value：删除N个值 ltrim key start stop：截取指定区间的值，重新赋值给key rpoplpush source destination：从源列表的右边出栈一个元素，该元素左边入栈目的列表，并返回 lset key index value：设置列表某个index的值 linsert key before/after pivot value：在list某个已有值的前后再添加具体值 4、setsadd key member [member ...]：往集合添加元素 smembers key：查看集合有什么元素 sismember key member：查看member是否为集合的元素 scard key：获取集合元素个数 srem key member [member ...]：移除集合中的元素 srandmember key [count]：随机获取集合中count个元素 spop key [count]：随机从集合中出栈count个元素 smove source destination member：从source中的某个值移动倒destination中 sdiff key [key ...]：差集（集合中的哪些元素不在其他集合中） sinter key [key ...]：交集（集合中的哪些元素存在于其他集合中） sunion key [key ...]：并集（几个集合的并集，去重复） 5、hashhset key field value：设置键为key，值为 field - value 的键值对 hget key field：获取键为key，field的值 hmset key field value [field key ...]：设置多个键值对 hgetall key：获取所有键值对 hdel key field [field ...]：删除某个键值对 hlen key：获取键值对对数 hexists key field：key中是否存在该键值对的键 hkeys/hvals key：获取key的所有键或所有值 hincrby/hincrbyfloat key field increment：数字增加整数或浮点 hsetnx key field value：不存在赋值，存在无效 6、Zsetzadd key score member [score member ...]：设置键为key，score与member对 zrange key start stop [withscores]：获取区间的值（0到-1表示全部），加上withscores，显示所有score zrangebyscore key min max [withscores] [limit offset count]：获取区间的值根据score，(表示不包含，limit类似mysql的limit。举个例子：ZRANGEBYSCORE zset 20 (50 limit 1 2 zrem key member [member ...]：移除score下对应的member值，删除元素 zcard key：获取键为key，member的数量 zcount key min max：根据score区间获取member数量 zrank key member：获取member在key中的下标位置 zscore key member：按照member获取score zrevrank/zrevrange/zrevrangebyscore：反转 五、redis.conf配置文件1、redis.conf存放位置 配置文件redis.conf，在安装redis的安装路径下，一般把redis.conf复制到其他地方，在启动redis-server /myredis/redis.conf指定配置文件的位置。 2、units单位redis只支持bytes，不支持bit，大小写不敏感。 3、includes可以通过include包含其他配置文件 12# include /path/to/local.conf# include /path/to/other.conf 4、modules可以让用户编写代码来实现和扩展redis不具备的功能 12# loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so 5、network网络设置 1234567891011121314# 只响应本地ip的请求，不设置则响应可用网卡的所有连接请求bind 127.0.0.1# 禁用公网访问redis，如果需要外网访问redis则设置为no，并把上面的bind 127.0.0.1注释掉protected-mode yes# 默认启动端口为6379port 6379# 并发时，需要提高tcp的backlog的值来避免TCP的慢连接问题# backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列# 注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值tcp-backlog 511# 客户端空闲N秒后关闭连接（0为禁用）timeout 0# TCP连接保活策略，每隔300秒server端会向连接空闲的客户端发送一次ACK请求，检查客户端是否挂掉，对于无响应的客户端则关闭连接（0为禁用）tcp-keepalive 300 6、generalredis的一般设置 12345678910111213141516171819202122232425262728# 设置为`yes`已守护进程的形式启动redisdaemonize no# 使用什么管理redis守护进程# no 不启用# upstart 使用upstart# systemd 使用systemd # auto 基于环境变量选择使用upstart还是systemdsupervised no# 配置pid文件路径pidfile /var/run/redis_6379.pid# 日志级别# debug 记录大量日志，适用于开发、测试阶段）# verbose 较多日志信息# notice 适量日志，使用于生产# warning 部分重要，关键信息才会被记录loglevel notice# 日志文件的位置，当指定为空字符串时，为标准输出，如果redis守护进程模式运行，那么日志会输出到/dev/nulllogfile ""# 是否把日志记录到系统日志（默认被注释）syslog-enabled# 指定日志的标志（默认被注释）syslog-ident# 指定日志设备，必须是user或local0到local7（默认被注释）syslog-facility local0# 设置redis数据库数量，默认16个数据库databases 16# 是否启用logoalways-show-logo yes 7、snapshotting设置快照（rdb配置） 12345678910111213141516171819# rdb是整个内存压缩过的快照，rdb的数据结构，可以配置快捷触发条件# 默认# 1分钟改1万次# 5分钟改10次# 15分钟改1次# 如果需要禁用rdb，只需要不设置任何save指令，或者save传入一个空字符串参数（save ""）save 900 1save 300 10save 60 10000# 后台存储错误停止写stop-writes-on-bgsave-error yes# 对于存储在磁盘的快照(rdb)，是否进行压缩（可以关掉）rdbcompression yes# 存储快照后，是否要进行数据校验（可能会损耗10%的性能，如果要获取最大性能可以关闭此功能）rdbchecksum yes# 持久化rdb存储文件名dbfilename dump.rdb# 数据库镜像备份的文件放置路径（可以通过config get dir获取）dir ./ 8、replication主从复制配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 从机设置主机的ip和端口replicaof &lt;masterip&gt; &lt;masterport&gt;# 设置主机的密码，没有密码则忽略masterauth &lt;master-password&gt;# 当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave 可能会有两种表现：# 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候 # 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 "SYNC with master in progress" 的错误replica-serve-stale-data yes# 设置从机是否接收写操作，默认为只读，不能写replica-read-only yes# 主从复制是否使用无硬盘复制功能，默认为no。对于慢磁盘和快速(大带宽)网络，无磁盘复制工作得更好。# 1）Disk-backed：主机创建一个新的进程写RDB文件在磁盘，然后由父进程递增地传递到从机# 2）Diskless：主机创建一个新的进程直接写RDB文件在从机的socket上，根本不触及磁盘repl-diskless-sync no# 当启用无硬盘复制功能，服务器等待一段时间才会通过套接字向从机写RDB文件，这个时间可以配置。# 这一点很重要，因为一旦传送开始，就不可能再为新到达的从机服务。从机要排队等待下一次的RDB传送。# 因此主机等待一段时间让更多的从机到达。# 延时单位为秒，设置0为立即传送repl-diskless-sync-delay 5# 从机以预定义的间隔向服务器发送ping信号。默认为10秒repl-ping-replica-period 10# 以下选项设置复制超时# 1）从复制的角度来看，同步过程中批量传输I/O# 2）从从机（数据、ping）的角度# 3）从主机的角度来看副本超时（REPLCONF ACK pings）# 还要确保该值要大于repl-ping-replica-period，否则每次主机和从简的流量较低时，就会监测到超时repl-timeout 60# 同步后在复制套接字上是否禁用 TCP_NODELAY？# yes：Redis会使用更少的TCP包和发送数据到从机的带宽更少。但这会增加数据出现在复制端上的延迟，使用默认配置的Linux内核最多延迟40毫秒# no：数据出现在从机的延迟将会减少，但复制将使用更多的带宽。# 默认情况下，我们优化低延迟，但是在非常高的流量条件下，或者当主机和从机多次跳转时，将其改为“yes”可能是个好主意repl-disable-tcp-nodelay no# 设置复制backlog的大小。# backlog是一个缓冲区，当从机断开连接一段时间后，它会积累从机数据，因此当副本希望再次连接时，通常不需要完全的重新同步，但是部分的重新同步就足够了，只需要传递在断开连接时从机遗留的部分数据即可。# 复制backlog越大，副本断开连接的时间越长，稍后就能够执行部分重新同步。# 只有在至少连接一个副本时，才分配backlogrepl-backlog-size 1mb# 在主机一段时间内不再连接从机之后，backlog将会被释放。# 下面的选项配置从最后一个副本断开连接的时间需要多长时间来释放backlog缓冲区repl-backlog-ttl 3600# 如果主机不再正常工作，具有低优先级的从机被认为更适合升级。# 如10、100、25，则10将成为主机，如果优先级为0则不能成为主机。replica-priority 100# 当从机少于N个与主机之间的延迟小于M秒，主机将不再提供工作。默认N=0，M=10min-replicas-to-write Nmin-replicas-max-lag M 9、security安全配置 123456# 设置密码（默认被注释）# config get requirepass：获取密码# config set requirepass pass：设置密码为pass# 设置完密码后需要验证密码# auth passrequirepass foobared 10、clients客户端配置 12# 设置最大客户端数量maxclients 10000 11、memory management内存管理配置 12345678910111213141516171819202122232425# 设置redis可用的最大内存量# 一旦达到内存上限，redis会试图移除内部数据，移除规则通过（maxmemory-policy）指定# 如果redis无法根据移除规则来移除内存数据，或者设置了不允许移除# 那么redis则会针对那些需要申请内存的指令返回错误信息（set、lpush等）# 但是无内存申请的指令会正常响应（get等）maxmemory &lt;bytes&gt;# 达到最大内存策略（5种策略）# 1、lru（Least Recently Used：最近最少使用）# volatile-lru -&gt; 使用lru移除key，只针对设置了过期时间的key# allkeys-lru -&gt; 使用lru移除key# 2、lfu（Least Frequently Used：最近最不常用）# volatile-lfu -&gt; 使用lfu移除key，只针对设置了过期时间的key# allkeys-lfu -&gt; 使用lfu移除key# 3、random（随机）# volatile-random -&gt; 随机移除key，只针对设置了过期时间的key# allkeys-random -&gt; 随机移除key# 4、ttl（Time To Live，生存时间值）# volatile-ttl -&gt; 删除最近过期时间的key# 5、noeviction（不移除）maxmemory-policy noeviction# LRU、LFU和最小TTL算法都不是精确的算法，而是近似的算法# 所以需要设置需要的样本值，从样本中进行算法（默认5可以产生足够好的结果，10非常真正的LRU，但是需要更多CPU）maxmemory-samples 5# 副本忽略最大内存限制replica-ignore-maxmemory yes 12、lazy freeinglazy free可译为惰性删除或延迟释放；当删除键的时候,redis提供异步延时释放key内存的功能，把key释放操作放在bio(Background I/O)单独的子线程处理中，减少删除big key对redis主线程的阻塞。有效地避免删除big key带来的性能和可用性问题。 123456789# 默认全部都没开启# redis内存大于maxmemory，并设置淘汰策略时，在被动删除key时，是否采用lazy freelazyfree-lazy-eviction no# 针对设置有ttl的key，达到过期后，被redis清理删除时是否采用lazy freelazyfree-lazy-expire no# 针对有些指令在处理已存在的key时，会带有隐式的DEL键，如rename，是否采用lazy freelazyfree-lazy-server-del no# 针对slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景，是否采用lazy freereplica-lazy-flush no 参考链接：https://www.jianshu.com/p/e927e99e650d 13、append only modeaof配置 12345678910111213141516171819202122232425# 是否启用aof，默认为noappendonly no# 生成的aof文件名appendfilename "appendonly.aof"# 更新aof文件条件，三个可选值：# 1、always：同步持久化，每次发生数据变更都会被立即记录到磁盘，性能较差但数据完整性比较好# 2、everysec：默认推荐，异步操作，每秒记录，如果一秒内宕机，该秒会数据丢失# 3、no：只要让操作系统在需要时刷新数据。速度快appendfsync no# 重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。# 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync（记录）会造成阻塞过长时间。# 对于延迟要求很高的应用，可以设置为yes，测试哦rewrite期间对于新写的操作不会进行fsync，暂时存在内存中，等rewrite结束后再进行写入。Linux的默认fsync策略是30秒。可能丢失30秒数据。no-appendfsync-on-rewrite no# 设置重写的基准值# aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写# 即当aof文件增长到一定大小的时候，redis就能调用bgrewriteaof对日志文件进行重写。# 默认为100，即两倍，自动启动新的日志重写过程auto-aof-rewrite-percentage 100# 指定允许重写的最小aof文件大小，避免达到了约定百分比，但文件仍然很小的情况还要重写auto-aof-rewrite-min-size 64mb# aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象，redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。aof-load-truncated yes# 在重写AOF文件时，Redis可以在AOF文件中使用RDB序言来加快重写和恢复。当打开此选项时，重写后的AOF文件由两个不同的小节组成:[RDB文件][AOF tail]。加载Redis时，发现AOF文件以“Redis”字符串开头，加载带前缀的RDB文件，并继续加载AOF tail。# 开启RDB与AOF混合持久化，需要appendonly yesaof-use-rdb-preamble yes 14、lua scriptinglua脚本配置 12# Lua脚本的最大执行时间(毫秒)lua-time-limit 5000 15、redis clusterredis集群配置 123456789# 启动redis集群cluster-enabled yes# 每一个redis集群节点都有自己的配置文件，确保每个节点只有一份配置文件# 指定配置文件的名字cluster-config-file nodes-6379.conf# 集群节点超时时间cluster-node-timeout 15000# cluster-replica-validity-factor 10 ==以下配置待续== 16、cluster docker/nat support17、slow log18、latency monitor19、event notifacation20、advance config21、actice defpagmentation六、持久化（1）RDBRDB：Redis DataBase 1、是什么？ Redis默认备份方式，备份文件名默认为dump.rdb 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 2、Fork fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 3、触发RDB快照 配置文件中默认的快照配置，满足以下三条其中一个将会触发RDB快照 1分钟10000次写 5分钟10次写 30分钟1次写 命令save和bgsave save：save时只管保存，其它不管，全部阻塞 BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 4、恢复备份 将备份文件（dump.rdb）移动到redis安装目录并启动服务即可 config get dir：通过该命令获取备份文件目录 5、优劣势 优势： 适合大规模的数据恢复 对数据完整性和一致性要求不高 劣势： 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改 fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 6、如何停止 动态所有停止RDB保存规则的方法：redis-cli config set save “” （2）AOFAOF：appendonly file 1、是什么？ AOF默认不开启，需要再redis.conf中开启AOF（具体查看配置文件），备份文件名默认为appendonly.aof 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 2、AOF启动、修复、恢复 正常恢复 启动：修改配置文件appendonly yes 将有数据的aof文件复制一份保存到对应目录（config get dir） 恢复：重启redis然后重新加载 异常恢复 启动：修改配置文件appendonly yes 备份被写坏的AOF文件 修复：使用redis-check-aof --fix进行修复 恢复：重启redis然后重新加载 3、重写机制 是什么？AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 重写原理：AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似 触发机制：Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大小64M（可以配置文件修改）时触发 4、优劣势 优势： 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失 不同步：appendfsync no 从不同步 劣势： 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同 （3）RDB-AOF混合持久化 配置文件中，修改aof-use-rdb-preamble为 true（默认就为true，启动了aof就会起作用） 在重写AOF文件时，Redis可以在AOF文件中使用RDB序言来加快重写和恢复。当打开此选项时，重写后的AOF文件由两个不同的小节组成：[RDB文件][AOF tail]。 旧的数据存储在RDB中，rewrite（重写）后的写入将用aof保存。 七、事务1、是什么 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞 一个队列中，一次性、顺序性、排他性的执行一系列命令 2、常用命令 MULTI：开启事务 DISCARD：放弃事务 WATCH：类似乐观锁，开启事务前，监控一个或多个key，当在事务执行中，有一个key的值发生改变，则会回滚整个事务 UNWATCH：取消监控一个或多个key EXEC：触发事务，执行成功或失败都会取消所有key的监控 3、事务三阶段 开启：以MULTI开始一个事务 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面 执行：由EXEC命令触发事务 4、事务三特性 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 八、Redis的发布订阅 进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 1、常用命令 subscribe c1 c2 c2：一次性订阅一个或多个，可以使用通配符，如`subscribe new` publish c1 msg：消息发布 九、Redis的Master/Slave1、是什么？ 行话：也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。 2、能干什么？ 读写分离 容灾恢复 3、常用命令 slaveof 主机ip 主机端口：跟随一个主机 slaveof no one：反客为主 info replication：查看主从关系信息 4、怎么玩？ 配从不配主 从库配置：slaveof 主机ip 主机端口，如果不配置需要手动配置 常用三招： 一主二仆：一个主机两个从机，主机挂掉，从机会等待主机重新上线 薪火相传：从机也可以是另外一个从机的主机，当最上级主机发生写操作，所有从机（包括下级从机）都会同步 反客为主：SLAVEOF no one，使当前数据库停止与其他数据库的同步，转成主数据库 5、复制原理 slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 6、哨兵模式(sentinel) 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 新建sentinel.conf文件，编辑内容为如下： 1sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机 启动哨兵：redis-sentinel sentinel.conf 当主机挂掉后，从机投票得出新的主机，旧的主机回来后会成为新主机的从机。哨兵模式启动后，对应挂掉的主机或从机，重新启动后会被哨兵重写对应的配置文件，把新的主机地址和端口放在slaveof 主机ip 主机端口中。 十、sentinel.conf配置文件1、sentinel.conf存放位置 配置文件sentinel.conf，在安装redis的安装路径下，一般把sentinel.conf复制到其他地方，在启动redis-server /myredis/sentinel.conf --sentinel指定配置文件的位置。 2、普通配置123456789101112131415161718192021222324252627# 哨兵进程端口port 26379# 设置为yes以守护进程模式启动哨兵daemonize no# 当daemonize为yes时，会把进程id写在pidfile指定的文件中pidfile /var/run/redis-sentinel.pid# 日志文件的位置，当指定为空字符串时，为标准输出，如果redis守护进程模式运行，那么日志会输出到/dev/nulllogfile &quot;&quot;# 哨兵工作目录dir /tmp# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;# 告诉哨兵去监听 ip为：127.0.0.1，端口为：6379 的一个主redis进程，master名可以随意设置，quorum为一个数字# quorum表示当有多少个哨兵进程认为一个master失效，才认为master失效，并执行故障转移sentinel monitor mymaster 127.0.0.1 6379 2# 设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# 默认30秒主机没有回应则认定为master失效sentinel down-after-milliseconds mymaster 30000# 在故障转移期间，我们可以重新配置多少个副本以同时指向新副本，在同步的过程中副本会无法访问# 所以如果使用副本服务查询，请使用较低的数字，以避免在执行与主服务器的同步时，几乎同时无法访问所有副本。sentinel parallel-syncs mymaster 1# 指定故障转移超时（毫秒）。它有很多种用途# 1、在给定的sentinel对同一主服务器尝试上一次故障转移后，重新启动故障转移所需的时间是故障转移超时的两倍。# 2、根据sentinel当前配置，复制到错误主服务器的复制副本需要的时间，强制使用正确的主服务器进行复制，正是故障转移超时（从sentinel检测到错误配置的那一刻算起）。# 3、取消已在进行但未产生任何配置更改的故障转移所需的时间（slaveof尚未被提升的副本确认）。# 4、当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。sentinel failover-timeout mymaster 180000 3、脚本配置哨兵模式的脚本执行包括以下两种： notification-script 配置调用以通知系统管理员的脚本 reconfig-script 故障转移后重新配置客户端 执行脚本使用以下错误处理规则： 如果脚本以“1”退出，则稍后将重试执行（当前最多设置10次）。 如果脚本退出时带有“2”（或更高的值），则不会重试脚本执行。 如果脚本由于接收到信号而终止，则行为与退出代码1相同。 脚本的最大运行时间为60秒。达到此限制后，将使用sigkill终止脚本，并重试执行。 （1）notification-script 为警告级别中生成的任何sentinel事件调用指定的通知脚本（例如-sdown、-odown等）。 此脚本应通过电子邮件、SMS或任何其他消息传递系统通知系统管理员受监控的Redis系统有问题。 调用脚本时只使用两个参数：第一个参数是事件类型，第二个参数是事件描述。 如果提供此选项，脚本必须存在并可执行，以便sentinel启动。 sentinel notification-script mymaster /var/redis/notify.sh （2）client-reconfig-script 当主服务器由于故障转移而发生更改时，可以调用脚本以执行特定于应用程序的任务，以通知客户端配置已更改且主服务器位于不同的地址。 以下参数将传递给脚本： &lt;master name&gt;&lt;role&gt;&lt;state&gt;&lt;from ip&gt;&lt;from port&gt;&lt;to ip&gt;&lt;to port&gt; &lt;state&gt;当前总是“故障转移” &lt;role&gt;是“leader”或“observer” &lt;from ip&gt;、&lt;from port&gt;、&lt;to ip&gt;、to port的参数用于通信主服务器的旧地址和所选副本（现在是主服务器）的新地址。 这个脚本应该能够抵抗多次调用。 sentinel client-reconfig-script mymaster /var/redis/reconfig.sh 4、安全配置12345678910# 默认情况下，sentinel集将无法在运行时更改通知脚本和客户端reconfig脚本。这样就避免了一个小的安全问题，客户机可以将脚本设置为任何内容，并触发故障转移以执行程序。sentinel deny-scripts-reconfig yes# redis命令重命名# 有时redis服务器有一些命令，这些命令是sentinel正常工作所必需的，重命名为不可访问的字符串。这通常是配置和slaveof的情况，在提供redis作为服务的提供者的上下文中，不希望客户在管理控制台之外重新配置实例。# 在这种情况下，可以告诉sentinel使用不同的命令名，而不是普通的命令名。例如，如果主“mymaster”和相关副本的“config”全部重命名为“guessme”，我可以使用：SENTINEL rename-command mymaster CONFIG GUESSME# 在设置了这样的配置之后，每次sentinel使用config时，它都会使用guessme。注意，实际上不需要尊重命令案例，因此在上面的示例中编写“config guessme”是相同的。# Sentinel集也可用于在运行时执行此配置。# 为了将命令设置回其原始名称（撤消重命名），只需将命令重命名为它本身SENTINEL rename-command mymaster CONFIG CONFIG]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从U盘安装ArchLinux]]></title>
    <url>%2F%E4%BB%8EU%E7%9B%98%E5%AE%89%E8%A3%85ArchLinux.html</url>
    <content type="text"><![CDATA[前言 都说ArchLinux比较难安装，本文简单记录通过U盘去安装ArchLinux。当然还是主要参照官方文档wiki。传送门 一、把镜像写入U盘 首先要准备好u盘。要备份好u盘中的数据，稍后会格式化u盘。 参照官方wiki提供的多种写入镜像的方法，传送门)，这里使用USBWriter（百度云盘地址）。 Source file：选择ArchLinux的iso镜像 Target device：选择需要写入的u盘 最后点击Write等待完成即可 二、开始安装ArchLinux1、wifi-menu 2、nano /etc/pacman.d/mirrorlist 3、fdisk /dev/sda 123456789# 500M /boot/EFI $ mkfs.fat -F32 /dev/sda1# 500M /boot $ mkfs.ext4 /dev/sda2# 12G swap$ mkswap/dev/sda3$ swapon/dev/sda3# 100G /$ mkfs.ext4 /dev/sda4 4、挂载 12345$ mount /dev/sda4 /mnt$ mkdir /mnt/boot$ mount /dev/sda2 /mnt/boot$ mkdir /mnt/boot/EFI$ mount /dev/sda1 /mnt/boot/EFI 5、 pacstrap -i /mnt base base-devel 6、 进入到新系统 12$ genfstab -U /mnt &gt;&gt; /mnt/etc/fstab$ arch-chroot /mnt 7、本地化 1234567$ nano /etc/locale.gen# 反注释（删掉前面的#） # en_US.UTF-8 UTF-8 # zh_CN.UTF-8 UTF-8 # 这两个，退出保存 $ locale-gen$ echo LANG=en_US.UTF-8 &gt; /etc/locale.conf 8、设置时区 9、引导系统 123$ pacman -S dosfstools grub efibootmgr$ grub-install --target=x86_64-efi --efi-directory=/boot/EFI --recheck$ grub-mkconfig -o /boot/grub/grub.cfg 10、用户管理 1234567# 设置root密码$ passwd$ useradd mrxiexie$ passwd mrxiexie$ nano /etc/sudoers#在 root ALL=(ALL) ALL 下面添加 #用户名 ALL=(ALL) ALL 11、下载wifi-menu必要包 12# 重启前先调用该命令pacman -S iw wpa_supplicant dialog 三、配置i312345678910# 下载i3$ pacman -S i3# 下载xorg$ pacman -S xorg xorg-xinit# 复制配置文件到家目录$ cp /etc/X11/xinit/xinitrc ~/.xinitrc# 修改.xinitrc最后一行为$ exec i3# 启动$ startX 四、配置ArchLinux1、安装aur，执行以下shell脚本 123456789#!/bin/bashgit clone https://aur.archlinux.org/package-query.gitcd package-querymakepkg -sicd ..git clone https://aur.archlinux.org/yaourt.gitcd yaourtmakepkg -sicd .. 2、安装openssh远程登录 123$ pacman -S openssh# 修改/etc/ssh/sshd_config，将PermitRootLogin yes前的#号去掉允许root远程登录$ vim /etc/ssh/sshd_config 3、本地化 添加以下三行到~/.xinitrc中，放在exec前 123export LANG=zh_CN.UTF-8export LANGUAGE=zh_CN:en_USexport LC_CTYPE=en_US.UTF-8 4、设置时间 123$ ln -S /usr/share/zoneinfo/Asia/Shanghai /etc/localtime$ hwclock --systohc --utf# 修改/etc/locatime CST-8为CST-0 5、安装搜狗输入法 传送门 6、安装i3lock锁屏 1234$ pacman -S i3lock$ yaourt -S i3lock-wrapper# 自动锁屏$ pacman -S xautolock 7、安装chrome浏览器 12 8、安装polybar状态栏 1$ yaourt -S polybar 9、安装rofi搜索 配置文件在~/.Xresources 1$ pacman -S rofi 10、安装i3-gaps桌面 配置文件在~/.config/i3/config 1yaourt -S i3-gaps 11、安装flux 12、安装lantern-bin 13、安装终端 1$ pacman -S xfce4-terminal ==待续==]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ArchLinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA整合Docker详细教程]]></title>
    <url>%2FIDEA%E6%95%B4%E5%90%88Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、简单介绍Docker守护进程（Daemon）Docker守护进程可以监听三种不同类型的Socket请求：unix，tcp，和fd。 默认情况下，创建unixSocket，/var/run/docker.sock，需要root权限或docker组成员身份。 如果需要远程访问Docker守护进程，则需要启用tcpSocket。注意，默认设置提供对Docker守护进程的未加密和为经过身份验证的直接访问。 未加密（所有人都可以访问，不安全）： dockerd -H tcp:0.0.0.0:2375：使ip地址监听2375所有网络接口上的端口 dockerd -H tcp:192.168.59.103:2375：使ip地址监听特定网络接口 加密（只有证书的才能访问，安全）： 通常使用2376与守护进程进行加密通信 以下将分不加密与加密介绍IDEA与Docker的整合。 二、不加密（1）开放Docker远程连接访问方法一： 使用dockerd启动Docker 1$ dockerd -H tcp:0.0.0.0:2375 方法二： 修改/usr/lib/systemd/system/docker.service的ExecStart属性，不需要每次启动都带上参数 1$ vim /usr/lib/systemd/system/docker.service 修改ExecStart属性为如下 /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock （2）重启Docker12$ systemctl daemon-reload $ systemctl restart docker （3）开放2375端口以centos7为例 12345$ firewall-cmd --zone=public --add-port=2375/tcp --permanentsuccess$ systemctl restart firewalld.service$ firewall-cmd --zone=public --query-port=2375/tcpyes #yes说明已开放2375端口 （4）把项目打为jar包备用 （5）配置IDEA中的Docker插件Engine API URL填写对应的地址与端口 显示Connection successful则说明配置成功 此时左下角多了docker标签，显示了该docker中所拥有的所有容器和镜像 （6）编写Dockerfile创建Dockerfile文件 内容如下： 1234FROM openjdk:8EXPOSE 8080COPY docker-0.0.1-SNAPSHOT.jar docker.jarCMD ["java", "-jar", "/docker.jar"] （7）创建镜像并运行容器 Edit Configuration新增Dockerfile配置，填写对应信息，点击ok即可~ 点击运行 稍等片刻，等容器运行 （8）在浏览器访问容器 三、加密为什么要加密？第二步的配置所有人都可以访问，意味着黑客可以随时黑你的服务器。所以根据官网的说明，可以通过加密通信来保证安全。 加密可参照官网文档一步步操作，传送门 （1）创建保存证书的文件夹此处我把文件夹创建在root文件夹下 1$ mkdir -p /root/ac （2）创建CA证书切换到ac文件夹下，生成CA私钥和公钥 创建私钥，需要输入两次密码 1234567[root@mrxiexie ac]# openssl genrsa -aes256 -out ca-key.pem 4096Generating RSA private key, 4096 bit long modulus.....................++.............................................++e is 65537 (0x10001)Enter pass phrase for ca-key.pem:Verifying - Enter pass phrase for ca-key.pem: 首先输入私钥密码，然后依次输入国家，省，区，组织，邮箱等 12345678910111213141516[root@mrxiexie ac]# openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pemEnter pass phrase for ca-key.pem:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:GuangdongLocality Name (eg, city) [Default City]:ShundeOrganization Name (eg, company) [Default Company Ltd]:MrXieXieOrganizational Unit Name (eg, section) []:MrXieXieCommon Name (eg, your name or your server's hostname) []:MrXieXieEmail Address []:MrXieXie@qq.com （3）创建服务器密钥和证书签名请求（CSR）12345[root@mrxiexie ac]# openssl genrsa -out server-key.pem 4096Generating RSA private key, 4096 bit long modulus................................++..........................................................................................................................................++e is 65537 (0x10001) $Host换成你自己服务器外网的IP或者域名，由于我使用的是虚拟机，这里填写了虚拟机的ip地址192.168.252.128 1[root@mrxiexie ac]# openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server.csr （4）签署公钥由于可以通过IP地址和DNS名称建立TLS连接，因此在创建证书时需要指定它们。 建议使用0.0.0.0，即允许所有的ip都访问，但只有拥有证书的人才能够连接成功。此处需要输入一次ca证书密码。 若使用IP则命令如下，多个可用逗号分隔 echo subjectAltName = IP:x.x.x.x,IP:y.y.y.y &gt; extfile.cnf 若使用域名则命令如下 echo subjectAltName = DNS:www.mrxiexie.cn,IP:y.y.y.y &gt; extfile.cnf 123456[root@mrxiexie ac]# echo subjectAltName = IP:0.0.0.0,IP:192.168.252.128 &gt; extfile.cnf[root@mrxiexie ac]# openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnfSignature oksubject=/CN=192.168.252.128Getting CA Private KeyEnter pass phrase for ca-key.pem: （5）创建客户端密钥和证书签名请求 创建key.pem 123456[root@mrxiexie ac]# openssl genrsa -out key.pem 4096Generating RSA private key, 4096 bit long modulus....................................................++................................................................................................................................................................++e is 65537 (0x10001)[root@mrxiexie ac]# openssl req -subj '/CN=client' -new -key key.pem -out client.csr （6）签署私钥 要使密钥适合客户端身份验证，创建扩展配置文件： 1[root@mrxiexie ac]# echo extendedKeyUsage = clientAuth &gt; extfile.cnf 签署私钥，输入ca证书密码 生成cret.pem 12345[root@mrxiexie ac]# openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile.cnfSignature oksubject=/CN=clientGetting CA Private KeyEnter pass phrase for ca-key.pem: （7）删除两个证书签名请求12345[root@mrxiexie ac]# rm -v client.csr server.csrrm：是否删除普通文件 "client.csr"？y已删除"client.csr"rm：是否删除普通文件 "server.csr"？y已删除"server.csr" （8）修改文件读写权限 为了保护您的密钥免受意外损坏，您需要删除其写入权限。要使它们只能被您读取 1234[root@mrxiexie ac]# chmod -v 0400 ca-key.pem key.pem server-key.pemmode of "ca-key.pem" changed from 0644 (rw-r--r--) to 0400 (r--------)mode of "key.pem" changed from 0644 (rw-r--r--) to 0400 (r--------)mode of "server-key.pem" changed from 0644 (rw-r--r--) to 0400 (r--------) 证书可以是可读的，删除写权限以防止意外损坏 1234[root@mrxiexie ac]# chmod -v 0444 ca.pem server-cert.pem cert.pemmode of "ca.pem" changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of "server-cert.pem" changed from 0644 (rw-r--r--) to 0444 (r--r--r--)mode of "cert.pem" changed from 0644 (rw-r--r--) to 0444 (r--r--r--) （9）启动Docker启动Docker守护程序仅接受来自提供CA信任的证书的客户端的连接，注意要开放2376端口，请参照不加密第三条 方式一：以前台方式启动 1[root@mrxiexie ac]# dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem -H=0.0.0.0:2376 方式二： 修改/usr/lib/systemd/system/docker.service的ExecStart属性，不需要每次启动都带上参数 1ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/root/ac/ca.pem --tlscert=/root/ac/server-cert.pem --tlskey=/root/ac/server-key.pem -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock 重启docker 12$ systemctl daemon-reload $ systemctl restart docker （10）把客户端pem证书保存到本地 把三个证书放在同一个目录中： （11）配置IDEA Certificates floder指定证书目录 显示Connection successful则配置成功 四、脚本生成证书嫌加密要输的命令太多了？shell脚本帮你搞掂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/bin/bash# # Created by L.STONE &lt;web.developer.network@gmail.com&gt;# -------------------------------------------------------------# 自动创建 Docker TLS 证书# -------------------------------------------------------------# 以下是配置信息# --[BEGIN]------------------------------IP="192.168.252.128"PASSWORD="root"COUNTRY="CN"STATE="GD"CITY="SD"ORGANIZATION="MrXieXie"ORGANIZATIONAL_UNIT="MrXieXie"COMMON_NAME="192.168.252.128"EMAIL="MrXieXie@qq.com"# --[END]--# Generate CA keyopenssl genrsa -aes256 -passout "pass:$PASSWORD" -out "ca-key.pem" 4096# Generate CAopenssl req -new -x509 -days 365 -key "ca-key.pem" -sha256 -out "ca.pem" -passin "pass:$PASSWORD" -subj "/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL"# Generate Server keyopenssl genrsa -out "server-key.pem" 4096# Generate Server Certs.openssl req -subj "/CN=$COMMON_NAME" -sha256 -new -key "server-key.pem" -out server.csrecho "subjectAltName = IP:$IP,IP:127.0.0.1" &gt;&gt; extfile.cnfecho "extendedKeyUsage = serverAuth" &gt;&gt; extfile.cnfopenssl x509 -req -days 365 -sha256 -in server.csr -passin "pass:$PASSWORD" -CA "ca.pem" -CAkey "ca-key.pem" -CAcreateserial -out "server-cert.pem" -extfile extfile.cnf# Generate Client Certs.rm -f extfile.cnfopenssl genrsa -out "key.pem" 4096openssl req -subj '/CN=client' -new -key "key.pem" -out client.csrecho extendedKeyUsage = clientAuth &gt;&gt; extfile.cnfopenssl x509 -req -days 365 -sha256 -in client.csr -passin "pass:$PASSWORD" -CA "ca.pem" -CAkey "ca-key.pem" -CAcreateserial -out "cert.pem" -extfile extfile.cnfrm -vf client.csr server.csrchmod -v 0400 "ca-key.pem" "key.pem" "server-key.pem"chmod -v 0444 "ca.pem" "server-cert.pem" "cert.pem"# 打包客户端证书mkdir -p "tls-client-certs"cp -f "ca.pem" "cert.pem" "key.pem" "tls-client-certs/"cd "tls-client-certs"tar zcf "tls-client-certs.tar.gz" *mv "tls-client-certs.tar.gz" ../cd ..rm -rf "tls-client-certs"# 拷贝服务端证书mkdir -p /etc/docker/certs.dcp "ca.pem" "server-cert.pem" "server-key.pem" /etc/docker/certs.d/# /etc/docker/daemon.json# &#123;# "tlsverify": true,# "tlscacert": "/etc/docker/certs.d/ca.pem",# "tlscert": "/etc/docker/certs.d/server-cert.pem",# "tlskey": "/etc/docker/certs.d/server-key.pem",# "hosts": ["tcp://0.0.0.0:2376", "unix:///var/run/docker.sock"]# &#125;echo " - 修改 /etc/docker/daemon.json 文件"cat &lt;&lt;EOFvi /etc/docker/daemon.json&#123; "tlsverify": true, "tlscacert": "/etc/docker/certs.d/ca.pem", "tlscert": "/etc/docker/certs.d/server-cert.pem", "tlskey": "/etc/docker/certs.d/server-key.pem", "hosts": ["tcp://0.0.0.0:2376", "unix:///var/run/docker.sock"]&#125;EOF# 拷贝客户端证书文件# cp -v &#123;ca,cert,key&#125;.pem ~/.docker# 客户端远程连接# docker -H 192.168.1.130:2376 --tlsverify --tlscacert ~/.docker/ca.pem --tlscert ~/.docker/cert.pem --tlskey ~/.docker/key.pem ps -aecho "docker -H $IP:2376 --tlsverify --tlscacert ~/.docker/ca.pem --tlscert ~/.docker/cert.pem --tlskey ~/.docker/key.pem ps -a"# 客户端使用 cURL 连接# curl --cacert ~/.docker/ca.pem --cert ~/.docker/cert.pem --key ~/.docker/key.pem https://192.168.1.130:2376/containers/jsonecho "curl --cacert ~/.docker/ca.pem --cert ~/.docker/cert.pem --key ~/.docker/key.pem https://$IP:2376/containers/json"echo -e "\e[1;32mAll be done.\e[0m" 执行完脚本后，修改/etc/docker/daemon.json 12345678$ vi /etc/docker/daemon.json&#123; "tlsverify": true, "tlscacert": "/etc/docker/certs.d/ca.pem", "tlscert": "/etc/docker/certs.d/server-cert.pem", "tlskey": "/etc/docker/certs.d/server-key.pem", "hosts": ["tcp://0.0.0.0:2376", "unix:///var/run/docker.sock"]&#125; 然后重启docker即可~，客户端证书都已经打包好在你执行脚本了。 修改/usr/lib/systemd/system/docker.service的ExecStart属性 1ExecStart=/usr/bin/dockerd 重新启动docker 12$ systemctl daemon-reload $ systemctl restart docker 把ca目录下的tls-client-certs.tar.gz复制到window下，里面有客户端的三个证书，idea指向对应的解压目录即可。 ps：如果直接把脚本在window下放到linux下执行可能会出错，由于window的换行跟linux的换行有所不同。只需在vim命令下:set ff=unix即可。还有别忘了，脚本需要给执行权限才能运行~]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText3配置Lua开发环境]]></title>
    <url>%2FSublimeText3%E9%85%8D%E7%BD%AELua%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[前言 关于SublimeText这款开发神器，以后会出文章记录安装流程及常用的插件安装。 最近在学lua这门轻量级的脚本语言，为了要在触动精灵上大显身手。一款灵活的开发工具就显得很重要了，官方自带的开发工具对中文支持不太好，而且代码补全不够完善。后来接触到了其他几款IDE，也尝试过在IDEA中安装EmmyLua插件进行开发，但IDEA太占内存了，感觉拿来开发几个lua小脚本有点小题大做。最终，选择用SublimeText这款神器进行lua脚本开发。 一、安装LuaForWindow首先要安装lua脚本的编译环境，点击后方链接，安装在你喜欢的地方即可：LuaForWindow传送门。 安装完成后打开cmd，输入lua -v，出现版本信息，即安装成功。 二、创建Hello.lua在sublime中创建Hello.lua，输入print(&#39;Hello World&#39;)，快捷键ctrl + B运行，可看到运行成功。 三、安装插件（1）Lua Dev 运行出错提示错误信息，传送门 （2）Lua Extended 添加while、repeat等代码片段，传送门。 安装插件后ctrl + shift + p，输入set Syntax: LuaExtended切换到该语法环境下开发。 （3）Lua Format lua代码格式化，传送门。 由于我们安装了Lua Extended插件，我们需要在LuaExtended语法下开发，而Lua Format只能在Lua语法下起作用，所以还需要以下配置。 SharePreference &gt; Package Settings &gt; Lua Format &gt; Key Bindings - User 在KeyMap的User下添加如下 安装PackageResourceViewer插件 ctrl + shift + p，输入open resource &gt; LuaFormat &gt; LuaFormat.py 修改内容如下： 12file_suffix = suffix_setting.split('/')[2]if not file_suffix.lower().startswith('lua'): return ctrl + s保存即可 （4）sublimelinter-lua 语法检测，传送门。 安装该插件前，首先要先安装sublimelinter 由于我们安装了Lua Extended插件，我们需要在LuaExtended语法下开发，而sublimelinter-lua只能在Lua语法下起作用，所以还需要以下配置。 根据Lua Extended文档的设置Linters的配置文件，可是不成功，具体原因还不清楚。只能通过以下偏方法来解决了。 在SublimeText安装目录中找到LuaExtended.sublime-package文件 右键使用解压文件打开，修改LuaExtended为Lua，保存即可（需要先关闭SublimeText才能修改） 最终效果如下： （5）SublimeLinter-luacheck 使用未定义变量提示，传送门。 安装该插件前，首先要先安装sublimelinter，还需要下载luacheck文件，传送门。 把下载完的luacheck.exe文件放在LuaForWindow的与Lua.exe的同级目录下（简单来说就是要将luacheck.exe，放在环境变量下） 最终效果如下：]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>SublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、创建本地仓库git init 初始化本地仓库 使用后文件夹会生成.git隐藏目录，这个目录是Git来跟踪管理版本库的。 git add . 把修改内容添加到暂存区 .：代表提交所有（没有被忽略的文件） git add readme.md：指定值提交readme.md文件 git commit 把暂存区的内容提交到分支（注意：修改的内容需要先add然后再commit） -m &quot;xxx&quot;：提交时需要带上描述信息，说明该次提交了什么，修改了什么。 --amend：弹出文本编辑器，修改最近一次提交的信息 二、时光机穿梭git status 查看仓库当前的状态 git diff 可以查看工作区和版本库里面最新版本的区别 git diff HEAD -- readme.md：查看readme.md文件在工作区与版本库间的区别 git diff --cached：看已经暂存起来的文件和上次提交时的快照之间的差异 git reset 版本回退，也可以把暂存区的修改回退到工作区（意思是把add命令撤销） git使用 HEAD 指定当前版本，HEAD^表示上一个版本，HEAD^^表示上两个版本，HEAD ~100表示上100个版本 （1）版本回退 git reset --hard &lt;commitId&gt;：回退到某个版本，丢弃跟踪文件的任何修改 git reset --soft &lt;commitId&gt;：回退到某个版本，修改的文件记录在暂存区 git reset --mixed &lt;commitId&gt;：回退到某个版本，修改的文件还在工作区，修改记录未add到暂存区 举个例子： 回退到某个版本，但是要保留回退间的所有提交 git reset --hard &lt;commitId&gt;：先回退到你要回退的版本 git reset --soft &lt;commitId&gt;：把修改的文件记录放在暂存区 git commit -m &lt;msg&gt;：提交即可 （2）把缓存区的修改退回工作区 git reset HEAD &lt;file&gt;：把某个文件的修改退回工作区 git checkout 用版本库里的版本替换工作区的版本（可以理解为撤销操作） 让这个文件回到最近一次git commit或git add时的状态 情况一：自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 情况二：已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 git rm 删除文件 该命令相当于使用rm删除一个文件，再git add .了一次 --cache：删除暂存区中的文件跟踪，保留文件 三、远程仓库ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 创建SSH Key 在用户根目录会有.ssh隐藏文件夹，包含id_rsa私钥（不能泄露出去）和id_rsa.pub公钥（可以放心地告诉任何人，把公钥放在github上，有私钥才能提交代码） git remote 查看远程库的信息 -v：显示更详细的信息 git remote add &lt;name&gt; git@github.com:account/repositoryname.git：关联本地仓库与远程仓库 name：指定字符串name对应仓库地址 account：为github账号名 repositoryname：为仓库名 git remote rename &lt;old&gt; &lt;new&gt;：修改远程仓库名字 git remote rm &lt;name&gt;：删除远程仓库 git push 提交代码到远程仓库 git push &lt;repertory&gt; &lt;local&gt;:&lt;remote&gt;：把本地local分支的最新修改推送至repertory的remote分支。 git push &lt;repertory&gt; :&lt;remote&gt;：删除远程分支 git pull 拉取远程仓库代码到本地仓库并合并 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt; git fetch 拉取远程仓库代码到本地仓库，但不合并 git fetch &lt;repertory&gt; &lt;remotebranch&gt;:&lt;localbranch&gt;：拉取远程仓库repertory的remotebranch分支到本地仓库的localbranch分支 git clone 克隆远程仓库到本地 git支持https和ssh协议，使用ssh比较快 git clone https://github.com/Xieweicheng/TestGit.git git clone git@github.com:Xieweicheng/TestGit.git 四、分支管理 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 git branch 查看分支 git branch &lt;name&gt;：创建分支 git branch -d &lt;name&gt;：删除分支 git branch -D &lt;name&gt;：丢弃一个没有被合并过的分支，强制删除 git branch --set-upstream-to=origin/&lt;branch&gt; &lt;branch&gt;：设置&lt;branch&gt;和origin/&lt;branch&gt;的链接 git checkout 切换分支（实际就是改变HEAD的指向） git checkout &lt;name&gt;：切换分支 git checkout -b &lt;name&gt;：创建并切换分支 git checkout -b &lt;name&gt; origin/&lt;name&gt;：创建远程origin的&lt;name&gt;分支到本地 git merge 合并分支 git merge &lt;name&gt;：合并某分支到当前分支 --no-ff：禁用Fast forward（使用Fast forward，删除分支后，会丢掉分支信息。） -m：添加commit描述 git merge --no-ff -m &quot;commit msg&quot; &lt;name&gt;：禁用Fast forward并添加合并信息 --abort：撤销合并 git cherry-pick 合并特定提交 git cherry-pick &lt;name&gt;：合并某分支的最新提交到当前分支 git cherry-pick &lt;commitId1&gt;..&lt;commitId2&gt;：合并commitId1到commitId2之间的所有提交（不包括commitId1） git cherry-pick &lt;commitId1&gt;^..&lt;commitId2&gt;：合并commitId1到commitId2之间的所有提交 git stash 保存本地修改，隐藏工作现场，返回前一次commit状态 git stash apply：恢复本地修改，回到工作现场，但不会删除stash内容 git stash drop：删除stash内容 git stash pop：恢复本地修改，回到工作现场，并删除stash内容 git stash list：查看stash内容 git rebase 可以把本地未push的分叉提交历史整理成直线 --abort：撤销rebase 五、标签管理git tag 查看所有标签 git tag &lt;tagname&gt;：新建一个本地标签，默认指定HEAD，可以指定一个commitId git tag -a &lt;tagname&gt; -m &quot;标签信息&quot;：新建一个本地标签，带上标签信息 git tag -d &lt;tagname&gt;：删除一个本地标签 git show 查看标签信息 git show &lt;tagname&gt;：查看标签信息 git push 提交标签到远程仓库，或删除远程仓库的标签 git push origin &lt;tagname&gt;：提交标签到远程仓库，标签默认只保存在本地仓库 git push origin --tags：提交所有标签到远程仓库 git push origin :refs/tags/&lt;tagname&gt;：删除远程仓库的标签（先删除本地标签） 其他常用命令git log 查看git历史提交日志 --graph ：查看分支合并图 --pretty=oneline：一行显示，只显示哈希值和提交说明 --abbrev-commit：仅显示SHA-1的前几个字符，而非所有的40个字符 git reflog 查看git历史命令日志]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2FDocker%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[一、Docker介绍1、什么是Docker Docket中文官网传送门 Docker是基于Go语言实现的云开源项目，是一个轻量级容器技术。 Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。 运行中的这个镜像称为容器，容器启动是非常快速的。 Build,Ship and Run Any App,Anywhere：一次封装，导出运行。 2、为什么使用Docker 一次开发环境的安装和配置，即可在处处运行。（解决在开发机器上能正常运行，在运维机器上不能运行的情况） 启动快，占用少 轻松维护扩展 3、docker底层原理 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接收命令并管理运行在主机上的容器。容器，是一个运行时环境。 4、虚拟机与Docker的对比 Docker有这比虚拟机更少的抽象层。由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 docker利用的是宿主机的内核，而不是Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，返个新建过程是分钟级别。而docker由于直接利用宿主机的操作系统，则省略了返个过程，因此新建一个docker容器只需要几秒钟。 特性 Docker容器 虚拟机 操作系统 与宿主机共享OS 宿主机OS上运行虚拟机OS 启动 秒级 分钟级 硬盘使用 MB级 GB级 性能 接近原生 操作系统额外的CPU、内存消耗 系统支持量 单机支持上千个容器 一般几十个 二、Docker三要素 Docker三要素：镜像、容器、仓库 1、镜像（image），就是一个只读的模板，可以用于创建Docker容器 2、容器（container） 利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例。 容器可以被启动、开始、停止、删除。每个容器相互隔离。 可以把容器看做一个简易版的Linux系统，包含root用户权限、进程空间、用户空间和网络空间等，和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也就是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 3、仓库（repository） 仓库是几种存放镜像文件的场所 仓库和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库又包含了多个镜像。每个镜像有不同的标签（tag） 仓库分为公开仓库（public）和私有仓库（private）两种形式 最大的公开仓库是Docker Hub 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等。 容器与镜像的关系类似于面向对象编程中的对象和类。 Docker 面向对象 容器 对象 镜像 类 4、概括 Docker本身是一个容器运行载体或称为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看做是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。 image文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器。 仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中 三、Docker安装（社区版，centos7为例） 中文官方文档安装教程 卸载旧版本 1234$ sudo yum remove docker \ docker-common \ docker-selinux \ docker-engine 使用镜像仓库进行安装 1234567# 安装所需的软件包。yum-utils 提供了 yum-config-manager 实用程序，并且 devicemapper 存储驱动需要 device-mapper-persistent-data 和 lvm2。$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 使用下列命令设置 stable 镜像仓库。您始终需要使用 stable 镜像仓库，即使您还需要通过 edge 或 testing 镜像仓库安装构建也是如此。# download.docker.com 可换为 mirrors.aliyun.com$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装Docker-CE 123456# 更新 yum 软件包索引。$ sudo yum makecache fast# 安装最新版的docker-ce$ sudo yum install docker-ce# 若需要安装指定版本的docker-ce$ sudo yum install docker-ce-&lt;VERSION&gt; 启动Docker 1$ sudo systemctl start docker 四、使用阿里云镜像加速 为什么要使用阿里云镜像加速？是因为我国伟大的防火墙导致访问国外网站慢或者无法访问，这时我们就需要访问阿里云所同步的镜像 1、注册阿里云账号2、进入容器镜像服务 3、获取加速地址 4、配置镜像加速地址123456789101112# 安装docker后默认是没有`daemon.json`文件的，需要用root权限创建$ sudo vim /etc/docker/daemon.json# 修改文件内容如下，后面参数填上一步所复制的阿里云加速器地址&#123; "registry-mirrors": ["https://lolololo.mirror.aliyuncs.com"]&#125;# 重新加载daemon$ sudo systemctl daemon-reload# 重新启动docker$ sudo systemctl restart docker# 查看docker信息$ sudo docker info 使用docker info 查看docker信息，查看Registry Mirrors内容为阿里云加速器地址则说明设置成功。 5、执行HelloWorld12# 运行hello-world镜像，若本地没有，则会自动从云端pull，并执行，云端没有显示没有该镜像。$ sudo docker run hello-world 五、Docker命令（1）帮助命令1、docker version 查看docker版本信息 2、docker info 查看docker信息 3、docker --help 查看docker常用命令 （2）镜像命令1、docker images 列出本机上的镜像 docker images -a：列出所有镜像层 docker images -q：只显示镜像id docker images –digests：显示镜像摘要信息 docker images –no-trunc：不截取镜像id 2、docker search 查询镜像 docker search -s 30 tomcat：查询star数大于30K的tomcat 3、docker pull 下载镜像（默认下载lastest） 4、docker rmi 删除镜像（默认删除lastest） docker rmi -f hello-world：强制删除镜像 docker rmi -f $(docker images -qa)：强制删除所有镜像 5、docker commit 根据容器创建镜像 docker commit -a &quot;author&quot; -m &quot;Description information&quot; &lt;containerId&gt; &lt;schema&gt;/&lt;imageName&gt;:tag 举个例子： docker commit -a &quot;MrXieXie&quot; -m &quot;MyTomcat&quot; tomcat88 mrxiexie/tomcat:1.0 根据tomcat88容器创建一个名为mrxiexie/tomcat标签为1.0的镜像 （3）容器命令1、docker run image 新建并启动容器 –name=“容器新名字”：为容器指定一个名称 -d：后台 -i：以交互模式运行容器，通常与 -t 同时使用 -t：以容器重新分配一个伪输入终端，通常与 -i 同时使用 -P：随机端口映射 -p：指定端口映射，以下四种模式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 举个例子： docker run -it centos –name centos 以centos镜像为模板，创建一个名为centos的容器，并使用伪终端与容器交互。 docker run -d centos /bin/bash -c &quot;while true;do echo hello;sleep 2;done&quot; 以后台形式启动centos，并执行脚本。（若不执行脚本，该容器会启动后马上退出，由于该容器没有任务） 2、docker ps 列出所有正在运行的容器 -a：列出所有容器 -l：上一次运行的 -n 3：上三次运行的 -q：静默模式，只显示容器id 3、退出容器 exit：关闭容器后退出回宿主机 ctrl + p + q：退出容器到宿主机 4、docker start containerId(name) 启动容器 5、docker restart containerId(name) 重启容器 6、docker stop containerId(name) 停止容器 7、docker kill containerId(name) 强制关闭容器 8、docker rm containId(name) 删除已关闭容器 -f：强制删除 docker rm -f $(docker ps -aq)：删除所有容器 docker ps -aq | xargs docker rm：删除所有容器 9、docker logs 查看容器日志 -t：显示时间戳 -f：不断追加最新日志 –tail 3：显示尾部 3行 举个例子： docker logs -tf --tail 3 containerId(name) 查看该容器后三行的日志 10、docker top containerId(name) 查看容器进程 11、docker inspect containerId(name) 查看容器内部细节 12、docker attach containerId(name) 重新进入容器命令的终端，不会启动新的进程 13、docker exec 是在容器中打开新的终端，并且可以启动新的进程。 docker exec -it 容器id bashShell：不进入容器命令的终端，执行完bashShell返回结果给宿主终端。 14、docker cp containerId(name) 复制文件到宿主机 docker cp 容器ID:容器内路径 目的主机路径 六、镜像原理 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 （1）UnionFS（联合文件系统）Union文件系统是一种分层、轻量级并且好性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 （2）Docker镜像加载原理Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFs。 1、bootfsbootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们经典的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs 2、rootfsrootfs（root file system），在bootfs之上，包含的就是典型的Linux系统的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行。由此可见对于不同的linux发行版，bootfs基本一致，rootfs会有差别，因此不同的发现版可以公用bootfs 3、分层的镜像镜像是一层套一层，kernel&gt;centos&gt;java&gt;tomcat….. 4、为什么使用分层结构最大的好处是共享资源 比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 七、Docker容器数据卷 将应用于运行的环境打包形成容器运行，我们希望对数据进行持久化，并且希望容器之间能够实现数据共享 Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然就没有了 为了保存数据，在docker中使用数据卷 （1）数据卷 容器的持久化 容器间继承和共享数据 数据卷的生命周期一直持续到没有容器使用它为止 （2）添加数据卷添加数据卷的两种方法，使用直接命令和使用DockerFile 1、直接命令docker run -it -v /宿主机目录:/容器内目录 &lt;imageId&gt; docker run -it -v /宿主机目录:/容器内目录:ro &lt;imageId&gt; 2、DockerFile由于可移植和分享的考虑：用-v主机目录：容器目录这种方法不能够直接在Dockerfile中实现 由于宿主机目录是依赖于特定宿主机的，并不能保证在所有的宿主机上都存在这样的特定目录。 创建DockerFile，并编写如下 1234FROM centosVOLUME ["/container1","/container2"]CMD echo "finished!!"CMD /bin/bash 使用docker build构建出新的镜像，注意：最后面有个. 1$ docker build -f /mydocker/Dockerfile -t mrxiexie/centos . 使用docker inspect &lt;containerId&gt;查看默认挂载的目录，类似如下目录 1/var/lib/docker/volumes/58ae629198c1b06d60d0a2a451a8eb76330c0171982f80f60897f745ec65e7c0/_data （3）数据卷容器命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。 1$ docker run -it --name &lt;name1&gt; --volumes-from &lt;name2&gt; &lt;image&gt; 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止 八、DockerFile解析（1）DockerFile是什么DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 构建三步骤 编写DockerFile文件 docker build docker run （2）DockerFile构建过程解析1、Docker内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 2、Docker执行DockerFile的大致流程 Docker从基础镜像运行一个容器 执行一条指令并对容器作出修改 执行类似docker commit的操作提交一个新的镜像层 docker再基于刚提交的镜像运行一个新容器 执行dockerfile的下一条指令直到所有指令都执行完成 123456789101112131415$ docker build -f DockerFile -t mrxiexie/centos .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 75835a67d134Step 2/4 : VOLUME ["/container1","container2"] ---&gt; Using cache ---&gt; 572b4737c362Step 3/4 : CMD echo "finish!!" ---&gt; Using cache ---&gt; 800fe2b84793Step 4/4 : CMD /bin/bash ---&gt; Using cache ---&gt; f491cc1b1e35Successfully built f491cc1b1e35Successfully tagged mrxiexie/centos:latest 从应用软件的角度来看：Dockerfile、Docker镜像和Docker容器分别代表软件的三个不同阶段。 DockerFile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态 Dockerfile面向开发，Docker镜像称为交付标准，Docker容器则涉及部署和运维，三者缺一不可，合力充当Docker体系的基石。 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等。 Docker镜像，在用Dockerfile定义一个文件后，docker build时会产生一个Docker镜像，当运行Docker镜像时，会直接开始提供服务。 Docker容器，容器是直接提供服务的。 （3）DockerFile保留字指令1、FROM基础镜像，当前新镜像是基于哪个镜像的 2、MAINTAINER镜像维护者的姓名和邮箱地址 3、RUN容器构建时需要运行的命令 4、EXPOSE当前容器对外暴露出的端口 5、WORKDIR指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 6、ENV用来构建镜像过程中设置环境变量 环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样，也可以在其他指令中直接使用这些环境变量。 12ENV MY_PATH /usr/mytestWORKDIR $MY_PATH 7、ADD将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 8、COPY类似ADD，拷贝文件和目录到镜像中 将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置 12COPY src destCOPY ["src","dest"] 9、VOLUME容器数据卷，用于数据保存和持久化工作 10、CMD指定一个容器启动时要运行的命令 Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换 11、ENTRYPOINT指定一个容器启动时要运行的命令 ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数 12、ONBUILD当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发 （4）案例 Base镜像（scratch）：DockerHub中百分之99的镜像都是通过base镜像中安装和配置需要的软件构建出来的 1、自定义Centos镜像需求： 环境变量MYPATH为/tmp 落脚点在：/tmp 自带vim及ifconfig命令 在mydocker/centos/下编写DockerFile 1234567FROM centosENV MYPATH /tmpWORKDIR $MYPATHRUN yum install -y vimRUN yum install -y net-toolsEXPOSE 80CMD /bin/bash 构建镜像 1$ docker build -f /mydocker/centos/DockerFile -t mrxiexie/mycentos:1.0 . 2、编写查看ip的镜像需求： 运行镜像可以看到当前ip地址 可以带参数 在mydocker/ip/下编写DockerFile 12345FROM centosRUN yum install -y curl# 不能使用CMD，因为运行时追加参数会替代上一个CMD命令。# 使用ENTRYPOINT，会把追加参数放在命令中。ENTRYPOINT ["curl", "-s", "https://ip.cn"] 构建镜像 1$ docker build -f /mydocker/ip/DockerFile -t mrxiexie/ip:1.0 . 运行镜像带请求头 1$ docker run mrxiexie/ip:1.0 -i 3、编写一个让子镜像执行后会触发命令的父镜像父镜像DockerFile： 123FROM centosCMD echo "parent"ONBUILD RUN echo "我有一个子镜像创建了" 创建父镜像 1$ docker build -f /mydocker/onbuild/ParentDockerFile -t mrxiexie/parent . 子镜像DockerFile： 12FROM mrxiexie/parentCMD echo "child" 创建子镜像 12345678910111213141516171819$ docker build -f /mydocker/onbuild/ChildDockerFile -t mrxiexie/child .# 创建日志如下：Step 1/3 : FROM mrxiexie/parent# Executing 1 build trigger ---&gt; Running in b23f935ff9eb我有一个子镜像创建了Removing intermediate container b23f935ff9eb ---&gt; 539080c42b1eStep 2/3 : RUN echo "Child" ---&gt; Running in 16e027c94730ChildRemoving intermediate container 16e027c94730 ---&gt; 835ec69c4d0bStep 3/3 : CMD echo "Child" ---&gt; Running in ea1b7dbfc27dRemoving intermediate container ea1b7dbfc27d ---&gt; 83fe9d29db55Successfully built 83fe9d29db55Successfully tagged mrxiexie/child:latest 4、部署web应用 官网下载tomcat与java 配置环境变量 123456789101112131415161718192021222324FROM centos# 邮箱姓名MAINTAINER mrxiexie@qq.com# 设置工作路径为环境变量ENV WORK_DIR /usr/local# 设置落脚点WORKDIR $WORK_DIR# 复制test.txt到容器，并修改名字为container.txtCOPY test.txt /usr/local/container.txt# 解压并复制ADD jdk-8u191-linux-x64.tar.gz $WORK_DIRADD apache-tomcat-9.0.13.tar.gz $WORK_DIR# 安装vimRUN yum install -y vim# 设置java和tomcat环境ENV JAVA_HOME $WORK_DIR/jdk1.8.0_191ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME $WORK_DIR/apache-tomcat-9.0.13ENV CATALINA_BASE $WORK_DIR/apache-tomcat-9.0.13ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin# 暴露8080端口EXPOSE 8080# 启动tomcatCMD ["/usr/local/apache-tomcat-9.0.13/bin/catalina.sh", "run"] 创建镜像 1$ docker build -f /mydocker/tomcat/Dockerfile -t mrxiexie/tomcat . 启动镜像，并设置挂载点 1234$ docker run -d -p 8080:8080 --name tomcat \-v /mydocker/tomcat/test:/usr/local/apache-tomcat-9.0.13/webapps/test \-v /mydocker/tomcat/logs:/usr/local/apache-tomcat-9.0.13/logs \--privileged=true mrxiexie/tomcat 创建/mydocker/tomcat/test/a.jsp，内容如下： 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%="Hello Docker!"%&gt; &lt;% System.out.println("Hello Docker");%&gt; &lt;/body&gt;&lt;/html&gt; 创建/mydocker/tomcat/MET_INF/web.xml 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; 在浏览器中，输入http://localhost:8080/test/a.jsp正常访问，说明配置成功 九、将镜像推送到阿里云（1）登录到阿里云镜像管理登录阿里云，传送门，点击创建我的容器镜像 （2）创建镜像仓库 创建命名空间，然后填写对应镜像信息，点击下一步。 选择本地仓库，创建镜像仓库 （3）上传镜像到阿里云仓库镜像仓库中，选择对应的仓库，点击管理 根据第三步，推送对应的镜像到仓库 （4）下拉镜像到本地根据第二步，下拉对应的镜像到本地]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logback中文文档]]></title>
    <url>%2FLogback%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[一、Logback中文文档下载logback.pdf 二、常用配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0"?&gt;&lt;configuration&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;[%level] %d&#123;YYYY-MM-dd HH:mm:ss.SSS&#125; [%thread] %logger&#123;36&#125; : %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;file&gt;/sdcard/log/log.log&lt;/file&gt; &lt;!--&lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt;--&gt; &lt;!--&lt;fileNamePattern&gt;log.%i.log&lt;/fileNamePattern&gt;--&gt; &lt;!--&lt;minIndex&gt;1&lt;/minIndex&gt;--&gt; &lt;!--&lt;maxIndex&gt;3&lt;/maxIndex&gt;--&gt; &lt;!--&lt;/rollingPolicy&gt;--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;FileNamePattern&gt;/sdcard/log/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;!-- or whenever the file size reaches 1MB --&gt; &lt;maxFileSize&gt;1M&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;MaxFileSize&gt;2MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- 日志级别 --&gt; &lt;root&gt; &lt;level value="error" /&gt; &lt;level value="warn"/&gt; &lt;level value="info" /&gt; &lt;level value="debug" /&gt; &lt;level value="trace" /&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="FILE" /&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中配置Lombok和Logback]]></title>
    <url>%2FAndroid%E4%B8%AD%E4%BD%BF%E7%94%A8Lombok%E5%92%8CLogback.html</url>
    <content type="text"><![CDATA[一、安装Lombok插件之前有写过安装插件的教程，虽然是基于IDEA的，但是AS就是IDEA的儿子，照搬就行~传送门在此 二、Gradle修改如下1234567891011121314android &#123; defaultConfig &#123; //... javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath = true &#125; &#125; &#125; //...&#125;dependencies &#123; //... compileOnly group: 'org.projectlombok', name: 'lombok', version: '1.16.18' implementation 'org.glassfish:javax.annotation:10.0-b28' implementation 'ch.qos.logback:logback-classic:1.2.3'&#125; 三、项目根目录添加lombok.config文件 修改文件内容如下 1lombok.anyConstructor.suppressConstructorProperties=true 四、创建logback配置文件在raw目录下 文件名想怎么起就怎么起~ 五、启动时识别logback配置文件 要想直接通过注解@Slf4j打印日志是已经ok了~ 但要logback还是默认的配置，只需要在Application中调用下面方法，就能用到R.raw.app_log_config里面的配置了~ 1234567891011private void setLogger() &#123; LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); JoranConfigurator joranConfigurator = new JoranConfigurator(); joranConfigurator.setContext(loggerContext); loggerContext.reset(); try &#123; joranConfigurator.doConfigure(getResources().openRawResource(R.raw.app_log_config)); &#125; catch (JoranException e) &#123; e.printStackTrace(); &#125;&#125; 参考链接]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Lombok</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android简单实现抽奖转盘]]></title>
    <url>%2FAndroid%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E8%BD%AC%E7%9B%98.html</url>
    <content type="text"><![CDATA[前言 本来说过不再搞安卓的，可是公司突然要把原本用H5开发的界面全部转为Android，迫不得已又要去开发Android，在抽奖转盘上花了点时间，自定义View这块都忘得差不多了。 一、如何绘制 可以查看鸿洋大神的博客或者直接看慕课网的视频 我是直接看着慕课网的视频码出来的。只是做了一个简单的封装。 二、Demo演示 三、使用gradle依赖到项目中step1：将其添加到存储库末尾的根build.gradle（app模块）中： 123456allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125; step2：添加依赖项 123dependencies &#123; implementation &apos;com.github.Xieweicheng:luckypan:Tag&apos; &#125; 最新Tag请查阅Release 四、使用教程 在布局文件，加入如下布局即可 1234&lt;pers.mrxiexie.luckypan.LuckyPanSerfaceView android:id="@+id/luckypanview" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; 设置转盘参数方法 方法名 参数类型 说明 setBackground int 设置背景（背景最好是正方形！！） setCenterBtn int 设置中间点击按钮 setColors List&lt;Integer&gt; 设置盘块颜色列表 setIcons List&lt;Integer&gt; 设置奖项icon setPadding int 设置绘制转盘的内边距 setPrizes List&lt;String&gt; 设置奖品文字 setRealistic boolean 设置是否真实（真实则随机在需要中奖的盘块的任意位置，而非盘块正中间） setTextColor int 设置字体颜色 setTextSize int 设置字体大小，单位为px 获取转盘状态方法 方法名 返回值 说明 isShouldEnd boolean 转盘是否应该停止 isStart boolean 转盘是否在旋转 设置转盘状态 方法名 参数类型 说明 luckyStart int 开始旋转，传入需要中奖的奖项索引，索引为setPrizes所传入列表的索引 luckyStop null 结束旋转，该方法不是立即停止转盘，需要一段时间才会停止 设置监听 方法名 说明 setOnLuckyCenterClickListener 设置转盘中间按钮点击事件监听 setOnLuckyStopListener 设置转盘完全停止监听 五、举个例子12345678luckyPanSerfaceView.setColors(colors) .setIcons(icons) .setPrizes(prizes) .setPadding(140) .setBackground(R.drawable.center) .setCenterBtn(R.drawable.pointer) .setOnLuckyStopListener(this) .setOnLuckyCenterClickListener(this); 六、即将更新 自定义中心按钮大小 添加主题（文字与icon的位置更多选择）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程]]></title>
    <url>%2FShell%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、Shell是什么 Shell是一个命令行解析器，它为用户提供一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell启动、挂起、停止甚至是编写一些程序。 二、HelloWorld 脚本以 #!/bin/bash 开头 创建一个Shell脚本，输出HelloWorld！ 新建helloworld.sh，编写内容如下 12#!/bin/bashecho "HelloWorld!" 给用户添加执行权限 chmod u+x helloworld.sh 使用 ./helloworld.sh 执行脚本 （如果不添加权限，可以使用 su ./helloworld.sh 执行脚本） 三、Shell变量 变量分为系统变量和用户自定义变量 （1）系统变量 使用 echo $PATH 输出系统变量 （2）用户自定义变量 变量名=值：MYNUM=1 unset 变量名：撤销变量 readonly 变量名=值：声明静态变量 echo $变量名：输出变量 注意事项 变量不能以数字开头 等号左右不能用空格 变量名一般建议大写 （3）将命令返回值赋值给变量 变量名=`cal`：使用反引号，将cal的结果赋值给变量 变量$(ls -la)：等价于反引号 四、设置环境变量 export 变量名=变量值：将shell变量输出为环境变量 source 配置文件：让修改后的配置信息立即生效 echo $变量名：查询环境变量 栗子：为tomcat添加环境变量 123456789# 修改/etc/profilevim /etc/profile# 输入 G 跳转到底部# 添加如下语句TOMCAT_HOME=/opt/tomcatexport TOMCAT_HOME# 修改后wq保存即可# 让修改后的配置文件生效source /ect/profile 五、注释 #：单行注释（ #echo &quot;helloworld&quot;） :&lt;&lt;! 内容 !：多行注释（:&lt;&lt;! echo &quot;helloworld !&quot;） 六、位置参数变量 $n：n为数字，$0为命令本身，$1-$9代表第一到第九个参数，十以上的参数，使用${10} $*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体 $@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待 $#：这个变量代表命令行中所有参数的个数 七、预定义变量 shell设计者事先已经定义好的变量，可以在shell脚本中直接使用 $$：当前进程号的PID $!：后台运行的最后一个进程的进程号PID $?：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行。 八、运算符 $((运算符)) $[运算符] expr m + n expr m - n expr \*,/,% 注意事项：使用expr运算符间要有空格 九、条件判断 [ condition ]：condition前后要有空格，可以使用 $? 校验（0为true） 栗子：命令行输入两个数字判断前一个数字是否大于后一个数字，若大于输出0 123#!/bin/bash[ $1 -gt $2 ]echo "$?" （1）常用的判断条件1、两个整数的比较 =：字符串比较 -lt：小于 -le：小于等于 -eq：等于 -gt：大于 -ge：大于等于 -ne：不等于 2、按照文件权限进行判断 -r 有读的权限 [ -r 文件 ] -w：有写的权限 -x：有执行的权限 3、按照文件类型进行判断 -f：文件存在并且是一个常规的文件 -e：文件存在 -d：文件存在并是一个目录 栗子： 123[ "ok" == "ok" ] #判断是否相等[ 23 -gt 22 ] #23是否大于22[ -e /root/shell/aaa.txt ] #判断目录中的文件是否存在 十、流程控制（1）if语句基本语法： 1234567891011121314# 第一种写法if [ condition ];then 程序fi# 第二种写法（推荐使用）if [ condition ]then 程序elif [ condition ]then 程序else 程序fi 栗子：如果输入参数大于等于60，则输出”及格“，否则输出”不及格“ 1234567#!/bin/bashif [ $1 -ge 60 ]then echo "及格了"else echo "不及格"fi （2）case语句基本语法： 1234567891011case $变量名 in"值1") 如果为值1执行程序 ;;"值2") 如果为值2执行程序 ;;*) 如果都不是则执行程序 ;;esac 栗子：当命令行参数是1时，输出“周一”，是2时，输出“周二”，其他情况输出“other” 123456789101112#!/bin/bash case $1 in "1") echo "周一" ;; "2") echo "周二" ;; *) echo "other" ;; esac （3）for循环基本语法： 1234for 变量 in 值1 值2 值3...do 程序done 栗子：打印命令行输入的参数 12345#!/bin/bash for i in $* do echo "$i" done （4）while循环基本语法： 1234while [ condition ]do 程序done 栗子：从命令行输入一个数n，统计从1 + .. + n 的值是多少？ 123456789#!/bin/bashi=0SUM=0while [ $i -le $1 ]do SUM=$[$SUM+$i] i=$[$i+1]doneecho "sum=$SUM" （5）read控制控制台输入基本语法： read (选项) (参数) -p：指定读取值时的提示符 -t：指定读取值等待的时间（秒），如果没有在指定的时间输入，就不再等待。 栗子：读取控制台的一个值，10s内输入 123#!/bin/bashread -p "请在10s内输入一个数字" -t 10 NUMecho “输入的数字为$NUM” 十一、函数（1）系统函数 basename [pathname][suffix]：返回完整路径最后 / 的部分，常用语获取文件名，若指定了suffix 会把后缀一起删除 dirname [pathname]：返回完整路径最后 / 的前面的部分，常用于返回路径的部分 （2）自定义函数基本语法： 1234[ function ] functionname[()]&#123; Action; [return int;]&#125; 调用时直接写函数名：functionname [值] 栗子：计算输入两个参数的和（read） 12345678#!/bin/bashfunction getSum()&#123; SUM=$[$n1+$n2] echo "和是=$SUM"&#125;read -p "请输入第一个数n1" n1read -p "请输入第二个数n2" n2getSum n1 n2 十二、Shell编程综合案例需求： 每天凌晨2：10备份数据库 mytest 到 /data/backup/db 备份开始和备份结束能够给出响应的提示信息 备份后的文件要求以备份时间为文件名，并打包为 .tar.gz 的形式，比如 2018-10-10.tar.gz 在备份的同时，检查是否有10天前的备份的数据库文件，如果有就将其删除。 1234567891011121314151617181920212223242526272829BACKUP="/data/backup/db"DATETIME=$(date +%Y-%m-%d)echo "开始备份！"echo "备份路径为 $BACKUP/$&#123;DATETIME&#125;.tar.gz"#主机HOST=localhost#用户名USER=root#密码PWD=root#数据库名DATABASE=mytest#创建备份的路径#如果备份的路径文件夹存在，就使用，否则就创建[ ! -d "$BACKUP/$DATETIME" ] &amp;&amp; mkdir -p "$BACKUP/$DATETIME"#执行mysql的备份数据库的指令#使用docker# MYSQL=mysql# sudo docker exec mysql sh -c 'exec mysqldump -u'$USER' -p'$PWD' '$DATABASE'' | gzip &gt; $BACKUP/$DATETIME/$&#123;DATETIME&#125;.sql.gzmysqldump -u$USER -p$PWD --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME/$&#123;DATETIME&#125;.sql.gz#打包备份文件cd $BACKUPtar -zcvf $DATETIME.tar.gz $DATETIME#删除临时目录rm -rf $BACKUP/$DATETIME#删除10天前的备份文件find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -rf &#123;&#125; \;echo "备份文件成功" 最后使用任务调度 110 2 * * * /usr/sbin/mysql_db_backup.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux包管理]]></title>
    <url>%2FLinux%E5%8C%85%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[一、RPM（1）介绍 一种用于互联网下载包的打包和安装工具，它包含了某些Linux分发版中。它生成具有 .RPM 扩展名的文件。RPM是 RedHat Package Manager（RedHat软件包管理工具），类似Window的 setup.exe。 （2）常用指令 rpm -qa | grep xx：简单查询 rpm -q 软件包名：查询软件包是否安装 rpm -qi 软件包名 ：查询软件包信息 rpm -ql 软件包名：查询软件包中的文件 rpm -qf 文件全路径 ：查询文件所属的软件包 rpm -e RPM 包的名称 ：卸载rpm包 rpm -e --nodeps RPM 包的名称：强制删除 rpm -ivh RPM 包全路径名称：安装rpm包（i=install 安装，v=verbose 提示，h=hash 进度条） 二、YUM（1）介绍 YUM是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有的依赖包。使用YUM的前提是可以联网。 （2）常用指令 yum list | grep xx：查询软件包列表 yum install xxx：下载安装 yum remove xxx：删除 三、APT（1）介绍apt是Advanced Packaging Tool简称，是一款安装包管理工具。在Ubuntu下，可以使用apt命令用于软件包的安装、删除、清理等。 （2）常用指令 apt-get update 更新源 apt-get install package 安装包 apt-get remove package 删除包 apt-cache search package 搜索软件包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 apt-get install package –reinstall 重新安装包 apt-get -f install 修复安装 apt-get remove package –purge 删除包，包括配置文件等 apt-get build-dep package 安装相关的编译环境 apt-get upgrade 更新已安装的包 apt-get dist-upgrade 升级系统 apt-cache depends package 了解使用该包依赖那些包 apt-cache rdepends package 查看该包被哪些包依赖 apt-get source package 下载该包的源代码 （3）更新源地址 清华大学开源软件镜像站 寻找ubuntu镜像 选择对应的ubuntu版本，并复制下面所有内容 备份原文件 1cp /etc/apt/sources.list /etc/apt/sources.list.backup 把刚复制的内容覆盖sources.list 更新源 apt-get update即可]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理]]></title>
    <url>%2FLinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[一、进程的基本介绍 Linux中，每个执行的程序都会称为一个进程。都会分配一个ID号。 每个进程，都会对应一个父进程，而父进程可以有多个子进程。 每个进程都有前后台之分。前台可以理解为界面可见，后台为不可见。 一般系统的服务都是以后台进程的方式存在，而且常驻在系统中。直到关机结束。 二、常用指令（1）显示系统执行的进程 ps -a：显示当前终端的所有进程信息 -u：以用户的格式显示进程信息 -x：显示后台进程运行的参数 -e：显示所有进程 -f：全格式 常用指令：ps -aux | grep xxx 12USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 19340 1548 ? Ss 09:18 0:00 /sbin/init 指令说明： USER：用户名 PID：进程号 %CPU：进程占用CPU的百分比 %MEM：进程占用物理内存的百分比 VSZ：进程占用的虚拟内存大小（KB） RSS：进程占用的物理内存大小（KB） TT：终端名称 STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在进行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等。 STARTED：进程的启动时间 TIME：CPU时间，即进程使用CPU的总时间 COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 常用指令：ps -ef | more 12UID PID PPID C STIME TTY TIME CMDroot 1 0 0 09:18 ? 00:00:00 /sbin/init 指令说明： UID：用户ID PID：进程ID PPID：父进程ID C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：完整的终端名称 TIME：CPU时间 CMD：启动进程所用的命令和参数 （2）终止进程 kill killall kill PID ：按照pid杀死进程 killall 进程名称：按照名称杀死进程 -9：表示强制停止进程 （3）查看进程树 pstree -p：显示进程的PID -u：显示进程的所属用户 （4）设置服务各个运行级别设置启动或关闭 查看服务：chkconfig --list | grep xxx chkconfig 服务名 --list chkconfig --level 5 服务名 on/off：将某服务在运行级别为5下启动或者不启动 （5）动态监控进程 top [选项] 选项说明： -d 秒数：指定top指令每个几秒更新。默认是3秒在top指令的交互模式中可以执行的指令 -i：是top不显示任何闲置或者僵死进程 -p：通过指定监控进程ID来仅仅监控某个进程的状态 交互操作说明 P：以CPU使用率排序，默认就是此项 M：以内存的使用率排序 N：以PID排序 q：退出 （6）查看系统网络情况 netstat -anp -an：按一定顺序排列输出 -p：显示哪个进程在调用 三、服务管理 service 服务名 [start | stop | restart | reload | status] centos7.0后，不再使用 service，而是使用 systemctl （1）防火墙 查看防火墙状态：service iptables status 关闭防火墙：service iptables stop 启动防火墙：service iptables start window下可以使用 talnet 命令测试某个端口是否外放 12# 查看ip为192.168.164.130的22端口是否外放telnet 192.168.164.130 22 （2）查看服务名 使用setup -&gt; 系统服务 ls -l /etc/init.d/ ：列出系统有哪些服务 （3）Linux开机流程 开机 &gt; BIOS &gt; /boot &gt; init 进程1 &gt; 运行界别 &gt; 运行级别对应的服务]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络配置]]></title>
    <url>%2FLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[一、常用指令1、ping 测试当前系统是否能够连接到某ip 栗子：ping www.baidu.com 2、ifconfig 查看网卡信息 3、service network start：启动网络 stop：停止网络 restart：重启网络 二、开机自动联网、自定义IP 自定义ip地址，需要编辑 /ect/sysconfig/network-scripts/ifcfg-eth0 文件 1234567891011vim `/ect/sysconfig/network-scripts/ifcfg-eth0`# 开机启动网络ONBOOT=yes # 静态方式获取ipBOOTPROTO=static# 指定ipIPADDR=192.168.184.130# 指定网关GATEWAY=192.168.184.2# 指定NDS服务器（与网关一致即可）DNS1=192.168.184.2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘分区和挂载]]></title>
    <url>%2FLinux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD.html</url>
    <content type="text"><![CDATA[一、分区的方式（1）mbr分区 最多支持四个主分区 系统只能安装在主分区 扩展分区需要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性 （2）gtp分区 支持无限多个主分区（但操作系统可能限制，比如window下最多128个分区） 最大支持18EB的大容量（1EB = 1024PB，1PB = 1024TB） window7 64位以后支持gtp 二、Linux分区（1）分区原理 Linux来说无论有多少个分区，分给哪一个目录，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux的每个分区都是用来组成整个文件系统的一部分。 Linux采用了一种 “载入” 的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。 （2）硬盘说明 Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本都是SCSI硬盘 对于IDE硬盘，驱动器标识符为 hdx~，其中 hd 表明分区所在设备的类型，指的是IDE硬盘。x 表示盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），~ 代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。 对于SCSI硬盘则标识为 sdx~，跟IDE标识方法一致。 三、分区常用指令1、lsblk 查看当前系统的分区情况 lsblk -f ： 查看系统的分区和挂载的情况 2、fdisk 分区 栗子：fdisk /dev/sdb m：显示命令列表 p：显示磁盘分区 n：新增分区 d：删除分区 w：写入并保存 3、mkfs 格式化 栗子：mkfs -t ext4 /dev/sdb1 4、mount 挂载 栗子：mount /dev/sdb1 /home/newdisk 5、umount 卸载 栗子：umount /dev/sdb1 或 umount /home/newdisk 6、df 查询系统整体磁盘使用情况 df -lh 7、du 查询指定目录的磁盘占用情况 du -h /目录 -s：指定目录占用大小汇总 -h：带计量单位 -a：含文件 –max-depth=1：子目录深度 四、分区步骤 分区 fdisk /dev/sda 格式化 mkfs -t ext4 /dev/sda1 挂载 先创建需要挂载的目录，例如 /home/asd，挂载 mount /dev/sda1 /home/asd 设置可以自动挂载（永久挂载） 12vim /etc/fstab/dev/sda1 /home/asd ext4 defaults 0 0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux任务调度之crond]]></title>
    <url>%2FLinux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B9%8Bcrond.html</url>
    <content type="text"><![CDATA[一、简单介绍任务调度 任务调度：是指在某个时间执行的特定的命令或程序。 任务调度分类： 1、系统工作，有些重要的工作必须周而复始地执行。如病毒扫描等。 2、个别用户工作，个别用户可能希望执行某些程序，比如对mysql数据库的备份。 二、基本语法 crontab [选项] 常用选项： 选项 说明 -e 编辑crontab定时任务 -l 查询crontab任务 -r 删除当前用户所有crontab任务 三、简单例子 以下例子是将命令 cal 的输出结果每隔一分钟输出到 /home/1.txt 文件中 12345678# 编辑定时任务crontab -e# 输入 i 进入插入模式i# 输入如下命令*/1 * * * * cal &gt;&gt; /home/1.txt# 按 esc 键，然后 :wq 保存退出:wq 当然也可以把命令放在 sh 文件中 如下为/home/1.sh文件内容： 1cal &gt;&gt; /home/1.txt 此时 crontab 内容为： 1*/1 * * * * /home/1.sh 四、参数细节说明 5个占位符说明 项目 含义 范围 第一个“*” 一小时中的第几分钟 0-59 第二个“*” 一天当中的第几个小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的第几月 1-12 第五个“*” 一周当中的星期几 0-7（0和7都是星期日） 特殊符号说明 特殊符号 含义 * 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思 , 代表不连续的时间，比如“0 8,12,16 * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 - 代表连续的时间范围。比如”0 5 * 1-6命令“，就代表在周一到周六的凌晨5点0分执行命令 */n 代表每隔多久执行一次。比如“/10 * 命令”，代表每10分钟就执行一遍命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、Vi &amp; Vim（1）vi 和 vim 的基本介绍 所有Linux系统都会内建 vi文本编辑器 Vim具有程序编程能力，可以看做 vi增强版 （2）vi 和 vim 的三种模式1、正常模式 使用命令后的模式就处于正常模式 该模式下可以使用快捷键。 2、插入模式/编辑模式 该模式，可以输入内容 按下 i、I、o、O、a、A、R等任何一个字母后切入该模式，一般来说按 i 即可 3、命令行模式 在该模式，可以使用相关指令完成读取、存盘、替换、离开vim、显示行号等行为。 4、三种模式的相互转换图 （3）常用指令 拷贝当前行 yy，拷贝当前行向下5行，5yy，使用 p 粘贴 删除当前行 dd，删除当前行向下5行，5dd。 查找某个单词【命令行下： /关键字】，回车查找，n查找下一个。 设置行号，取消行号。【命令行下：:set nu 和 :set nonu】 快速跳转文件头gg和文件尾G 撤销 u 跳转到20行，先输入 20，然后快捷键 shift + g 二、开机、重启和用户登录注销1、shutdown shutdown -h now：立即关机 shutdown -h -l：1分钟后关机 shutdown -r now：立即重启 2、halt 关机 3、reboot 重启 4、syn 把内存数据同步到磁盘（建议关机前执行） 5、su 用户名 切换用户 6、logout 注销用户 三、用户管理（1）常用指令1、useradd [选项] 用户名 添加用户 useradd -g 用户组 用户名：添加用户到某个组 2、passwd 用户名 修改密码 3、userdel 用户名 删除用户 4、id 用户名 查询用户信息 5、groupadd 组名 添加用户组 6、groupdel 组名 删除用户组 7、usermod -g 用户组 用户名 修改用户组 （2）有关用户的配置文件1、/etc/passwd 文件 用户的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识符:组标识符:注释性描述:主目录:登录Shell 2、/etc/shadow 文件 口令配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 3、/etc/group 文件 组的配置文件，记录Linux包含的组的信息 每行的含义：组名:口令:组标志号:组内用户列表 四、实用命令（1）Linux运行级别 0：关机 1：单用户模式 （可在该模式下修改root密码） 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用为 3 和 5，要修改默认的运行级别可以修改 /etc/inittab 的 id:5:initdefault 这一行中的数字 （2）找回密码 开机 -&gt; 引导时输入 回车键 -&gt; 看到界面输入 e -&gt; 看到一个新的界面，选中编辑内核然后输入 e -&gt; 行尾输入 空格 1 回车 -&gt; 再次输入 b 进入单用户模式 -&gt; 使用passwd修改root密码 （3）常用命令1、man 指令或配置文件 帮助指令，获得帮助信息 2、help 指令 获得shell内置命令的帮助信息 3、pwd 查看当前目录 4、ls 查看当前目录文件 -a：显示隐藏文件 -l：列表方式显示信息 5、cd 切换目录 6、mkdir 创建目录 -p：创建多级目录 7、rmdir 删除空目录 8、rm 删除文件 -f：不询问删除 -r：递归删除 9、touch 创建空文件 10、cp 复制指令 -r：递归复制整个文件夹 /cp：不询问覆盖 11、mv 移动文件或目录重命名 12、cat 查看文件内容，只读 -n：显示行号 13、more 查看文件内容 空格：下一页 Enter：下一行 q：退出 Ctrl + F：下一页 Ctrl + B：上一页 =：输出行号 :f：输出文件名和当前行号 14、less 分屏查看文件内容（大文件时效率高） 空格：下一页 pagedown：下一页 pageup：上一页 /字串：向下搜索，n：向下，N：向上 ?字串：与 /字串 相反 q：退出 15、&gt; 输出重定向：会将文件内容覆盖 栗子： ls -l &gt; 文件 commond &gt; /dev/null：/dev/null 为空文件 commond &gt; /dev/null 2&gt;&amp;1： 1表示stdout标准输出，系统默认为1，所以&gt; /dev/null 等同于 1 &gt; /dev/null 2标识stdout标准错误 &amp;标识等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 16、&gt;&gt; 追加：不会覆盖原来文件的内容 栗子：ls -l &gt;&gt; 文件 17、echo 输出内容到控制台 18、head 显示文件头部内容，默认10行 -n：指定显示多少行 19、tail 显示文件尾部内容，默认10行 -n：指令显示多少行 -f：追踪文档的所有更新（查看日志文件） 20、ln 创建软链接（类似window快捷方式） ln -s [原目录或文件][软链接名] 删除软链接：rm -rf 软链接名，不要带斜杠！ 21、history 查看历史指令 22、date 显示当前日期 23、cal 查看日历指令 24、find [范围][选项] -name：按文件查找 -user：按文件所有者查找 -size：按大小查找，+20M，-20M 或 20M 25、locate 快速定位文件路径 使用该指令前必须使用 updatedb 指令创建locate数据库 26、grep 过滤查找，使用管道符号，|，表示将前一个命令的处理结果输出传递给后面的指令处理。 -n：显示行号 -i：忽略大小写 栗子：cat hello.txt | grep -ni yes 27、gzip/gunzip gzip：压缩文件 gunzip：解压文件（gz后缀） 28、zip/unzip zip：压缩文件 unzip：解压文件（zip后缀） 29、tar -c：产生tar文件 -v：显示详细信息 -f：指定压缩后的文件名 -z：打包同时压缩 -x：解包tar文件 -zcvf：压缩 -zxvf：解压（tar.gz后缀） 30、netstat 监控TCP/IP网络的工具，可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 -a：显示所有连线中的Socket -n：不显示域名服务器，直接使用ip地址 -l：显示监控中的服务器的Socket -t：显示TCP传输协议的连线状况 -u：显示UDP传输协议的连线状况 -p：显示正在使用Socket的程序识别码和程序名称 31、lsof List Open Files，系统级监控诊断工具，可以列出各种进程打开的文件信息 32、nohup no hang up，不挂起，当前交互命令行退出的时候，程序还要在 通常跟 &amp; 一起使用，&amp;表示后台运行 栗子：nohup java -jar Test.jar &gt; /dev/null 2&gt;&amp;1 &amp; 33、awk AWK是一种处理文本文件的语言，是一个强大的文本分析工具。 栗子：ps -ef | grep conky | awk ‘{print $2}’ （4）管道命令 目录 命令 管道命令 \ 选取命令 cut，grep 排序命令 sort，wc，uniq 双重数据流 tee 字符转换命令 tr，expand，col，join，paste 切割命令 split 参数代换 xargs 五、组管理和权限管理（1）文件详细信息 通过 ls -l 查看文件的详细信息 123drwxr-xr-x. 5 root root 4096 9月 28 09:44 yum-rw-r--r--. 1 root root 969 5月 12 2016 yum.conf12345678910 11 12 13 14 15 16 1：表示文件类型，文件为 -，目录为 d 2-4：表示所有者权限，rwx分别表示，读、写和执行 5-7：表示所在组权限 8-10：表示其他组权限 11：如果是文件，表示硬链接数；如果是目录表示该目录的子目录数（包括隐藏目录） 12：文件所有者 13：文件所在组 14：文件大小，目录大小默认为4096 15：最后修改时间 16：文件名 （2）rwx权限1、文件 r：表示可读 w：表示可写，不一定可以删除，要有删除权限前提是当前文件目录有可写权限 x：表示可执行 2、目录 r：表示可读，ls可查看 w：表示可以修改，目录内创建、删除、重命名 x：表示可执行，可以进入该目录 （3）修改权限 chmod 1、方式一 +、-、=变更 u：所有者 g：所有组 o：其他组 a：所有人 栗子：chmod u=rwx,g=rx,o=x 文件目录名 2、方式二 r=4、w=2、x=1，rwx=4+2+1=7 栗子：chmod u=rwxg=rx,o=x 文件目录名 等价于 chmod 751 文件目录名 （4）修改文件所有者 chown chown newowner file 改变文件的所有者 chown newowner:newgroup file 改变用户的所有者和所有组 -R：如果是目录，则使其下所有子文件和目录递归生效 （5）修改文件所在组 chgrp chgrp newgroup file 修改文件的所在组]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Docker部署SpringBoot项目]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Web%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[一、Docker在Linux环境下的下载安装参照Docker安装及简单使用这篇文章进行下载安装~ 二、使用Docker安装配置Mysql 从docker hub拉取最新的Mysql镜像 123456789101112131415161718[root@192 /]# docker pull mysqlUsing default tag: latestTrying to pull repository docker.io/library/mysql ...latest: Pulling from docker.io/library/mysql802b00ed6f79: Pull complete30f19a05b898: Pull complete3e43303be5e9: Pull complete94b281824ae2: Pull complete51eb397095b1: Pull complete54567da6fdf0: Pull completebc57ddb85cce: Pull completed6cd3c7302aa: Pull completed8263dad8dbb: Pull complete780f2f86056d: Pull complete8e0761cb58cd: Pull complete7588cfc269e5: Pull completeDigest: sha256:038f5f6ea8c8f63cfce1bce9c057ab3691cad867e18da8ad4ba6c90874d0537aStatus: Downloaded newer image for docker.io/mysql:latest 查看已有镜像 123[root@192 /]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/mysql latest 6a834f03bd02 3 weeks ago 484 MB 启动Mysql容器 12[root@192 /]# docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql1e70b88a06383a6e288d09685439fe193fe95fca85bd606042e4da233a6e4033 查看已启动容器 123[root@192 /]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e70b88a0638 mysql "docker-entrypoint..." 16 seconds ago Up 15 seconds 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 在window下使用navicat连接数据库，并导入对应数据库即可 三、SpringBoot导出jar包 四、使用Dockerfile构建openjdk镜像 使用scp命令将jar包从window导入linux（注：该操作要在window命令行执行） 123scp /d/project/IdeaProjects/wx/card/build/libs/card-0.0.1-SNAPSHOT.jar root@192.168.5.67:/openjdk/root@192.168.5.67's password: #输入你的linux系统密码card-0.0.1-SNAPSHOT.jar 100% 27MB 43.4MB/s 00:00 在openjdk目录下创建Dockerfile文件，内容如下： 1234567891011# 基于哪个镜像FROM openjdk:8# 将本地⽂件夹挂载到当前容器VOLUME /tmp# 开放8080端口EXPOSE 8080# 拷⻉⽂件到容器ADD card-0.0.1-SNAPSHOT.jar app.jarRUN bash -c &apos;touch /card-0.0.1-SNAPSHOT.jar&apos;# 配置容器启动后执⾏的命令CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/card-0.0.1-SNAPSHOT.jar&quot;] 当前openjdk目录如下 12[root@192 openjdk]# lscard-0.0.1-SNAPSHOT.jar Dockerfile 构建docker镜像 1234567891011121314151617181920212223242526272829303132333435363738[root@192 openjdk]# docker build -t wx/card .Sending build context to Docker daemon 28.17 MBStep 1/6 : FROM openjdk:8Trying to pull repository docker.io/library/openjdk ...8: Pulling from docker.io/library/openjdk05d1a5232b46: Pull complete5cee356eda6b: Pull complete89d3385f0fd3: Pull complete80ae6b477848: Pull complete40624ba8b77e: Pull complete8081dc39373d: Pull complete8a4b3841871b: Pull completeb919b8fd1620: Pull complete2760538fe600: Pull completeDigest: sha256:28c751d7461b624a0fedfaf5295fda83242c612c5e1ad2fe34c9c78cc5ee8755Status: Downloaded newer image for docker.io/openjdk:8 ---&gt; 81f83aac57d6Step 2/6 : VOLUME /tmp ---&gt; Running in 9c2aee938c46 ---&gt; ce5056b8f1e8Removing intermediate container 9c2aee938c46Step 3/6 : EXPOSE 8080 ---&gt; Running in e6f2966baff8 ---&gt; b023c77db552Removing intermediate container e6f2966baff8Step 4/6 : ADD card-0.0.1-SNAPSHOT.jar app.jar ---&gt; bf17297d2dd8Removing intermediate container 554aa0f3d90eStep 5/6 : RUN bash -c 'touch /card-0.0.1-SNAPSHOT.jar' ---&gt; Running in 240209263a87 ---&gt; ee62463069bfRemoving intermediate container 240209263a87Step 6/6 : CMD java -jar /card-0.0.1-SNAPSHOT.jar ---&gt; Running in 93a4c14e812d ---&gt; 44ce7c9e2ec5Removing intermediate container 93a4c14e812dSuccessfully built d2e4c843e0f4 查看已有镜像 12345[root@192 openjdk]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEwx/card latest d2e4c843e0f4 53 minutes ago 652 MBdocker.io/openjdk 8 81f83aac57d6 3 weeks ago 624 MBdocker.io/mysql latest 6a834f03bd02 3 weeks ago 484 MB 启动刚新建的容器 12[root@192 openjdk]# docker run -p 8080:8080 --name card -d wx/card77f963935f9aaf1996431db90777da55962fda9bef95340b797136a2931f3d36 查看已启动的容器 1234[root@192 openjdk]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77f963935f9a wx/card "java -jar /app.jar" 6 seconds ago Up 5 seconds 0.0.0.0:8080-&gt;8080/tcp card1e70b88a0638 mysql "docker-entrypoint..." 14 minutes ago Up 14 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 可以看到项目已经正常启动了，打开浏览器输入ip地址加8080就可以访问了（注：项目的端口要与容器的端口一致才能正常访问） 五、配置Nginx服务器，使用二级域名访问服务器 上诉操作我是在本地Linux虚拟机上操作的，剩下的操作将转移到腾讯云的Linux服务器上 首先在腾讯云后台操作，把二级域名解析到云服务器ip地址上 稍等片刻，即可在浏览器上通过域名+端口访问项目（解析需要一段时间，期间可以使用 ping 域名 命令来判断是否正确指向ip） 从docker hub拉取最新的Nginx镜像 123456789[root@VM_0_7_centos /]# docker pull nginxUsing default tag: latestTrying to pull repository docker.io/library/nginx ...latest: Pulling from docker.io/library/nginx802b00ed6f79: Already existsc16436dbc224: Pull complete683eac851b28: Pull completeDigest: sha256:e8ab8d42e0c34c104ac60b43ba60b19af08e19a0e6d50396bdfd4cef0347ba83Status: Downloaded newer image for docker.io/nginx:latest 查看已有镜像 123456[root@VM_0_7_centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/nginx latest bc26f1ed35cf 39 hours ago 109 MBwx/card latest d2e4c843e0f4 53 minutes ago 652 MBdocker.io/openjdk 8 81f83aac57d6 3 weeks ago 624 MBdocker.io/mysql latest 6a834f03bd02 3 weeks ago 484 MB 编写nginx.conf配置文件，放在服务器 nginx/conf 目录下 12345678910111213141516171819202122232425262728293031323334353637#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; upstream wx &#123; server 172.16.0.7:8080 weight=1; &#125; server &#123; listen 80; server_name wx.mrxiexie.cn; access_log /var/log/nginx/access.log main; location / &#123; proxy_pass http://wx; &#125; &#125;&#125; nginx目录如下 12[root@VM_0_7_centos nginx]# lsconf 启动Nginx容器（注：需要在nginx目录下使用如下命令） 12[root@VM_0_7_centos nginx]# docker run -p 80:80 --name nginx -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -d bc26f1ed35cf8d2e61da4374b47e982ad15814986b2f6c3f8d16cd3d4936fda609096f142262 查看已启动的容器 12345[root@VM_0_7_centos nginx]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6c3e47090f0d bc26f1ed35cf "nginx -g 'daemon ..." 27 hours ago Up 3 minutes 0.0.0.0:80-&gt;80/tcp nginx77f963935f9a wx/card "java -jar /app.jar" 6 seconds ago Up 5 seconds 0.0.0.0:8080-&gt;8080/tcp card1e70b88a0638 mysql "docker-entrypoint..." 14 minutes ago Up 14 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 最后还需要防火墙开放对应的程序端口，我这里需要开放8080端口 12345$ firewall-cmd --zone=public --add-port=8080/tcp --permanent$ firewall-cmd --reload# 查看端口是否开放，yes为开放$ firewall-cmd --zone=public --query-port=8080/tcpyes 浏览器输入二级域名即可访问~ 以上所有配置仅供参考，详细配置请参照对应官方文档~]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Java</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓dp、dpi、px的关系]]></title>
    <url>%2F%E5%AE%89%E5%8D%93dp%E3%80%81dpi%E3%80%81px%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[一、屏幕宽对应dpi 宽 DPI等级 DPI数值 240 LDPI 120 320 MDPI 160 480 HDPI 240 720 XHDPI 320 1080 XXHDPI 480 1440 XXXHDPI 640 二、计算公式（1）dpi计算公式dpi：(dot per inch)每英寸像素多少 dpi = 对角线的像素 / 屏幕尺寸 （2）dp与px换算px = dp * (dpi/160)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx学习笔记]]></title>
    <url>%2FNginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、Nginx初探（1）Nginx是什么 Nginx是一款免费开源的HTTP服务器及反向代理服务器，官网链接 （2）Nginx的功能 Nginx提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。 Nginx提供高级HTTP服务，可以进行自定义配置，支持虚拟主机，支持URL重定向，支持网络监控，支持流媒体传输等。 Nginx作为邮件代理服务器是最早开发这个产品的目的之一，它支持IMAP/POP3代理服务功能，支持内部SMTP代理服务功能。 二、Nginx的安装和部署下载地址 （1）Window下安装 window版下载下来为一个压缩文件，解压即可使用，文件目录如下： conf 目录中存放的是Nginx服务器的配置文件，包含Nginx服务器的基本配置文件和对部分特性的配置文件 docs 目录中存放了Nginx服务器的文档资料，包含Nginx服务器的LICENSE，OpenSSL的LICENSE，PCRE的LICENSE以及zlib的LICENSE，还包括本版本Nginx服务器升级的版本变更说明，以及README文档 html 目录中存放了两个后缀名为.html的静态网页文件。这两个文件与Nginx服务器的运行相关。 logs目录中存放了Nginx服务器运行的日志文件 nginx.exe 即为启动Nginx服务器的运行程序 （2）Linux下安装1、把下载的安装包放在一个文件夹中，解压~ 123456789101112131415161718192021[root@localhost nginx]# lsnginx-1.15.3.tar.gz[root@localhost nginx]# tar xf nginx-1.15.3.tar.gz [root@localhost nginx]# lsnginx-1.15.3 nginx-1.15.3.tar.gz[root@localhost nginx]# cd nginx-1.15.3[root@localhost nginx-1.15.3]# lsauto CHANGES CHANGES.ru conf configure contrib html LICENSE man README src [root@localhost nginx-1.15.3]# ls -l 总用量 740 drwxr-xr-x. 6 1001 1001 4096 9月 20 23:07 auto -rw-r--r--. 1 1001 1001 290941 8月 28 23:36 CHANGES -rw-r--r--. 1 1001 1001 443800 8月 28 23:36 CHANGES.ru drwxr-xr-x. 2 1001 1001 168 9月 20 23:07 conf -rwxr-xr-x. 1 1001 1001 2502 8月 28 23:36 configure drwxr-xr-x. 4 1001 1001 72 9月 20 23:07 contrib drwxr-xr-x. 2 1001 1001 40 9月 20 23:07 html -rw-r--r--. 1 1001 1001 1397 8月 28 23:36 LICENSE drwxr-xr-x. 2 1001 1001 21 9月 20 23:07 man -rw-r--r--. 1 1001 1001 49 8月 28 23:36 README drwxr-xr-x. 9 1001 1001 91 9月 20 23:07 src src 目录中存放了Nginx软件的所有源代码 man 目录中存放了Nginx软件的帮助文档 man nginx html 目录和 conf 目录中存放的内容和windows版本的同名目录相同 auto 目录中存放了大量的脚本文件，和configuration脚本程序有关 configura 文件是Nginx软件的自动脚本程序 2、下载Nginx需要依赖的第三方库 1yum -y install gcc gcc-c++ automake pcre pcre-devel zlib zlib-deve l open openssl-devel 3、配置并生产Makefile文件 1./configure --prefix=/Nginx 4、编译与安装，最后nginx安装在了 /Nginx 目录下 12makemake install 5、查看安装目录 12[root@localhost Nginx]# lsconf html logs sbin conf 目录中存放了Nginx的所有配置文件。其中，ngfix.conf文件是Nginx服务器的主配置文件，其他配置文件是用来配置Nginx的相关功能，比如，配置 fastcgi 使用的 fastcgi.conf 和 fastcgi_params 两个文件。所有的配置文件都提供了以 .default 结尾的默认配置文件，方便我们将配置过的 .conf 文件恢复到初始状态 html 目录中存放了 Nginx服务器在运行过程中调用的一些html网页文件。 logs 目录，用来存放Nginx服务器的日志 sbin目录，目前其中只有一个nginx文件，这就是Nginx服务器的主程序 （3）Nginx服务的启停控制 Nginx服务器的启动停止，有一类是通过信号机制来实现的。 Nginx在运行时，会保持一个主进程和一个或多个worker process 工作进程。 通过给Nginx的主进程发送信号就可以控制服务的启动停止了。 1、启动Nginx1[root@desktop-ksot40m Nginx]# ./sbin/nginx 2、查看Nginx的主进程PID，当前主进程为1143 通过ps命令获取 1234[root@desktop-ksot40m Nginx]# ps -ef | grep nginxroot 1143 1 0 11:05 ? 00:00:00 nginx: master process ./sbin/nginxnobody 1144 1143 0 11:05 ? 00:00:00 nginx: worker processroot 1169 1123 0 11:37 pts/0 00:00:00 grep --color=auto nginx 查看nginx.conf文件 12345[root@desktop-ksot40m Nginx]# cd logs/[root@desktop-ksot40m logs]# lsaccess.log error.log nginx.pid[root@desktop-ksot40m logs]# cat nginx.pid1143 3、停止Nginx12kill SIGNAL PIDkill SIGNAL 'filepath' //指定nginx.pid动态获取pid号 信号 作用 TERM 或 INT 快速停止Nginx服务 QUIT 平缓停止Nginx服务 HUP 使用新的配置文件启动进程，之后平缓停止原有进程，也就是所谓的平滑重启 USR1 重新打开日志文件，常用于日志切割，在相关章节中会对此进一步说明 USR2 使用新版本的Nginx文件启动服务，之后平缓停止原有Nginx进程，也就是所谓的”平滑升级“ WINCH 平缓停止worker process，用于Nginx服务器平滑升级 4、重启Nginx12kill -HUP PIDkill -HUP 'filepath' //指定nginx.pid动态获取pid号 5、升级Nginx Nginx服务器提供平滑升级功能 Nginx服务接收到 USR2 信号后，首先将旧的 nginx.pid 文件添加后缀 .oldbin ，变为 nginx.pid.oldbin 文件；然后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要向旧的Nginx服务进程发出 WINCH 信号，使旧的Nginx服务平滑停止，并删除 nginx.pid.oldbin 文件。在发送 WINCH 信号之前，可以随时停止新的Nginx服务。 实现Nginx服务器平滑升级，应该保持安装路径一致。如果由于某种原因无法保持一致。则可以先将旧服务器的安装路径改为新服务器的安装路径。 1./Nginx/nginx -p newInstallPath 备份好旧服务器，安装新的服务器，使用以下两种其中之一，命令实现Nginx服务的平滑升级 12./sbin/Nginx -g USR2kill -USR2 PID 通过 ps -ef | grep nginx 查看新的Nginx服务启动正常，再使用 WINCH 信号用于发送平滑停止旧服务信号 12./sbin/Nginx -g WINCHkill WINCH PID （4）Nginx服务器基本配置指令1、打开nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#user nobody;#全局生效worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; #在events中部分生效 worker_connections 1024;&#125;http &#123; #以下指令在http部分中生效 include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; #以下指令在http的server部分中生效 server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #以下指令在http/server的location中生效 location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 2、nginx.conf文件的结构 nginx.conf 由三部分组成，全局块、events块和http块 http块中包含http全局块，多个server块 server块中包含server全局块，多个location块 12345678910111213141516171819202122232425#全局块#event块events &#123; &#125;#http块http &#123;#http全局块 #server块 server &#123; #server全局块 #location块 location [PATTERN] &#123; &#125; #location块 location [PATTERN] &#123; &#125; &#125; #server块 server &#123; &#125;&#125; 3、各个块作用 全局块：全局块是默认配置文件从开始到events块之间的一部分内容，主要设置一些影响Nginx服务器整体运行的配置指令，因此指令的作用于是Nginx服务器全局。通常包括配置运行Nginx服务器的用户（组），允许生成的worker process数、Nginx进程PID存放路径，日志的存放路径和类型以及配置文件引入等。 event块：events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个worker process 可以同时支持的最大连接数等。 http块：http块是Nginx服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。可以在http全局块中配置的指令包括文件引入、MIME-TYPE定义、日志自定义、是否使用sendfile传输文件、连接超时时间、单链接请求数上限等。 server块：server块和“虚拟主机”的概念有密切联系。一台实体主机可以有多个虚拟主机。一个Nginx服务器提供Web服务时，同一个Nginx进程可以运行多个网站，就是通过server块来完成这个功能。每一个server块就相当于一台虚拟主机，它内部可有多台主机联合提供服务，一起对外提供逻辑上关系密切的一组服务。server全局块指令的作用域为本server块，其不会影响其他server块。在server全局块中，最常见的两个配置项就是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。 location块：基于Nginx服务器接收到的请求字符创（例如，server_name/uri_string），对除虚拟主机名称（也可以IP别名）之外的字符串进行匹配（/uri_string）。地址定向、数据缓存和应答控制等功能都是在这部分实现。许多第三方模块的配置也是在location块中提供功能。 4、配置运行Nginx服务器的用户（组）只有设置的用户或用户组成员才能运行Nginx服务器 1user user [group]; user：指定可以运行Nginx服务器的用户 group：指定可以运行Nginx服务器的用户组 如果希望所有用户都可以启动Nginx进程，可以将该指令注释，或者使用如下指令 12# user [user] [group];user nobody nobody; #这也是user指令的默认设置 5、配置运行生成的worker process 数workr process 是Nginx服务器实现并发处理服务器的关键所在。理论上，数值越大可支持并发越大。但也会受软件本身、操作系统本身资源、硬件设备等约束。 1worker_processes number | auto; number：指定Nginx进程最多可以产生的worker process 数 auto：Nginx进程会自动监测 6、配置Nginx进程PID存放路径Nginx进程作为系统的守护进程运行，我们需要再某文件中保存当前运行程序的主进程号。 1pid file; file：指定文件路径和文件名称 7、配置错误日志的存放路径在全局块，http块和server块都可以对Nginx服务器的日志进行相关配置。 1error_log file | stderr [debug | info | notice | warb | error | crit | alert | emerg]; file：指定文件路径和文件名称 stderr：日志级别 8、配置文件的引入有时候，我们需要将其他的Nginx配置或者第三方模块配置引用到当前的主配置文件中。Nginx提供了include指令来完成配置文件的引入 1include file; file：要引入的配置文件 9、设置网络连接的序列化 惊群：当某一时刻只有一个网络连接到来时，多个睡眠线程会被同时叫醒，但是只有一个进程可以获得连接。如果每次唤醒进程数太多，会影响性能。 使用 accept_mutex 指令可以解决这个问题。当该设置开启时，将会对多个Nginx进程接收连接进行序列化，防止多个进程对连接争抢 1accept_mutex on | off; 只能在events块中进行配置 10、配置是否允许同时接收多个网络连接 每个Nginx服务器的worker process 都有能力同时接收多个新的到达的网络连接。 1multi_accept on | off; 当为off时，worker process一次只能接收到一个新到达的网络连接。 11、事件驱动模型的选择 Nginx提供了多种事件驱动模型来处理网络消息。配置文件中为我们提供了相关的指令来强制Nginx服务器选择哪种事件驱动模型进行消息处理，指令为use 1use method; method：select、poll、kqueue、epoll、rtsig、/dev/poll 以及 eventport 只能在events块中进行配置 12、配置最大连接数 指令 worker_connections 主要用来设置允许每一个 worker process 同时开启的最大连接数。 1worker_connections number; 默认为512 只能在events块中进行配置 13、定义MIME-TYPE 浏览器中可现实的内容有HTML、XML、GIF及Flash等种类繁多的文本、媒体等资源，浏览器可以区分这些资源，需要使用MIME Type。 Nginx默认配置中，http全局块中有一下两行配置 12include mime.types;default_type application/octet-stream 第一行从外部引入了 mime_types 文件 第二行使用指令 default_type 配置了用于处理前段请求的MIME类型 1default_type mine-type; 默认值为 text/plain 可以在http块，server块或者location块中进行设置 14、自定义服务日志 记录Nginx服务器提供服务过程应答前端请求的日志。 Nginx服务器支持对服务日志的格式、大小、输出等进行配置，需要使用两个指令，分别是access_log 和 log_format指令 access_log指令的语法结构为： 1access_log path [format [buffer=size]]; path：配置服务日志的文件存放的路径和名称。 format：可选项，自定义服务日志的格式字符串，也可以通过“格式串的名称” 使用 log_format 指令定义好的格式。“格式串的名称” 在 log_format 指令中定义 size：配置临时存放日志的内存缓存区大小 可以在http块、server块或者location块中进行配置。默认配置为： 1access_log logs/access.log combined; 其中，combined为 log_format 指令默认定义的日志格式字符串的名称。 如果要取消服务日志的功能，则使用： 1access_log off; 和access_log联合使用的另一个指令是log_format，它专门用于定义服务日志的格式，并且可以为格式字符串定义一个名字，以便access_log指令可以直接调用，其语法格式为： 1log_format name string ...; name：格式字符串的名字，默认的名字为combined。 string：服务日志的格式字符串。在定义过程中，可以使用Nginx配置预设的一些变量获取相关内容，变量的名称使用双引号括起来，string整体使用单引号括起来。 示例： 1log_format exampleLog &apos;$remote_addr&apos; - [$time_local] $request &apos; &apos;$status $body_bytes_sent $http_referer &apos; &apos;$http_user_agent&apos;; 上面示例定义了服务日志文件的名称为 exampleLog 结果： 1192.168.1.102 - [31/Oct/2011:20:41:39 +0800] &quot;GET/HTTP/1.1&quot; 200 151 &quot;-&quot; &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)&quot; $remote_addr：获取到用户机的ip地址为 192.168.1.102 $time_local：获取到本地时间为 31/Oct/2011:20:41:39 +0800 $request：获取到请求为GET/favicon.ico HTTP/1.1 $status：获取到请求状态为404（未找到） $body_bytes_sent：获取到请求体的大小为 570B $http_referer：未获取到任何内容 $http_user_agent：获取到用户是用Mozilla浏览器 只能在http块中进行配置 15、配置允许sendfile方式传输文件 sendfile传输方式的相关指令 sendfile 和 sendfile_max_chunk 以及它们的语法结构： 1sendfile on | off; 用于开启或者关闭 sendfile() 传输文件，默认值为off，可以在http块、server块或者location块中进行配置。 1sendfile_max_chunk size; 其中，size值如果大于0，Nginx进程的每个worker process 每次调用sendfile() 传输的数据最大不能超过这个值；如果设置为0，则无限制。默认值为0。可以在http块、server块或者location块中进行配置。 1sendfile_max_chunk 128k; 16、配置连接超时时间 与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间 1keepalive_timeout timeout [header_timeout]; timeout：服务器端对连接的保持时间。默认值为75s。 header_timeout：可选项。在应答报文头部的Keep_Alive域设置超时时间：“Keep_Alive:timeout=header_timeout”。 1keepalive_timeout 120s 100s; 可以在http块，server块或者location块中进行设置 17、单连接请求数上限 Nginx服务器端和用户端建立会话后，用户端通过此连接发送请求。指令 keepalive_requests 用于限制用户通过某一连接向Nginx服务器发送请求的次数。 1keepalive_requests numbers; 可以在http块，server块或者location块中进行设置，默认100。 18、配置网络监听 使用 listen，其配置方法主要有三种，我们先分别介绍三种配置的语法结构，然后统一介绍涉及的相关变量和标识符。 第一种：配置监听的ip地址 1listen addr[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]; 第二种：配置监听端口 1listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl]; 第三种：配置UNIX Domain Socket（一种在原有Socket框架发展起来的IPC机制，用于在单个主机上执行客户、服务器通信） 1listen unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ssl]; address：IP地址，如果是IPv6的地址，需要使用中括号“[]”括起来，比如[fe80::1]等。 port，端口号，如果只定义了IP地址没有定义端口号，就使用80端口。 path：socket文件路径，如var/run/nginx.sock等。 default_server：标识符，将此虚拟主机设置为address:port的默认主机。 setfib=number：Nginx-0.8.44中使用这个变量为监听socket关联路由表，目前支队FreeBSD起作用，不常用。 backlog=number：设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在FreeBSD中默认为-1，其他平台默认为511。 rcvbuf=size：设置监听socket接收缓存区大小。 sndbuf=size：设置监听socket发送缓存区大小。 deferred：标识符，将accept()设置为Deferred模式。 accept_filter=filter：设置监听端口对请求的过滤，被过滤的内容不能接收和处理。可以设置dataready和httpready。 bind：标识符，使用独立的bind()处理此address:port；一般情况下，对于端口相同而ip地址不同的多个连接，Nginx服务器将只使用一个监听命令，并使用bind()处理端口相同的所有连接。 ssl：标识符，设置会话连接使用SSL 模式，此标识符和Nginx服务器提供的HTTPS服务有关。 默认设置： 1listen *:80 | *:8000; 即监听所有80端口和8000端口。示例： 1234listen 192.168.1.10:8000; #监听具体的IP和具体的端口上的连接listen 192.168.1.10; #监听具体IP的所有端口上的连接listen 8000; #监听具体端口上的所有IP连接，等同于listen *:8000;listen 192.168.1.10 default_server backlog=1024; #设置192.168.1.10 的连接请求默认由此虚拟主机处理，并且允许最多1024网络连接同时处于挂起状态。 19、基于名称的虚拟主机配置 主机，指的是server块对外提供的虚拟主机。设置了主机的名称并配置好DNS，用户就可以使用这个名称对此虚拟主机发送请求了。 1server_name name ...; name：可以只有一个名称，也可以由多个名称并列，之间使用空格隔开。每个名字就是一个域名，由两段或三段组成，之间由点号 “.” 隔开。 1server_name myserver.com www.myserver.com; 示例中，此虚拟主机的名称设置为 myserver.com 或 www.myserver.com。Nginx服务器规定，第一个名称作为此虚拟主机的主要名称。 20、配置location块 在Nginx的官方文档中定义的location的语法结构为： 1location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125; uri：是待匹配的请求字符串，可以是不含正则表达的字符串，如/myserver.php等；也可以是包含有正则表达的字符串，如 .php$（表示以.php结尾的URL）等。 Nginx服务器首先在server块的多个location中搜索是否有标准的uri和请求字符串匹配，如果有多个可以匹配，就记录匹配度最高的一个。然后服务器再用location块中的正则uri和请求字符串匹配，当第一个正则uri匹配成功，结束搜索，并使用这个location块处理此请求；如果正则匹配全部失败，就使用刚才记录的匹配度最高的location块处理此请求。 “=”：用于标准uri前，要求请求字符串与uri严格匹配。如果匹配成功，就停止继续向下搜索并立即处理此请求。 “~”：用于表示uri包含正则表达式，并且区分大小写。 “~*”：用于表示uri包含正则表达式，并且不区分大小写。 “^~”：用于标准uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。 如果uri包含正则表达式，就必须使用 “~” 或者 “~*” 标识。 21、配置请求的根目录 Web服务器收到网络请求之后，首先要在服务器端指定目录中寻找请求资源。在Nginx服务器中，指令root就是用来配置这个根目录。 1root path; path：Nginx服务器接收到请求以后查找资源的根目录路径。path变量中可以包含Nginx服务器预设的大多数变量。 123location /data/&#123; root /locationtest1;&#125; 当location块收到 “data/index.html” 的请求时，将在 /locationtest1/data 目录下找到 index.html 响应请求。 可以在http块，server块或者location块中进行设置。 22、更改location的URI 在location块中，除了使用root指令指明请求处理根目录，还可以使用alias指令改变location接收到的URI的请求路径 1alias path; path：修改后的根路径。 示例： 123location = ^/data/(.+\.(html|htm))$ &#123; alias /locationtest1/other/$1&#125; 当次location块接收到 “/data/index.htm” 的请求时，匹配成功，之后根据alias指令的配置，Nginx服务器将到/locationtest1/other目录下找到index.htm并响应请求。 23、设置网站的默认首页 指令index用于设置网站的默认首页，它一般可以有两个作用： 用户在发出请求访问网站时，请求地址可以不写首页的名称； 可以对一个请求，根据其请求内容而设置不同的首页。 1index file ...; file：可以包括多个文件名，期间使用空格分隔，也可以包含其他变量。默认为 “index.html” 123location = ^/data/(.+)/web/ $ &#123; index index.$1.html index.myl.html index.html;&#125; 当location块接收到“/data/locationtest/web”时，匹配成功，它首先将预设变量$1置为locationtest。然后在/data/locationtest/web/ 路径下按照 index 的配置次序依次寻找 index.locationtest.html 页、index.my1.html 页和 index.html 页，首先找到哪个页面，就使用哪个页面响应请求。 24、设置网站的错误页面 HTTP 2xx：请求正常完成 HTTP 3xx：网站重定向 HTTP 4xx：客户端出现错误 HTTP 5xx：服务器端出现错误 1error_page code ... [=[response]] uri； code：要处理的HTTP错误代码 response：将code指定的错误代码转化为新的错误代码response。 uri：错误页面的路径或者网站地址。如果设置为路径，则是以Nginx服务器安装路径下的html目录为根路径的相对路径；如果设置为网址，则Nginx服务器会直接访问该网址获取错误页面，并返回给用户端。 1error_page 404 /404.html; 设置Nginx服务器使用 “Nginx安装路径/html/404.html” 页面响应404错误 1error_page 403 http://somewebsite/com/forbidden.html; 设置Nginx服务器使用 “http://somewebsite.com/forbidden.html” 页面响应403错误 1error_page 410 =301 /empty.gif 设置Nginx服务器产生410的HTTP消息时，使用 “Nginx安装路径/html/empty.gif” 返回给用户301消息。 使用一个location指令定向错误页面到新的路径下面。 1error_page 404 /404.html 添加一个location块 123location /404.html &#123; root /myserver/errorpages/&#125; 首先捕获 “/404.html” 请求，然后将请求定向到新的路径下面即可。 可以在http块，server块或者location块中进行设置。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA安装插件]]></title>
    <url>%2FIDEA%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[一、IDEA中安装步骤 下面我们以安装Lombok为例 打开设置（使用快捷键Ctrl + Alt + S） 搜索Lombok 选择Lombok，点击install下载安装~ 安装后点击Restart重启即可 二、进入官网下载插件进行安装 进入官网，搜索插件回车。 选择Lombok Plugin 选择对应IDEA的版本号进行下载（这个很重要，版本不对应会出错！） 在IDEA，设置页面中，选择从磁盘上进行安装，然后选择刚下载的插件，Restart即可。]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网穿透之ngrok]]></title>
    <url>%2F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E4%B9%8Bngrok.html</url>
    <content type="text"><![CDATA[一、下载软件登录Ngrok官网，下载好软件。 二、内网穿透输入如下命令映射对应端口，以8080为例： 12345678910111213ngrok http 8080ngrok by @inconshreveable (Ctrl+C to quit)Session Status onlineSession Expires 7 hours, 58 minutesVersion 2.2.8Region United States (us)Web Interface http://127.0.0.1:4040Forwarding http://2f2b4cad.ngrok.io -&gt; localhost:8080Forwarding https://2f2b4cad.ngrok.io -&gt; localhost:8080Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>Ngrok</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中List的浅拷贝与深拷贝]]></title>
    <url>%2FJava%E4%B8%ADList%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</url>
    <content type="text"><![CDATA[List浅拷贝众所周知，list本质上是数组，而数组的是以地址的形式进行存储。list A浅拷贝给list B，由于进行的是浅拷贝，所以直接将A的内容复制给了B，java中相同内容的数组指向同一地址，即进行浅拷贝后A与B指向同一地址。造成的后果就是，改变B的同时也会改变A，因为改变B就是改变B所指向地址的内容，由于A也指向同一地址，所以A与B一起改变。 几种浅拷贝1、遍历循环复制1234List&lt;Person&gt; destList = new ArrayList&lt;Person&gt;(srcList.size());for (Person p : srcList) &#123; destList.add(p);&#125; 2、使用List实现类的构造方法1List&lt;Person&gt; destList = new ArrayList&lt;Person&gt;(srcList); 3、使用list.addAll()方法12List&lt;Person&gt; destList = new ArrayList&lt;Person&gt;(); destList.addAll(srcList); 4、使用System.arraycopy()方法123Person[] srcPersons = srcList.toArray(new Person[0]); Person[] destPersons = new Person[srcPersons.length]; System.arraycopy(srcPersons, 0, destPersons, 0, srcPersons.length); 测试及结果1234567891011printList(destList); //打印未改变B之前的A srcList.get(0).setAge(100); //改变B printList(destList); //打印改变B后的A//打印结果123--&gt;20 ABC--&gt;21 abc--&gt;22 123--&gt;100 ABC--&gt;21 abc--&gt;22 List深拷贝深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。 深拷贝的方法1.使用序列化方法12345678910111213public static &lt;T&gt; List&lt;T&gt; deepCopy(List&lt;T&gt; src) throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); @SuppressWarnings("unchecked") List&lt;T&gt; dest = (List&lt;T&gt;) in.readObject(); return dest;&#125;List&lt;Person&gt; destList = deepCopy(srcList); //调用该方法 2.clone方法1234567891011121314151617181920public class A implements Cloneable &#123; public String name[]; public A() &#123; name = new String[2]; &#125; public Object clone() &#123; A o = null; try &#123; o = (A) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return o; &#125;&#125;for (int i = 0; i &lt; n; i +=) &#123; copy.add((A) src.get(i).clone());&#125; ​ Java对对象和基本的数据类型的处理是不一样的。在Java中用对象的作为入口参数的传递则缺省为”引用传递”，也就是说仅仅传递了对象的一个”引用”，这个”引用”的概念同C语言中的指针引用是一样的。当函数体内部对输入变量改变时，实质上就是在对这个对象的直接操作。 除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。 测试及结果12345678910printList(destList); //打印未改变B之前的A srcList.get(0).setAge(100); //改变B printList(destList); //打印改变B后的A123--&gt;20 ABC--&gt;21 abc--&gt;22 123--&gt;20 ABC--&gt;21 abc--&gt;22 ​ 在浅复制的情况下，源数据被修改破坏之后，使用相同引用指向该数据的目标集合中的对应元素也就发生了相同的变化。因此，在需求要求必须深复制的情况下，要是使用上面提到的方法，请确保List中的T类对象是不易被外部修改和破坏的。 更多引用拷贝，对象拷贝，浅拷贝，深拷贝：传送门]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content type="text"><![CDATA[线程池原理 线程池的使用 线程池源码分析 一、线程池原理1.1 使用线程池的好处第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 1.2 线程池的实现原理当向线程池提交任务后，线程池会按下图所示流程去处理这个任务： 线程池的主要处理流程 1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 对应到代码层面就是ThreadPoolExecutor执行execute()方法。如下图所示： ThreadPoolExecutor执行示意图 1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。根据不同的拒绝策略去处理。 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 二、线程池的使用2.1创建线程池我们可以通过ThreadPoolExecutor构造方法来创建一个线程池。 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)&#123;&#125; 介绍一下这几个参数： 1）corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 2）maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 3）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。 4）TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。 5）runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 6）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线 程设置有意义的名字，代码如下。 new ThreadFactoryBuilder().setNameFormat(&quot;XX-task-%d&quot;).build(); 7）RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。 AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。 2.2向线程池提交任务可以使用两个方法向线程池提交任务，分别为`execute()`和`submit()`方法。这两个方法的区别就是，execute()用于提交不需要返回值的任务，submit()方法用于提交需要返回值的任务。 execute方法：​ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。 123456threadsPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125;&#125;); submit方法：​ 线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 1234567891011Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);try &#123; Object s = future.get();&#125; catch (InterruptedException e) &#123; // 处理中断异常&#125; catch (ExecutionException e) &#123; // 处理无法执行任务异常&#125; finally &#123; // 关闭线程池executor.shutdown();&#125; 2.3关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 2.4实例Demo（1）首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。 12static BlockingQueue blockingQueue=new ArrayBlockingQueue&lt;&gt;(1);static ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(10, 20, 1, TimeUnit.MINUTES, blockingQueue); （2）另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务： 12345678910111213static class TaskBusyWithoutResult implements Runnable &#123; public TaskBusyWithoutResult() &#123; &#125; @Override public void run() &#123; System.out.println("线程"+Thread.currentThread()+"开始运行"); int i=10000*10000; while(i&gt;0) &#123; i--; &#125; System.out.println("线程"+Thread.currentThread()+"运行结束"); &#125;&#125; （3）向线程池提交20个任务，执行任务 123456public static void main(String[] args) &#123; for (int i = 0; i &lt; 20; i++) &#123; Runnable runnable = new TaskBusyWithoutResult(); threadPoolExecutor.submit(runnable); &#125;&#125; 三、线程池源码分析基于jdk1.8 3.1 认识几个变量123456789101112131415private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;// Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。 3.2 execute()方法1234567891011121314151617181920212223242526public void execute(Runnable command) &#123; //如果提交了空的任务 抛出异常 if (command == null) throw new NullPointerException(); int c = ctl.get();//获取当前线程池的状态 //检查当前工作线程数量是否小于核心线程数量 if (workerCountOf(c) &lt; corePoolSize) &#123; //通过addWorker方法提交任务 if (addWorker(command, true)) return; c = ctl.get();//如果提交失败 需要二次检查状态 &#125; //向工作线程提交任务 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 再次检查状态 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //扩容失败 则拒绝任务 else if (!addWorker(command, false)) reject(command);&#125; 这里面有些细节： （1）if (! isRunning(recheck) &amp;&amp; remove(command))这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。 （2）addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。 3.3 addWorker()方法这个方法是任务提交的一个核心方法。在里面完成了状态检查、新建任务、执行任务等一系列动作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: //死循环更新状态 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c);//获取运行状态 //检查线程池是否处于关闭状态 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; //获取当前工作线程数量 int wc = workerCountOf(c); //如果已经超过corePoolSize获取maximumPoolSize 返回false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //CAS增加一个工作线程 if (compareAndIncrementWorkerCount(c)) break retry; //再次获取状态 c = ctl.get(); // Re-read ctl //如果状态更新失败 则循环更新 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);//初始化一个工作线程 final Thread t = w.thread; if (t != null) &#123; //获得锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //添加工作这到hashset中保存 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; //工作线程启动 执行第一个任务 就是新提交的任务 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。 Worker的构造方法如下： 123456789 /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);&#125; 3.4 runWorker()方法在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的： 1234 /** Delegates main run loop to outer runWorker */public void run() &#123; runWorker(this);&#125; 它实际上是将自己委托给线程池的runWorker方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //不断地从blockingQueue获取任务 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //执行beforeExecute方法 beforeExecute(wt, task); Throwable thrown = null; try &#123; //调用Runable的run方法 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // 执行aferExecute方法 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。 原文链接]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zxing开源库简单使用]]></title>
    <url>%2Fzxing%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E7%A0%81.html</url>
    <content type="text"><![CDATA[一、使用开源库ZxingZxing官网 二、导入Zxing-Core和Zxing-JavaSe1234// https://mvnrepository.com/artifact/com.google.zxing/javasecompile group: 'com.google.zxing', name: 'javase', version: '3.3.3'// https://mvnrepository.com/artifact/com.google.zxing/corecompile group: 'com.google.zxing', name: 'core', version: '3.3.3' 三、创建二维码1234567891011121314151617181920212223public class CreateQRCode &#123; public static void main(String[] args) &#123; int width=300;//定义二维码的长宽 int height=300; String formt="png";//图片格式 String contents="www.baidu.com"; //定义二维码的参数 HashMap&lt;EncodeHintType,Object&gt; hints=new HashMap&lt;EncodeHintType,Object&gt;(); hints.put(EncodeHintType.CHARACTER_SET,"utf-8");//指定二维码的编码格式 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);//指定二维码的纠错等级,纠错等级越高,则存储的信息越少,一般是指定M级 hints.put(EncodeHintType.MARGIN,2);//设置二维码周围的空白 //生成二维码 try &#123; BitMatrix bitMatrix=new MultiFormatWriter().encode(contents, BarcodeFormat.QR_CODE,width,height,hints); Path file=new File("d:/Img.png").toPath();//将指定的二维码图片生成在指定的地方 MatrixToImageWriter.writeToPath(bitMatrix,formt,file); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 四、解析二维码12345678910111213141516171819202122232425262728public static String decode(String imgPath) &#123; try &#123; Reader reader = new MultiFormatReader(); File file = new File(imgPath);//获取该图片文件 BufferedImage image; try &#123; image = ImageIO.read(file); if (null != image) &#123; LuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Result result; Hashtable hints = new Hashtable();//将图片反解码为二维矩阵 hints.put(DecodeHintType.CHARACTER_SET, "UTF-8"); result = new MultiFormatReader().decode(bitmap, hints);//将该二维矩阵解码成内容 String resultStr = result.getText(); return resultStr; &#125; else &#123; System.out.println("未找到图片,无法解析"); &#125; &#125; catch (IOException | ReaderException ioe) &#123; ioe.printStackTrace(); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return "";&#125; QrCodeUtil.java 本文参考]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git添加忽略文件]]></title>
    <url>%2FGit%E6%B7%BB%E5%8A%A0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[一、.gitignore文件每一个git项目都会有.gitignore忽略文件，记录着哪些文件不需要提交到仓库，下面是一个栗子： 1234567891011121314151617181920212223# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 二、使用规则 栗子 说明 *.a 忽略所有以 .a 结尾的文件 !lib.a 但是不忽略 lib.a 文件 /TODO 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ 忽略 build/ 目录下的所有文件 doc/*.txt 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 三、使用 git status 查看将要提交的文件12345678λ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: src/main/java/pers/mrxiexie/card/ASD.java 四、使用 git rm 命令当文件已经提交了，再去修改 .gitignore 文件忽略已经提交的文件是无效的，现在就需要用到 git rm 这条命令 1git rm -r --cached node_modules（要删除的文件名） 然后重新 git add 和 git commit 就可以了]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把项目托管到Github]]></title>
    <url>%2F%E6%8A%8A%E9%A1%B9%E7%9B%AE%E6%89%98%E7%AE%A1%E5%88%B0Github.html</url>
    <content type="text"><![CDATA[一、Github 登录Github官网，注册一个账号~，记录好你的用户名和邮箱，下面配置git要使用到 创建一个新项目 填写相关信息 复制仓库地址，在git配置的第五步会用到~ 二、下载Git 登录Git官网，下载，默认安装即可~ 当然你也可以像我一样使用Cmder，下载FULL版，里面内嵌了git~ 打开命令行窗口，输入如下指令，填写你github账号的名字和邮箱 12git config --global user.name "Your Name"git config --global user.email "email@example.com" 使用cd命令进入你保存项目的地方 使用git clone 命令，拉下你在github上创建的项目地址 查看当前目录，project已经 clone 下来了 进入project目录下，复制以下文件到上一级目录（我的上一级目录为card，也就是项目根路径） 删除project目录 打开命令行，进入项目根路径，依次输入以下指令即可把项目托管到Github上 123git add .git commit -m "此次提交描述" //commit到本地仓库git push origin master //上传到Github远程仓库 登录Github官网，发现我们的项目已经部署到Github上了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微容小程序在线生成BUG]]></title>
    <url>%2F%E5%BE%AE%E5%AE%B9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90Bug.html</url>
    <content type="text"><![CDATA[一、自由布局 + 图片 图片无法显示 BUG演示 在微容后台能够正常预览，在微信开发者工具显示空白，如下图： 产生原因 应该是自由布局的宽高跟图片的宽高一致，微容自动代码如下 12345678910&lt;view class='free-control YWq5vM' style='height:4724rpx'&gt; &lt;view class='free-item' &gt; //这一行没有指定高度宽度导致，图片宽高为0*0 &lt;form bindsubmit='openEvent' report-submit&gt; &lt;view class="eventBox Img-pic hvFJmv"&gt; &lt;button class="eventBtn"&gt;&lt;/button&gt; &lt;image class="Img T55Qvq" src="https://www.wsmo.cn/attachment/images/3986/2018/08/Ic6aXl5aPzleAEyl6a6qeybql5q5W6.jpg" /&gt; &lt;/view&gt; &lt;/form&gt; &lt;/view&gt;&lt;/view&gt; 解决方案 添加 &lt;view class=&#39;free-item&#39;&gt; 行内样式，指定宽度高度，代码如下 12345678910&lt;view class='free-control HwNV0a' style='height:1702rpx'&gt; &lt;view class='free-item' style="left:0rpx;width:746rpx;top:0rpx;height:1702rpx" &gt; &lt;form bindsubmit='openEvent' report-submit&gt; &lt;view class="eventBox Img-pic Rj50vm"&gt; &lt;button class="eventBtn"&gt;&lt;/button&gt; &lt;image class="Img qnmJDb" src="https://www.wsmo.cn/attachment/images/3986/2018/08/WZJN9F8pPXf76x6986ma92CkfA18l6.jpg" /&gt; &lt;/view&gt; &lt;/form&gt; &lt;/view&gt;&lt;/view&gt; 二、购车计算器，贷款项出现NaN BUG演示 产生原因 在carCalculator.js中 12345678910111213141516171819202122232425CarCalculatorInit() &#123; let that = this let configuration_id = that.data.id app.request(&#123; url: 'car/getRatio', data: &#123; configuration_id &#125;, success(res) &#123; let price = parseInt(res.result.list.guide_price) //res.result.rate 应该返回是首付比例的数组，例[30, 50]，可是微容返回了false，导致出现NaN let annualInterestRate = parseFloat(res.result.rate[0]) let payment_ratio = parseInt(res.result.ratio[0]) that.setData(&#123; result: res.result, price: price, ratio: res.result.ratio, rate: res.result.rate, annualInterestRate, payment_ratio &#125;) that.countPrice() &#125; &#125;)&#125;, 解决方法 修改carCalculator.js代码如下 12345678910111213141516171819202122232425CarCalculatorInit() &#123; let that = this let configuration_id = that.data.id app.request(&#123; url: 'car/getRatio', data: &#123; configuration_id &#125;, success(res) &#123; let price = parseInt(res.result.list.guide_price) let annualInterestRate = parseFloat(res.result.rate[0]) let ratio = [30, 50] //修改首付比例即可~ let payment_ratio = parseInt(ratio[0]) that.setData(&#123; result: res.result, price: price, ratio, rate: res.result.rate, annualInterestRate, payment_ratio &#125;) that.countPrice() &#125; &#125;)&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>微容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魁北克小程序二次开发]]></title>
    <url>%2F%E9%AD%81%E5%8C%97%E5%85%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>微容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、Spring简介Spring是什么 Spring是一个开源框架 Spring 为简化企业级应用开发而生. 使用 Spring 可以使简单的 JavaBean 实现以前只有 EJB 才能实现的功能. Spring 是一个 IOC(DI) 和 AOP 容器框架 具体描述 轻量级：Spring 是非侵入性的 - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API 依赖注入(DI — dependency injection、IOC) 面向切面编程(AOP — aspect oriented programming) 容器: Spring 是一个容器, 因为它包含并且管理应用对象的生命周期 框架: Spring 实现了使用简单的组件配置组合成一个复杂的应用. 在 Spring 中可以使用 XML 和 Java 注解组合这些对象 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 （实际上 Spring 自身也提供了展现层的 SpringMVC 和 持久层的 Spring JDBC） Spring模块 搭建Spring开发环境 把以下 jar 包加入到工程的 classpath 下: Spring 的配置文件: 一个典型的 Spring 项目需要创建一个或多个 Bean 配置文件, 这些配置文件用于在 Spring IOC 容器里配置 Bean. Bean 的配置文件可以放在 classpath 下, 也可以放在其它目录下. IOC 和 DI IOC IOC(Inversion of Control)：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式 DI DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接 二、配置 bean 配置形式：基于 XML 文件的方式；基于注解的方式 Bean 的配置方式：通过全类名（反射）、通过工厂方法（静态工厂方法 &amp; 实例工厂方法）、FactoryBean IOC 容器 BeanFactory &amp; ApplicationContext 概述 依赖注入的方式：属性注入；构造器注入 注入属性值细节 自动转配 bean 之间的关系：继承；依赖 bean 的作用域：singleton；prototype；WEB 环境作用域 使用外部属性文件 spEL IOC 容器中 Bean 的生命周期 Spring 4.x 新特性：泛型依赖注入 三、在 Spring 的 IOC 容器里配置 Bean(XML)（1）通过全类名（反射）123&lt;bean class="pers.mrxiexie.spring.HelloWorld" id="helloWorld"&gt; &lt;property name="name" value="MrXieXie"/&gt;&lt;/bean&gt; id为bean的名称，必须全局唯一 若 id 没有指定，Spring 自动将权限定性类名作为 Bean 的名字 class为bena的全类名（2）通过调用静态工厂方法 调用静态工厂方法创建 Bean是将对象创建的过程封装到静态方法中. 当客户端需要对象时, 只需要简单地调用静态方法, 而不同关心创建对象的细节. 要声明通过静态方法创建的 Bean, 需要在 Bean 的 class 属性里指定拥有该工厂的方法的类, 同时在 factory-method 属性里指定工厂方法的名称. 最后, 使用 元素为该方法传递方法参数.12345678910111213public class CarStaticFactory &#123; private static Map&lt;String, Car&gt; cars = new HashMap&lt;&gt;(); static &#123; cars.put("AAA", new Car("AAA", "奥迪")); cars.put("BBB", new Car("BBB", "奔驰")); &#125; public static Car getInstance(String name)&#123; return cars.get(name); &#125;&#125; 12345678910&lt;!-- 使用静态工厂方法创建bean class 是对应静态工厂方法所在的类 factory-method 为对应的静态工厂方法 constructor 填写该工厂方法的参数--&gt;&lt;bean id="car" class="pers.mrxiexie.spring.factory.CarStaticFactory" factory-method="getInstance" &gt; &lt;constructor-arg name="name" value="AAA"/&gt;&lt;/bean&gt; （3）通过调用实例工厂方法 实例工厂方法: 将对象的创建过程封装到另外一个对象实例的方法里. 当客户端需要请求对象时, 只需要简单的调用该实例方法而不需要关心对象的创建细节. 要声明通过实例工厂方法创建的 Bean 在 bean 的 factory-bean 属性里指定拥有该工厂方法的 Bean 在 factory-method 属性里指定该工厂方法的名称 使用 construtor-arg 元素为工厂方法传递方法参数1234567891011121314public class CarInstanceFactory &#123; private Map&lt;String,Car&gt; cars; public CarInstanceFactory()&#123; cars = new HashMap&lt;&gt;(); cars.put("AAA", new Car("AAA", "奥迪")); cars.put("BBB", new Car("BBB", "奔驰")); &#125; public Car getInstance(String name)&#123; return cars.get(name); &#125;&#125; 123456789101112131415&lt;beans&gt; &lt;!-- 使用实例工厂方法创建bean 1、先创建实例工厂方法所在类的bean 2、在 bean 的 factory-bean 属性里指定拥有该工厂方法的 Bean 3、在 factory-method 属性里指定该工厂方法的名称 4、使用 construtor-arg 元素为工厂方法传递方法参数 --&gt; &lt;bean class="pers.mrxiexie.spring.factory.CarInstanceFactory" id="instanceFactory"/&gt; &lt;bean id="car1" factory-bean="instanceFactory" factory-method="getInstance"&gt; &lt;constructor-arg name="name" value="BBB"/&gt; &lt;/bean&gt;&lt;/beans&gt; （4）FactoryBean 接口 Spring 中有两种类型的 Bean, 一种是普通Bean, 另一种是工厂Bean, 即FactoryBean. 工厂 Bean 跟普通Bean不同, 其返回的对象不是指定类的一个实例, 其返回的是该工厂 Bean 的 getObject 方法所返回的对象 12345678910111213141516171819202122public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; //返回实例 @Override public Car getObject() throws Exception &#123; Car car2 = new Car("CCC","林肯"); return car2; &#125; //返回类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; //是否单例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 1234&lt;!-- 通过 实现FactoryBean接口创建bean--&gt;&lt;bean id="car2" class="pers.mrxiexie.spring.factory.CarFactoryBean"/&gt; 四、Spring的IOC容器 Spring提供了两种IOC容器的实现分别为 BeanFactory 和 ApplicationContext BeanFactory是基础类型IOC容器，面向Spring本身 ApplicationContext是BeanFactory的子接口，面向Spring框架的开发者 注：几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory （1）ApplicationContext ApplicationContext的主要实现类是 ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext ClassPathXmlApplicationContext：从类路径下加载配置文件 FileSystemXmlApplicationContext：从文件系统中加载配置文件 ConfigurableApplicationContext：扩展于 ApplicationContext，新增加两个主要方法：refresh() 和 close()， 让 ApplicationContext 具有启动、刷新和关闭上下文的能力 WebApplicationContext 是专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作 ApplicationContext 在初始化上下文时就实例化所有单例的 Bean （2）依赖注入的方式 Spring 支持 3 种依赖注入的方式：属性注入、构造器注入和工厂方法注入（很少使用，不推荐） 1、属性注入 属性注入使用 &lt;property&gt; 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 &lt;value&gt;子节点指定属性值 123&lt;bean class="pers.mrxiexie.spring.HelloWorld" id="helloWorld"&gt; &lt;property name="name" value="MrXieXie"/&gt;&lt;/bean&gt; 2、构造方法注入 构造器注入在 元素里声明属性, 中没有 name 属性，按 index 索引或 type 类型入参 12345&lt;bean class="pers.mrxiexie.spring.Car" id="car"&gt; &lt;constructor-arg value="company" index="0"/&gt; &lt;constructor-arg value="brand" index="1"/&gt; &lt;constructor-arg value="1" index="2"/&gt;&lt;/bean&gt; （3）注入属性细节1、字面量 字面值：可用字符串表示的值，可以通过&lt;value&gt;元素标签或 value 属性进行注入 基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式 若字面值中包含特殊字符，可以使用 &lt;![CDATA[]]&gt; 把字面值包裹起来123456&lt;bean class="pers.mrxiexie.spring.Car" id="car3"&gt; ... &lt;constructor-arg&gt; &lt;value&gt;&lt;![CDATA[&lt;ATARZA&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 2、引用其它 Bean 组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能. 要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用 在 Bean 的配置文件中, 可以通过 &lt;ref&gt;元素或 ref 属性为 Bean 的属性或构造器参数指定对 Bean 的引用. 也可以在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean12345678&lt;beans&gt; &lt;bean class="pers.mrxiexie.spring.Car" id="car"&gt; &lt;constructor-arg value="company"/&gt; &lt;/bean&gt; &lt;bean class="pers.mrxiexie.spring.Person" id="person"&gt; &lt;property name="car" ref="car"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、内部 Bean 当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 &lt;property&gt; 或 元素里, 不需要设置任何 id 或 name 属性 内部 Bean 不能使用在任何其他地方1234567&lt;bean class="pers.mrxiexie.spring.Person" id="person2"&gt; &lt;property name="car"&gt; &lt;bean class="pers.mrxiexie.spring.Car"&gt; &lt;constructor-arg value="1" type="float"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 4、注入参数详解：null 值和级联属性 可以使用专用的 &lt;null/&gt; 元素标签为 Bean 的字符串或其它对象类型的属性注入 null 值 和 Struts、Hiberante 等框架一样，Spring 支持级联属性的配置。 12345678&lt;bean class="pers.mrxiexie.spring.Person" id="person3"&gt; &lt;!-- null值 --&gt; &lt;property name="name"&gt;&lt;null/&gt;&lt;/property&gt; &lt;property name="age" value="10"/&gt; &lt;property name="car" ref="car"/&gt; &lt;!-- 级联睡醒 --&gt; &lt;property name="car.company" value="pppppppppp"/&gt;&lt;/bean&gt; 5、集合属性 在 Spring中可以通过一组内置的 xml 标签(例如: &lt;list&gt;, &lt;set&gt; 或 &lt;map&gt;) 来配置集合属性. 配置 java.util.List 类型的属性, 需要指定 &lt;list&gt; 标签, 在标签里包含一些元素. 这些标签可以通过&lt;value&gt; 指定简单的常量值, 通过 &lt;ref&gt; 指定对其他 Bean 的引用. 通过&lt;bean&gt; 指定内置 Bean 定义. 通过 &lt;null/&gt; 指定空元素. 甚至可以内嵌其他集合. 数组的定义和 List 一样, 都使用 &lt;list&gt; 配置 java.util.Set 需要使用 &lt;set&gt; 标签, 定义元素的方法与 List 一样. Java.util.Map 通过 &lt;map&gt; 标签定义, &lt;map&gt; 标签里可以使用多个 &lt;entry&gt; 作为子标签. 每个条目包含一个键和一个值. 必须在 &lt;key&gt; 标签里定义键 因为键和值的类型没有限制, 所以可以自由地为它们指定 &lt;value&gt;, &lt;ref&gt;, &lt;bean&gt; 或 &lt;null&gt; 元素. 可以将 Map 的键和值作为 &lt;entry&gt; 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义 使用 &lt;props&gt; 定义 java.util.Properties, 该标签使用多个 &lt;prop&gt; 作为子标签. 每个 &lt;prop&gt; 标签必须定义 key 属性. 12345678910111213141516171819202122232425262728293031&lt;beans&gt; &lt;bean class="pers.mrxiexie.spring.Person" id="person4"&gt; ... &lt;property name="cars"&gt; &lt;list&gt; &lt;ref bean="car2"/&gt; &lt;ref bean="car3"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- bean 中使用 map --&gt; &lt;bean class="pers.mrxiexie.spring.Person" id="person5"&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="AA" value-ref="car"/&gt; &lt;entry key="BB" value-ref="car2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- bean中使用properties --&gt; &lt;bean class="pers.mrxiexie.spring.DataSource" id="dataSource"&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="user"&gt;user&lt;/prop&gt; &lt;prop key="age"&gt;1&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5、使用 utility scheme 定义集合 使用基本的集合标签定义集合时, 不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合. 可以使用 util schema 里的集合标签定义独立的集合 Bean. 需要注意的是, 必须在 &lt;beans&gt; 根元素里添加 util schema 定义12345&lt;!-- bean 中使用集合 List --&gt;&lt;util:list id="cars"&gt; &lt;ref bean="car2"/&gt; &lt;ref bean="car3"/&gt;&lt;/util:list&gt; 6、使用 p 命名空间 为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。 Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过&lt;bean&gt; 元素属性的方式配置 Bean 的属性。 使用 p 命名空间后，基于 XML 的配置方式将进一步简化12&lt;bean class="pers.mrxiexie.spring.Car" id="car4" p:company="Mr" p:price="100" p:brand="brand" p:maxSpeed="100"/&gt; （4）自动装配1、XML 配置里的 Bean 自动装配 Spring IOC 容器可以自动装配 Bean. 需要做的仅仅是在 &lt;bean&gt; 的 autowire 属性里指定自动装配的模式 byType(根据类型自动装配): 若 IOC 容器中有多个与目标 Bean 类型一致的 Bean. 在这种情况下, Spring 将无法判定哪个 Bean 最合适该属性, 所以不能执行自动装配. byName(根据名称自动装配): 必须将目标 Bean 的名称和属性名设置的完全相同. constructor(通过构造器自动装配): 当 Bean 中存在多个构造器时, 此种自动装配方式将会很复杂. 不推荐使用123456&lt;beans&gt; &lt;!--使用 bean 的 autoWire 属性进行自动装载 byName 通过id装载--&gt; &lt;bean class="pers.mrxiexie.spring.auto.NewPerson" id="person" autowire="byName"/&gt; &lt;!--使用 bean 的 autoWire 属性进行自动装载 byType 通过type装载(若有多个相同类型则会报错)--&gt; &lt;bean class="pers.mrxiexie.spring.auto.NewPerson" id="person2" autowire="byType"/&gt;&lt;/beans&gt; （5）Bean之间的关系：继承和依赖1、继承Bean配置 Spring 允许继承 bean 的配置, 被继承的 bean 称为父 bean. 继承这个父 Bean 的 Bean 称为子 Bean 子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置 子 Bean 也可以覆盖从父 Bean 继承过来的配置 父 Bean 可以作为配置模板, 也可以作为 Bean 实例. 若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt;的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean 并不是 &lt;bean&gt; 元素里的所有属性都会被继承. 比如: autowire, abstract 等. 也可以忽略父 Bean 的 class 属性, 让子 Bean 指定自己的类, 而共享相同的属性配置. 但此时 abstract 必须设为 true123456789101112&lt;beans&gt; &lt;bean class="pers.mrxiexie.spring.Car" id="car1"&gt; &lt;property name="price" value="100"/&gt; &lt;property name="maxSpeed" value="100"/&gt; &lt;property name="brand" value="brand"/&gt; &lt;property name="company" value="company"/&gt; &lt;/bean&gt; &lt;bean id="car2" parent="car1"&gt; &lt;property name="maxSpeed" value="10000"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2、依赖 Bean 配置 Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，前置依赖的 Bean 会在本 Bean 实例化之前创建好 如果前置依赖于多个 Bean，则可以通过逗号，空格或的方式配置 Bean 的名称123456789101112&lt;!-- bean 的依赖，Spring 允许用户通过 depends-on 属性设定 Bean 前置依赖的Bean，前置依赖的 Bean 会在本 Bean 实例化之前创建好 初始化顺序 car4 -&gt; car3--&gt;&lt;beans&gt; &lt;bean id="car3" parent="car1" depends-on="car4"&gt; &lt;property name="company" value="car3"/&gt; &lt;/bean&gt; &lt;bean id="car4" parent="car1"&gt; &lt;property name="company" value="car4"/&gt; &lt;/bean&gt;&lt;/beans&gt; （6）Bean 的作用域 Bean的作用域有四种，分别为：singleton、prototype、request 和 session 在 Spring 中, 可以在 &lt;bean&gt; 元素的 scope 属性里设置 Bean 的作用域. 默认情况下, Spring 只为每个在 IOC 容器里声明的 Bean 创建唯一一个实例, 整个 IOC 容器范围内都能共享该实例：所有后续的 getBean() 调用和 Bean 引用都将返回这个唯一的 Bean 实例.该作用域被称为 singleton, 它是所有 Bean 的默认作用域. 类别 说明 singleton 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在 prototype 每次调用getBean() 时都会返回一个新的实例 request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HttpSession共享一个Bean，不同的HTTP Session使用不同的Bean，该作用域仅适用于WebApplicationContext环境 （7）使用外部属性文件 在配置文件里配置 Bean 时, 有时需要在 Bean 的配置里混入系统部署的细节信息(例如: 文件路径, 数据源配置信息等). 而这些部署细节实际上需要和 Bean 配置相分离 Spring 提供了一个 PropertyPlaceholderConfigurer 的 BeanFactory 后置处理器, 这个处理器允许用户将 Bean 配置的部分内容外移到属性文件中. 可以在 Bean 配置文件里使用形式为 ${var} 的变量, PropertyPlaceholderConfigurer 从属性文件里加载属性, 并使用这些属性来替换变量. Spring 还允许在属性文件中使用 ${propName}，以实现属性之间的相互引用。 Spring 2.5 之后: 可通过 context:property-placeholder 元素简化:&lt;beans&gt; 中添加 context Schema 定义在配置文件中加入如下配置:12345678910111213&lt;beans&gt; &lt;!-- 使用外部配置文件，可以在 Bean 配置文件里使用形式为 $&#123;var&#125; 的变量 --&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt; &lt;bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="source"&gt; &lt;property name="driverClass" value="$&#123;driver&#125;"/&gt; &lt;property name="user" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;url&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; （8）Spring表达式语言：SpEL Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL SpEL 为 bean 的属性进行动态赋值提供了便利 通过 SpEL 可以实现： 通过 bean 的 id 对 bean 进行引用 调用方法以及引用对象中的属性 计算表达式的值 正则表达式的匹配 1、字面量 整数：&lt;property name=&quot;count&quot; value=&quot;#{5}&quot;/&gt; 小数：&lt;property name=&quot;frequency&quot; value=&quot;#{89.7}&quot;/&gt; 科学计数法：&lt;property name=&quot;capacity&quot; value=&quot;#{1e4}&quot;/&gt; String可以使用单引号或者双引号作为字符串的定界符号：&lt;property name=“name” value=&quot;#{&#39;Chuck&#39;}&quot;/&gt; 或 &lt;property name=&#39;name&#39; value=&#39;#{&quot;Chuck&quot;}&#39;/&gt; Boolean：&lt;property name=&quot;enabled&quot; value=&quot;#{false}&quot;/&gt; 2、引用 Bean、属性和方法 引用其他对象&lt;property name=&quot;car&quot; ref=&quot;#{car}&quot;/&gt; 引用其他对象的属性&lt;property name=&quot;carName&quot; value=&quot;#{car.name}&quot;/&gt; 调用其他方法，还可以链式操作&lt;property name=&quot;carName&quot; value=&quot;#{car.toString()}&quot;/&gt; 调用静态方法或静态属性&lt;property name=&quot;price&quot; value=&quot;#{T(Math).random() != 0 ? 100000.0 : 0.0 } &quot;/&gt; 3、运算符号 算数运算符：+, -, *, /, %, ^： 加号还可以用作字符串连接： 比较运算符： &lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算符号： and, or, not, | if-else 运算符：?: (ternary), ?: (Elvis) if-else 的变体 正则表达式：matches （9）IOC 容器中 Bean 的生命周期方法 Spring IOC 容器可以管理 Bean 的生命周期, Spring 允许在 Bean 生命周期的特定点执行定制的任务. Spring IOC 容器对 Bean 的生命周期进行管理的过程: 通过构造器或工厂方法创建 Bean 实例 为 Bean 的属性设置值和对其他 Bean 的引用 调用 Bean 的初始化方法 Bean 可以使用了 当容器关闭时, 调用 Bean 的销毁方法 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法. 12345&lt;!-- 在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.--&gt;&lt;bean class="pers.mrxiexie.spring.life.Person" id="person" p:name="MrXieXie" init-method="init" destroy-method="destroy"/&gt; 创建 Bean 后置处理器 Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理. Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性. 对Bean 后置处理器而言, 需要实现接口. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:123456789101112public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125;&#125; 添加 Bean 后置处理器后 Bean 的生命周期，Spring IOC 容器对 Bean 的生命周期进行管理的过程: 通过构造器或工厂方法创建 Bean 实例 为 Bean 的属性设置值和对其他 Bean 的引用 将 Bean 实例传递给 Bean 后置处理器的 postProcessBeforeInitialization 方法 调用 Bean 的初始化方法 将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法 Bean 可以使用了 当容器关闭时, 调用 Bean 的销毁方法 五、在 Spring 的 IOC 容器里配置 Bean(Annotation)（1）在 classpath 中扫描组件 组件扫描(component scanning): Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件. 特定组件包括: @Component: 基本注解, 标识了一个受 Spring 管理的组件 @Respository: 标识持久层组件 @Service: 标识服务层(业务层)组件 @Controller: 标识表现层组件 对于扫描到的组件, Spring 有默认的命名策略: 使用非限定类名, 第一个字母小写. 也可以在注解中通过 value 属性值标识组件的名称 当在组件类上使用了特定的注解之后, 还需要在 Spring 的配置文件中声明 context:component-scan ： base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类. 当需要扫描多个包时, 可以使用逗号分隔. 如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类， context:include-filter 子节点表示要包含的目标类 context:exclude-filter 子节点表示要排除在外的目标类 context:component-scan 下可以拥有若干个 context:include-filter 和 context:exclude-filter 子节点1234567891011&lt;context:component-scan base-package="pers.mrxiexie.spring.annotation"&gt; &lt;!-- 不扫描特定注解 --&gt; &lt;!--&lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt;--&gt; &lt;!-- 不扫描特定包名 --&gt; &lt;!--&lt;context:exclude-filter type="assignable" expression="pers.mrxiexie.spring.annotation.controller.UserController"/&gt;--&gt;&lt;/context:component-scan&gt; （2）组件装配 context:component-scan 元素还会自动注册 AutowiredAnnotationBeanPostProcessor 实例, 该实例可以自动装配具有 @Autowired 和 @Resource 、@Inject注解的属性. （3）使用 @Autowired 自动装配 Bean @Autowired 注解自动装配具有兼容类型的单个 Bean属性 构造器, 普通字段(即使是非 public), 一切具有参数的方法都可以应用@Authwired 注解 默认情况下, 所有使用 @Authwired 注解的属性都需要被设置. 当 Spring 找不到匹配的 Bean 装配属性时, 会抛出异常, 若某一属性允许不被设置, 可以设置 @Authwired 注解的 required 属性为 false 默认情况下, 当 IOC 容器里存在多个类型兼容的 Bean 时, 通过类型的自动装配将无法工作. 此时可以在 @Qualifier 注解里提供 Bean 的名称. Spring 允许对方法的入参标注 @Qualifiter 已指定注入 Bean 的名称@Authwired 注解也可以应用在数组类型的属性上, 此时 Spring 将会把所有匹配的 Bean 进行自动装配. @Authwired 注解也可以应用在集合属性上, 此时 Spring 读取该集合的类型信息, 然后自动装配所有与之兼容的 Bean. @Authwired 注解用在 java.util.Map 上时, 若该 Map 的键值为 String, 那么 Spring 将自动装配与之 Map 值类型兼容的 Bean, 此时 Bean 的名称作为键值 （4）使用 @Resource 或 @Inject 自动装配 Bean Spring 还支持 @Resource 和 @Inject 注解，这两个注解和 @Autowired 注解的功用类似 @Resource 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称 @Inject 和 @Autowired 注解一样也是按类型匹配注入的 Bean， 但没有 reqired 属性 建议使用 @Autowired 注解 五、泛型依赖注入Spring 4.x 中可以为子类注入子类对应的泛型类型的成员变量的引用 看 package pers.mrxiexie.spring.annotation.generic下的示例 六、整合多个资源文件 Spring 允许通过 &lt;import&gt; 将多个配置文件引入到一个文件中，进行配置文件的集成。这样在启动 Spring 容器时，仅需要指定这个合并好的配置文件就可以。 import 元素的 resource 属性支持 Spring 的标准的路径资源 地址前缀 示例 对应资源类型 classpath: classpath:spring-mvc.xml 从类路径下加载资源，classpath:和classpath:/是等价的 file: file:/conf/security/spring-shiro.xml 从文件系统目录中装载资源，可采用绝对或相对路径 http:// http://www.atguigu.com/resource/beans.xml 从WEB服务器中加载资源 ftp:// ftp://www.atguigu.com/resource/bean.xml 从FTP服务器中加载资源 七、Spring AOP代码示例：123456789101112131415@Overridepublic int add(int x, int y) &#123; System.out.println("method add begin x = " + x + " y = " + y); int result = x + y; System.out.println("result : " + result); return result;&#125;@Overridepublic int sub(int x, int y) &#123; System.out.println("method sub begin x = " + x + " y = " + y); int result = x - y; System.out.println("result : " + result); return result;&#125; 问题 代码混乱：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀. 每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点. 代码分散: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 必须修改所有模块. 使用动态代理解决上述问题 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上. 1、 创建代理类 1234567891011121314151617181920212223public class ArithmeticCalculatorLoggingProxy &#123; private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy() &#123; Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; ArithmeticCalculator proxy = (ArithmeticCalculator) Proxy.newProxyInstance(target.getClass().getClassLoader(), interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("mehod " + method.getName() + " begin x = " + args[0] + " y = " + args[1]); Object result = method.invoke(target,args); System.out.println("result : " + result); return result; &#125; &#125;); return proxy; &#125;&#125; 2、 测试12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArithmeticCalculator calculator = null; calculator = new ArithmeticCalculatorLoggingImpl(); ArithmeticCalculatorLoggingProxy proxy = new ArithmeticCalculatorLoggingProxy(calculator); calculator = proxy.getLoggingProxy(); int result = calculator.add(1, 2); System.out.println(result); result = calculator.div(4, 2); System.out.println(result); &#125;&#125; （1）AOP 简介 AOP(Aspect-Oriented Programming, 面向切面编程): 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点. 在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里. AOP 的好处: 每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级 业务模块更简洁, 只包含核心业务代码. （2）AOP 术语 切面(Aspect): 横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象 通知(Advice): 切面必须要完成的工作 目标(Target): 被通知的对象 代理(Proxy): 向目标对象应用通知之后创建的对象 连接点（Joinpoint）：程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置 切点（pointcut）：每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 （3）用 AspectJ 注解声明切面 AspectJ：Java 社区里最完整最流行的 AOP 框架. 在 Spring2.0 以上版本中, 可以使用基于 AspectJ 注解或基于 XML 配置的 AOP 要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理. 在 AspectJ 注解中, 切面只是一个带有 @Aspect 注解的 Java 类. 通知是标注有某种注解的简单的 Java 方法. AspectJ 支持 5 种类型的通知注解: @Before: 前置通知, 在方法执行之前执行 @After: 后置通知, 在方法执行之后执行 @AfterRunning: 返回通知, 在方法返回结果之后执行 @AfterThrowing: 异常通知, 在方法抛出异常之后 @Around: 环绕通知, 围绕着方法执行 （4）利用方法签名编写 AspectJ 切入点表达式 最典型的切入点表达式时根据方法的签名来匹配各种方法: execution com.atguigu.spring.ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 中声明的所有方法,第一个 代表任意修饰符及任意返回值. 第二个 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名. execution public ArithmeticCalculator.(..): 匹配 ArithmeticCalculator 接口的所有公有方法. execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法 execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数 execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法. 在 AspectJ 中, 切入点表达式可以通过操作符 &amp;&amp;, ||, ! 结合起来. （5）让通知访问当前连接点的细节可以在通知方法中声明一个类型为 JoinPoint 的参数. 然后就能访问链接细节. 如方法名称和参数值. 1、前置通知 @Before 前置通知:在方法执行之前执行的通知 前置通知使用 @Before 注解, 并将切入点表达式的值作为注解值. 2、后置通知 @After 后置通知是在连接点完成之后执行的, 即连接点返回结果或者抛出异常的时候, 下面的后置通知记录了方法的终止. 一个切面可以包括一个或者多个通知. 3、返回通知 @AfterRunning 无论连接点是正常返回还是抛出异常, 后置通知都会执行 如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知. 4、在返回通知中访问连接点的返回值 在返回通知中, 只要将 returning 属性添加到 @AfterReturning 注解中, 就可以访问连接点的返回值. 该属性的值即为用来传入返回值的参数名称. 必须在通知方法的签名中添加一个同名参数. 在运行时, Spring AOP 会通过这个参数传递返回值.原始的切点表达式需要出现在 pointcut 属性中 5、异常通知 只在连接点抛出异常时才执行异常通知 将 throwing 属性添加到 @AfterThrowing 注解中, 也可以访问连接点抛出的异常. Throwable 是所有错误和异常类的超类. 所以在异常通知方法可以捕获到任何错误和异常. 如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就只在抛出这个类型及其子类的异常时才被执行. 6、环绕通知 环绕通知是所有通知类型中功能最为强大的, 能够全面地控制连接点. 甚至可以控制是否执行连接点.对于环绕通知来说, 连接点的参数类型必须是 ProceedingJoinPoint . 它是 JoinPoint 的子接口, 允许控制何时执行, 是否执行连接点. 在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed() 方法来执行被代理的方法. 如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行. 注意: 环绕通知的方法需要返回目标方法执行之后的结果, 即调用 joinPoint.proceed(); 的返回值, 否则会出现空指针异常 （6）指定切面的优先级 在同一个连接点上应用不止一个切面时, 除非明确指定, 否则它们的优先级是不确定的. 切面的优先级可以通过实现 Ordered 接口或利用 @Order 注解指定. 实现 Ordered 接口, getOrder() 方法的返回值越小, 优先级越高. 若使用 @Order 注解, 序号出现在注解中 （7）重用切入点定义 在编写 AspectJ 切面时, 可以直接在通知注解中书写切入点表达式. 但同一个切点表达式可能会在多个通知中重复出现. 在 AspectJ 切面中, 可以通过 @Pointcut 注解将一个切入点声明成简单的方法. 切入点的方法体通常是空的, 因为将切入点定义与应用程序逻辑混在一起是不合理的. 切入点方法的访问控制符同时也控制着这个切入点的可见性. 如果切入点要在多个切面中共用, 最好将它们集中在一个公共的类中. 在这种情况下, 它们必须被声明为 public. 在引入这个切入点时, 必须将类名也包括在内. 如果类没有与这个切面放在同一个包中, 还必须包含包名. 其他通知可以通过方法名称引入该切入点. （8）代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * order数字越小，切面优先级越高 */@Order(2)@Aspect@Componentpublic class LoggingAspect &#123; /** * 定义一个方法，用于声明切入点表达式 * 使用@PointCut来声明切入点表达式 * 后面的其他通知直接使用方法名来应用当前切入点表达式 */ @Pointcut(value = "execution(public int pers.mrxiexie.spring.aop.ArithmeticCalculator.*(int, int))") public void declareJoinPointExpression() &#123; &#125; /** * 前置通知 */ @Before(value = "declareJoinPointExpression()") public void before(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); System.out.println("method " + methodName + " begin " + args); &#125; /** * 后置通知，无论是否出现异常都会执行 */ @After(value = "declareJoinPointExpression()") public void after(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); System.out.println("method " + methodName + " end"); &#125; /** * 后置通知带返回值，出现异常则不会执行 */ @AfterReturning(value = "declareJoinPointExpression()", returning = "result") public void afterReturning(JoinPoint joinPoint, Object result) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println("method " + methodName + " end with " + result); &#125; /** * 出现异常执行 * @param ex 执行对应的Exception */ @AfterThrowing(value = "declareJoinPointExpression()", throwing = "ex") public void exception(JoinPoint joinPoint, Exception ex) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println("method " + methodName + " occur exception : " + ex); &#125; /** * 环绕通知需要携带 ProceedingJoinPoint 类型的参数. * 环绕通知类似于动态代理的全过程: ProceedingJoinPoint 类型的参数可以决定是否执行目标方法. * 且环绕通知必须有返回值, 返回值即为目标方法的返回值 */ @Around(value = "declareJoinPointExpression()") public Object around(ProceedingJoinPoint proceedingJoinPoint) &#123; String methodName = proceedingJoinPoint.getSignature().getName(); Object[] args = proceedingJoinPoint.getArgs(); Object result = null; try &#123; //前置通知 System.out.println("method " + methodName + " begin " + args); result = proceedingJoinPoint.proceed(); //返回通知 System.out.println("method " + methodName + " end with " + result); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); //异常通知 System.out.println("method " + methodName + " occur exception : " + throwable); &#125; //后置通知 System.out.println("method " + methodName + " end"); return result; &#125;&#125; （9）用基于 XML 的配置声明切面//TODO 详情看ppt 八、Spring JDBC（1）JdbcTemplate 简介 为了使 JDBC 更加易于使用, Spring 在 JDBC API 上定义了一个抽象层, 以此建立一个 JDBC 存取框架. 作为 Spring JDBC 框架的核心, JDBC 模板的设计目的是为不同类型的 JDBC 操作提供模板方法. 每个模板方法都能控制整个过程, 并允许覆盖过程中的特定任务. 通过这种方式, 可以在尽可能保留灵活性的情况下, 将数据库存取的工作量降到最低. （2）JdbcTemplate的使用1、更新1234@Overridepublic int update(String sql, Object... args) throws DataAccessException &#123; return update(sql, newArgPreparedStatementSetter(args));&#125; 2、批量更新1234@Overridepublic int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs) throws DataAccessException &#123; return batchUpdate(sql, batchArgs, new int[0]);&#125; 3、查询单行12345@Overridepublic &lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args) throws DataAccessException &#123; List&lt;T&gt; results = query(sql, args, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper, 1)); return DataAccessUtils.requiredSingleResult(results);&#125; 4、查询多行1234@Overridepublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args) throws DataAccessException &#123; return query(sql, args, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));&#125; 5、单值查询12345@Overridepublic &lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123; List&lt;T&gt; results = query(sql, rowMapper); return DataAccessUtils.requiredSingleResult(results);&#125; （3）简化 JDBC 模板查询 每次使用都创建一个 JdbcTemplate 的新实例, 这种做法效率很低下. JdbcTemplate 类被设计成为线程安全的, 所以可以再 IOC 容器中声明它的单个实例, 并将这个实例注入到所有的 DAO 实例中. JdbcTemplate 也利用了 Java 1.5 的特定(自动装箱, 泛型, 可变长度等)来简化开发 Spring JDBC 框架还提供了一个 JdbcDaoSupport 类来简化 DAO 实现. 该类声明了 jdbcTemplate 属性, 它可以从 IOC 容器中注入, 或者自动从数据源中创建. （4）注入 JDBC 模板示例代码1234567891011121314151617&lt;!-- 导入资源文件 --&gt;&lt;context:property-placeholder location="jdbc.properties" /&gt;&lt;!-- 配置 C3P0 数据源 --&gt;&lt;bean class="com.mchange.v2.c3p0.ComboPooledDataSource" id="dataSource"&gt; &lt;property name="user" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbcUrl&#125;" /&gt; &lt;property name="driverClass" value="$&#123;driver&#125;" /&gt; &lt;property name="initialPoolSize" value="$&#123;initialPoolSize&#125;"/&gt; &lt;property name="maxPoolSize" value="$&#123;maxPoolSize&#125;"/&gt;&lt;/bean&gt;&lt;!-- 配置 Spirng 的 JdbcTemplate --&gt;&lt;bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; （5）在 JDBC 模板中使用具名参数 在经典的 JDBC 用法中, SQL 参数是用占位符 ? 表示,并且受到位置的限制. 定位参数的问题在于, 一旦参数的顺序发生变化, 就必须改变参数绑定. 在 Spring JDBC 框架中, 绑定 SQL 参数的另一种选择是使用具名参数(named parameter). 具名参数: SQL 按名称(以冒号开头)而不是按位置进行指定. 具名参数更易于维护, 也提升了可读性. 具名参数由框架类在运行时用占位符取代 具名参数只在 NamedParameterJdbcTemplate 中得到支持 （6）在 JDBC 模板中使用具名参数 在 SQL 语句中使用具名参数时, 可以在一个 Map 中提供参数值, 参数名为键 也可以使用 SqlParameterSource 参数 批量更新时可以提供 Map 或 SqlParameterSource 的数组 1234&lt;!-- 配置 spring 的 NamedParameterJdbcTemplate 可以给占位符命名 --&gt;&lt;bean class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate" id="namedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"/&gt;&lt;/bean&gt; 123456789101112131415161718192021222324252627282930/** * 使用具名参数时, 可以使用 update(String sql, SqlParameterSource paramSource) 方法进行更新操作 * 1. SQL 语句中的参数名和类的属性一致! * 2. 使用 SqlParameterSource 的 BeanPropertySqlParameterSource 实现类作为参数. */@Testpublic void testNamedParameterJdbcTemplate2() &#123; String sql = "insert into `user` (name, address) values (:name, :address)"; User user = new User(); user.setName("MrXieXie"); user.setAddress("address!!!"); SqlParameterSource sqlParameterSource = new BeanPropertySqlParameterSource(user); namedParameterJdbcTemplate.update(sql, sqlParameterSource);&#125;/** * 可以为参数起名字 * 1、好处：若有多个参数，则不用再去对应位置，直接对应参数名，便于维护 * 2、缺点：较为麻烦 */@Testpublic void testNamedParameterJdbcTemplate() &#123; String sql = "insert into `user` (name, address) values (:name, :address)"; Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put("name", "MrXieXie"); params.put("address", "address"); namedParameterJdbcTemplate.update(sql, params);&#125; 九、Spring 事务管理（1）事务简介 事务管理是企业级应用程序开发中必不可少的技术, 用来确保数据的完整性和一致性. 事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用 事务的四个关键属性(ACID) 原子性(atomicity): 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用. 一致性(consistency): 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中. 隔离性(isolation): 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏. 持久性(durability): 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中. （2）Spring 中的事务管理 作为企业级应用程序框架, Spring 在不同的事务管理 API 之上定义了一个抽象层. 而应用程序开发人员不必了解底层的事务管理 API, 就可以使用 Spring 的事务管理机制. Spring 既支持编程式事务管理, 也支持声明式的事务管理. 编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚. 在编程式管理事务时, 必须在每个事务操作中包含额外的事务管理代码. 声明式事务管理: 大多数情况下比编程式事务管理更好用. 它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理. 事务管理作为一种横切关注点, 可以通过 AOP 方法模块化. Spring 通过 Spring AOP 框架支持声明式事务管理. （3）Spring 中的事务管理器 PlatformTransactionManager Spring 从不同的事务管理 API 中抽象了一整套的事务机制. 开发人员不必了解底层的事务 API, 就可以利用这些事务机制. 有了这些事务机制, 事务管理代码就能独立于特定的事务技术了. Spring 的核心事务管理抽象是 public interface PlatformTransactionManager 它为事务管理封装了一组独立于技术的方法. 无论使用 Spring 的哪种事务管理策略(编程式或声明式), 事务管理器都是必须的. （4）Spring 中的事务管理器的不同实现 DataSourceTransactionManager：在应用程序中只需要处理一个数据源, 而且通过 JDBC 存取 JtaTransactionManager：在 JavaEE 应用服务器上用 JTA(Java Transaction API) 进行事务管理 HibernateTransactionManager：用 Hibernate 框架存取数据库 …… 事务管理器以普通的 Bean 形式声明在 Spring IOC 容器中1234&lt;!-- 配置事务管理器 --&gt;&lt;bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="transactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; （5）用 @Transactional 注解声明式地管理事务 除了在带有切入点, 通知和增强器的 Bean 配置文件中声明事务外, Spring 还允许简单地用 @Transactional 注解来标注事务方法. 为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解. 根据 Spring AOP 基于代理机制, 只能标注公有方法. 可以在方法或者类级别上添加 @Transactional 注解. 当把这个注解应用到类上时, 这个类中的所有公共方法都会被定义成支持事务处理的. 在 Bean 配置文件中只需要启用 tx:annotation-driven 元素, 并为之指定事务管理器就可以了. 如果事务处理器的名称是 transactionManager, 就可以在tx:annotation-driven 元素中省略 transaction-manager 属性. 这个元素会自动检测该名称的事务处理器. 12&lt;!-- 启用事务注解 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; （6）事务传播属性 当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播. 例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行. 事务的传播行为可以由传播属性指定. Spring 定义了 7 种类传播行为. 传播属性 描述 REQUIRED 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 REQUIRED_NEW 当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务在运行，应该将它挂起 SUPPORTS 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中 NOT_SUPPORTED 当前的方法不应该运行在事务中，如果有运行的事务，则将它挂起 MANDATORY 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 NEVER 当前的方法不应该运行在事务中，如果有运行的事务，则抛出异常 NESTED 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 12345@Transactional(propagation = Propagation.REQUIRED)@Overridepublic void checkout(String username, List&lt;Long&gt; ids) &#123; ids.forEach(aLong -&gt; bookShopService.purchase(username, aLong));&#125; （7）并发事务所导致的问题 当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时, 可能会出现许多意外的问题 并发事务所导致的问题可以分为下面三种类型: 脏读: 对于两个事物 T1, T2, T1 读取了已经被 T2 更新但 还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的. 不可重复读:对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. 幻读:对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. （8）事务的隔离级别 从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题. 然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行. 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行. 事务的隔离级别可以通过隔离事务属性指定 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 （9）设置隔离事务属性 用 @Transactional 注解声明式地管理事务时可以在 @Transactional 的 isolation 属性中设置隔离级别. 12345@Transactional(isolation = Isolation.READ_COMMITTED)@Overridepublic void checkout(String username, List&lt;Long&gt; ids) &#123; ids.forEach(aLong -&gt; bookShopService.purchase(username, aLong));&#125; （10）设置回滚事务属性 默认情况下只有未检查异常(RuntimeException和Error类型的异常)会导致事务回滚. 而受检查异常不会. 事务的回滚规则可以通过 @Transactional 注解的 rollbackFor 和 noRollbackFor 属性来定义. 这两个属性被声明为 Class[] 类型的, 因此可以为这两个属性指定多个异常类. rollbackFor: 遇到时必须进行回滚 noRollbackFor: 一组异常类，遇到时必须不回滚12345@Transactional(rollbackFor = &#123;IOException.class&#125;)@Overridepublic void checkout(String username, List&lt;Long&gt; ids) &#123; ids.forEach(aLong -&gt; bookShopService.purchase(username, aLong));&#125; （11）设置超时和只读属性 由于事务可以在行和表上获得锁, 因此长事务会占用资源, 并对整体性能产生影响. 如果一个事物只读取数据但不做修改, 数据库引擎可以对这个事务进行优化. 超时事务属性: 事务在强制回滚之前可以保持多久. 这样可以防止长期运行的事务占用资源. 只读事务属性: 表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务.12345@Transactional(timeout = 1, readOnly = true)@Overridepublic void checkout(String username, List&lt;Long&gt; ids) &#123; ids.forEach(aLong -&gt; bookShopService.purchase(username, aLong));&#125; 十、Spring 如何在 WEB 应用中使用 ?1). 需要额外加入的 jar 包: spring-web-4.0.0.RELEASE.jarspring-webmvc-4.0.0.RELEASE.jar 2). Spring 的配置文件, 没有什么不同 3). 如何创建 IOC 容器 ? ①. 非 WEB 应用在 main 方法中直接创建②. 应该在 WEB 应用被服务器加载时就创建 IOC 容器: 在 ServletContextListener#contextInitialized(ServletContextEvent sce) 方法中创建 IOC 容器. ③. 在 WEB 应用的其他组件中如何来访问 IOC 容器呢 ? 在 ServletContextListener#contextInitialized(ServletContextEvent sce) 方法中创建 IOC 容器后, 可以把其放在ServletContext(即 application 域)的一个属性中. ④. 实际上, Spring 配置文件的名字和位置应该也是可配置的! 将其配置到当前 WEB 应用的初始化参数中较为合适. 4). 在 WEB 环境下使用 Spring ①. 需要额外加入的 jar 包: spring-web-4.0.0.RELEASE.jarspring-webmvc-4.0.0.RELEASE.jar ②. Spring 的配置文件, 和非 WEB 环境没有什么不同 ③. 需要在 web.xml 文件中加入如下配置: 12345678910&lt;!-- 配置 Spring 配置文件的名称和位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 启动 IOC 容器的 ServletContextListener --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记]]></title>
    <url>%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、MyBatis简介 MyBatis 是支持定制化 SQL、存储过程以及高级 映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设 置参数以及获取结果集。 MyBatis可以使用简单的XML或注解用于配置和原 始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 （1）为什么使用MyBatis MyBatis是一个半自动化的持久化层框架 JDBC SQL夹在Java代码块里，耦合度高导致硬编码内伤 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 Hibernate和JPA 长难复杂SQL，对于Hibernate而言处理也不容易 内部自动生产的SQL，不容易做特殊优化。 基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。 导致数据库性能下降。 对开发人员而言，核心sql还是需要自己优化 sql和java编码分开，功能边界清晰，一个专注业务、 一个专注数据。 二、MyBatis-HelloWorld（1）创建MyBatis全局配置文件 MyBatis 的全局配置文件包含了影响 MyBatis 行为甚深 的设置（settings）和属性（properties）信息、如数据库连接池信息等。指导着MyBatis进行工作。我们可以参照官方文件的配置示例。 mybatis-config.xml如下 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt; &lt;mappers&gt; &lt;mapper resource="conf/EmployeeMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; （2）创建SQL映射文件 映射文件的作用就相当于是定义Dao接口的实现类如何工作。这也是我们使用MyBatis时编写的最多的文件。 EmployeeMapper.xml如下 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:名称空间;指定为接口的全类名 id：唯一标识 resultType：返回值类型 #&#123;id&#125;：从传递过来的参数中取出id值 public Employee selectEmployee(Integer id); --&gt;&lt;mapper namespace="pers.mrxiexie.mybatis.mapper.EmployeeMapper"&gt; &lt;select id="selectEmployee" resultType="pers.mrxiexie.mybatis.beans.Employee"&gt; select id, last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （3）测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 1、接口式编程 * 原生： Dao ====&gt; DaoImpl * mybatis： Mapper ====&gt; xxMapper.xml * * 2、SqlSession代表和数据库的一次会话；用完必须关闭； * 3、SqlSession和connection一样她都是非线程安全。每次使用都应该去获取新的对象。 * 4、mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。 * （将接口和xml进行绑定） * EmployeeMapper empMapper = sqlSession.getMapper(EmployeeMapper.class); * 5、两个重要的配置文件： * mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等...系统运行环境信息 * sql映射文件：保存了每一个sql语句的映射信息： * 将sql抽取出来。 */public class HelloWorld &#123; public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = "conf/mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; /** * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息 * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。 * 3、将sql映射文件注册在全局配置文件中 * 4、写代码： * 1）、根据全局配置文件得到SqlSessionFactory； * 2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查 * 一个sqlSession就是代表和数据库的一次会话，用完关闭 * 3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。 */ @Test public void test() throws IOException &#123; // 2、获取sqlSession实例，能直接执行已经映射的sql语句 // sql的唯一标识：statement Unique identifier matching the statement to use. // 执行sql要用的参数：parameter A parameter object to pass to the statement. String resource = "conf/mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = null; try &#123; sqlSession = sqlSessionFactory.openSession(); Employee employee = sqlSession.selectOne("selectEmployee", 2); System.out.println(employee); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; @Test public void test1() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession sqlSession = sqlSessionFactory.openSession(); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); System.out.println(employeeMapper.getClass()); Employee employee = employeeMapper.selectEmployee(2); System.out.println(employee); sqlSession.close(); &#125;&#125; 三、MyBatis配置文件==待续==]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现跳转的方法]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、小程序页面跳转（js实现） wx.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 举个栗子：A页面跳转B页面，B页面调用wx.navigateBack返回A页面 123456//A页面wx.navigateTo(&#123; url: 'B'&#125;)//B页面wx.navigateBack(); wx.redirectTo(OBJECT) 关闭当前页面，跳转到应用内的某个页面。 举个例子：A页面跳转B页面并关闭A页面，B页面上不会又返回箭头 1234//A页面wx.redirectTo(&#123; url: 'B'&#125;) wx.reLaunch(OBJECT) 关闭所有页面，打开到应用内的某个页面。 举个栗子：A页面跳转B页面关闭所有页面 123wx.reLaunch(&#123; url: 'B'&#125;) wx.switchTab(OBJECT) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。 举个栗子：A页面跳转到B页面（tabBar） 123wx.switchTab(&#123; url: 'B'&#125;) wx.navigateBack(OBJECT) 关闭当前页面，返回上一页面或多级页面。可通过getCurrentPages()获取当前的页面栈，决定需要返回几层。 举个栗子：A页面跳转B页面，B页面跳转C页面，C页面返回A页面 12345678910111213141516//A页面wx.navigateTo(&#123; url: 'B'&#125;)//B页面wx.navigateTo(&#123; url: 'B'&#125;)//C页面var pages = getCurrentPages();//获取当前页栈for(var i = 0; i &lt; pages.length; i++)&#123; console.log(pages[i].route); //打印页栈路由&#125;wx.navigateBack(&#123; delta: 2 //返回两层，返回A页面，若大于页面数则返回首页&#125;); 注意：wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面 二、小程序页面跳转（wxml实现）1234567&lt;!-- sample.wxml --&gt;&lt;view class="btn-area"&gt; &lt;navigator url="/page/navigate/navigate?title=navigate" hover-class="navigator-hover"&gt;跳转到新页面&lt;/navigator&gt; &lt;navigator url="../../redirect/redirect/redirect?title=redirect" open-type="redirect" hover-class="other-navigator-hover"&gt;在当前页打开&lt;/navigator&gt; &lt;navigator url="/page/index/index" open-type="switchTab" hover-class="other-navigator-hover"&gt;切换 Tab&lt;/navigator&gt; &lt;navigator target="miniProgram" open-type="navigate" app-id="" path="" extra-data="" version="release"&gt;打开绑定的小程序&lt;/navigator&gt;&lt;/view&gt; ==待续小程序间跳转==]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蜜糖公寓小程序二次开发]]></title>
    <url>%2F%E8%9C%9C%E7%B3%96%E5%85%AC%E5%AF%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>微容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、文字示例： 1234this is *italic* and this is **bold** . another _italic_ and another __bold__this is `important` text. and percentage signs : % and `%`This is a paragraph with a footnote (builtin parser only). [^note-id]Insert `[ TOC ]` without spaces to generate a table of contents (builtin parsers only). 效果： this is italic and this is bold . another italic and another bold this is important text. and percentage signs : % and % This is a paragraph with a footnote (builtin parser only). [^note-id] Insert [ TOC ] without spaces to generate a table of contents (builtin parsers only). 二、引用示例： 12&gt; Here is some indented text&gt; &gt; even more indented 效果： Here is some indented text even more indented 三、标题示例： 123456# Big title (h1)## Middle title (h2)### Smaller title (h3)#### and so on (hX)##### and so on (hX)###### and so on (hX) 效果： Big title (h1) Middle title (h2) Smaller title (h3) and so on (hX) and so on (hX) and so on (hX) 四、列表示例： 1234567891011- bullets can be `-`, `+`, or `*`- bullet list 1- bullet list 2 - sub item 1 - sub item 2 with indented text inside- bullet list 3+ bullet list 4* bullet list 5 效果： bullets can be -, +, or * bullet list 1 bullet list 2 sub item 1 sub item 2 with indented text inside bullet list 3 bullet list 4 bullet list 5 五、链接示例： 123This is an [example inline link](http://lmgtfy.com/) and [another one with a title](http://lmgtfy.com/ "Hello, world").Links can also be reference based : [reference 1][ref1] or [reference 2 with title][ref2].References are usually placed at the bottom of the document 效果： This is an example inline link and another one with a title. Links can also be reference based : [reference 1][ref1] or [reference 2 with title][ref2]. References are usually placed at the bottom of the document 六、图像示例： 12345A sample image :![song](https://md.mrxiexie.cn/song/180731/1H7LLFFcID.jpg "song")As links, images can also use references instead of inline links :![song][song][song]: https://md.mrxiexie.cn/song/180731/1H7LLFFcID.jpg "song" 效果： A sample image : As links, images can also use references instead of inline links : 七、代码示例： 12345···html&lt;script&gt; document.location = 'http://lmgtfy.com/?q=markdown+cheat+sheet';&lt;/script&gt;··· 效果： 123&lt;script&gt; document.location = 'http://lmgtfy.com/?q=markdown+cheat+sheet';&lt;/script&gt; 八、数学示例： 12345When `enable_mathjax` is `true`, inline math can be included $$\frac&#123;\pi&#125;&#123;2&#125;$$ $$\pi$$Alternatively, math can be written on its own line:$$F(\omega) = \frac&#123;1&#125;&#123;\sqrt&#123;2\pi&#125;&#125; \int_&#123;-\infty&#125;^&#123;\infty&#125; f(t) \, e^&#123; - i \omega t&#125;dt$$$$\int_0^1 f(t) \mathrm&#123;d&#125;t$$$$\sum_j \gamma_j^2/d_j$$ 效果： When enable_mathjax is true, inline math can be included $$\frac{\pi}{2}$$ $$\pi$$ Alternatively, math can be written on its own line: $$F(\omega) = \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{\infty} f(t) \, e^{ - i \omega t}dt$$ $$\int_0^1 f(t) \mathrm{d}t$$ $$\sum_j \gamma_j^2/d_j$$ 九、表格示例： 12345| Year | Temperature (low) | Temperature (high) || ---- | ----------------- | ------------------ || 1900 | -10 | 25 || 1910 | -15 | 30 || 1920 | -10 | 32 | 效果： Year Temperature (low) Temperature (high) 1900 -10 25 1910 -15 30 1920 -10 32]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora + MPic 快速编写Markdown博客]]></title>
    <url>%2F%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99Markdown%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[使用Typora，MPic结合七牛云快速编写Markdown博客 一、下载TyporaTypora是一款简单实时预览的Markdown编辑器，点击下载 二、下载MPicMPic是一款支持多种上传方式且自动生成MarkDown链接的图床工具，点击下载 三、注册七牛云账号1、 注册七牛云账号，我用的是126邮箱，之前申请账号使用qq邮箱，第二天才收邮箱激活通知 2、实名认证 3、创建空间 4、创建对象存储 5、记录外链默认域名，登录MPic时需要用到 6、记录AK和SK，登录MPic时需要用到 四、设置MPic图床神奇 五、上传图片到MPic1、直接拖拽或复制图片到MPic窗口 2、微信使用Alt + A进行截图 3、qq使用Ctrl + Alt + A进行截图]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>七牛云</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用技巧]]></title>
    <url>%2FIDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[一、设置IDEA默认设置 设置每次新建新项目时候的默认设置 二、设置自动导入包，清除没用的包 三、设置文件编码格式 四、使用Hierarchy查看类层次结构 Eclipse快键键下首次使用按下 F4（Navigate -&gt; Type Hierarchy），以后每次使用按 Alt + 8 五、使用快捷键移动分割线 使用 alt + 1 切换鼠标焦点在project中，然后通过 ctrl + shift + 左右箭头来移动分割线 六、解决控制台乱码 在idea根目录找到idea64.exe.vmoptions 在文件末尾添加-Dfile.encoding=UTF-8，保存重启idea即可~ 123456789101112-Xms128m-Xmx750m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-Dfile.encoding=UTF-8 七、项目结构中隐藏文件 IDEA 项目结构中会显示一些与项目无关的文件，如 .idea 和 *.iml 等文件 只需在 File -&gt; Settings -&gt; File Types 中的底部 ignore files and folders 添加 .idea;*.iml 即可隐藏]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微容购车计算器转购房计算器]]></title>
    <url>%2F%E5%BE%AE%E5%AE%B9%E8%B4%AD%E8%BD%A6%E8%AE%A1%E7%AE%97%E5%99%A8%E8%BD%AC%E8%B4%AD%E6%88%BF%E8%AE%A1%E7%AE%97%E5%99%A8.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>微容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-模板消息]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>模板消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装及简单使用]]></title>
    <url>%2FDocker.html</url>
    <content type="text"><![CDATA[一、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 二、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 三、安装Docker1）、安装linux虚拟机1）、VMWare、VirtualBox（安装）； 2）、导入虚拟机文件centos7-atguigu.ova； 3）、双击启动linux虚拟机;使用 root/ 123456登陆 4）、使用客户端连接linux服务器进行命令操作； 5）、设置虚拟机网络； 桥接网络===选好网卡====接入网线； 6）、设置好网络以后使用命令重启虚拟机的网络 service network restart 7）、查看linux的ip地址 ip addr 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 四、Docker常用命令&amp;操作1）、镜像操作 操 作 命令 说明 检 索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜 像的TAG。 拉 取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认 是latest 列 表 docker images 查看所有本地镜像 删 除 docker rmi image-id 删除指定的本地镜像 2）、容器操作根据镜像启动容器：docker run –name：为容器起名字 -d：在后台运行容器 -p：本机端口映射到容器端口 1docker run --name mytomcat -d tomcat:lastest -p 8080:8080 启动容器：docker start1docker start 容器的id 查看容器：docker ps -a：查看所有容器 1docker ps -a 停止容器：docker stop1docker stop 容器的id 删除容器：docker rm1docker rm 容器的id 进入容器：docker exec1docker exec -it 容器的id bash 退出容器：Ctrl+P+Q查看容器日志：docker logs -f -t1docker logs -f -t 容器的id 五、踩坑记录1、centos7 启动docker失败–selinux-enabled=falsecentos7，执行完安装命令： yum install docker 执行启动命令： systemctl start docker ，报下面错误： Error starting daemon: SELinux is not supported with the overlay2 graph driver on this kernel. Either boot into a newer kernel or disable selinux in docker (–selinux-enabled=false) 解决方案：重新编辑docker配置文件： 12345678910111213vi /etc/sysconfig/docker //vi编辑器编辑docker文件//修改 --selinux-enabled=false\# /etc/sysconfig/docker\# Modify these options if you want to change the way the docker daemon runsOPTIONS='--selinux-enabled=false --log-driver=journald --signature-verification=false'if [ -z "$&#123;DOCKER_CERT_PATH&#125;" ]; then DOCKER_CERT_PATH=/etc/dockerfi:wq //保存并退出systemctl restart docker //重启docker 参考：http://blog.51cto.com/10950710/2131803 2、用Navicat连接本机Docker的Mysql8.0参考：https://blog.csdn.net/gf0515/article/details/80466213]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发]]></title>
    <url>%2FSpring-Annotation.html</url>
    <content type="text"><![CDATA[一、组件注册 给容器中注册组件； 包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类] @Bean[导入的第三方包里面的组件] @Import[快速给容器中导入一个组件] @Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 ImportSelector:返回需要导入的组件的全类名数组； ImportBeanDefinitionRegistrar:手动注册bean到容器中 使用Spring提供的 FactoryBean（工厂Bean）; 默认获取到的是工厂bean调用getObject创建的对象 要获取工厂Bean本身，我们需要给id前面加一个&amp;colorFactoryBean （1）使用@Bean注解注入Bean@Configuration：标注一个类为配置类 @Bean：给容器中注入一个Bean，类型为返回值的类型，id默认使用Bean标注的方法名 1234567891011121314/** * 标注一个类为配置类 */@Configurationpublic class MainConfig &#123; /** * 给容器中注入一个Bean，类型为返回值的类型，id默认使用Bean标注的方法名 */ @Bean("nihao")//设置id名 public Person person() &#123; return new Person("Xieweicheng", 12); &#125;&#125; （2）使用@ComponentScan注解配置自动扫描组件1、@ComponentScan：自动扫描组件，包含以下四个注解@Controller、@Service、@Repository、@Component ①、常用属性： value：指定扫描的包 includeFilters：只扫描哪些 excludeFilters：排除扫描哪些 useDefaultFilters：是否使用默认Filter 123456@ComponentScan( value = "pers.mrxiexie.springannotation", includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;, excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Repository.class&#125;)&#125;, useDefaultFilters = false)public class MainConfig &#123; 2、使用@Filter设置过滤规则①、type属性 FilterType.ANNOTATION：按照注解 FilterType.ASSIGNABLE_TYPE：按照给定的类型 FilterType.ASPECTJ：ASPECTJ表达式 FilterType.REGEX：使用正则指定 FilterType.CUSTOM：使用自定义规则 ②、使用自定义规则 1234567@Configuration@ComponentScan( value = "pers.mrxiexie.springannotation", includeFilters = &#123;@ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFIlter.class&#125;)&#125;, //type指定FilterType.CUSTOM使用自定义规则，classes标注自定义规则的类 useDefaultFilters = false)public class MainConfig &#123;&#125; 1234567891011121314151617181920212223public class MyTypeFIlter implements TypeFilter &#123; /** * @param metadataReader 读取到的当前正在扫描的类的信息 * @param metadataReaderFactory 可以获取到其他任何类信息的 * @return 是否加入容器 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; //获取当前扫描类注解 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前扫描类的信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println("className : " + className); return className.contains("er"); &#125;&#125; （3）使用@Scope修改组件的作用域 ConfigurableBeanFactory#SCOPE_PROTOTYPE：多实例，ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象。 ConfigurableBeanFactory#SCOPE_SINGLETON：单实例（默认值），ioc容器启动会调用方法创建对象放到ioc容器中，以后每次获取就是直接从容器（map.get()）中拿， org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST：同一次请求创建一个实例 org.springframework.web.context.WebApplicationContext#SCOPE_SESSION：同一个Session创建一个实例 （4）使用@Lazy修改单实例第一次使用才加载1234567891011/** * 懒加载： * 单实例bean：默认在容器启动的时候创建对象； * 懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化； */@Lazy@Bean("person")public Person person()&#123; System.out.println("给容器中添加Person...."); return new Person("张三", 25);&#125; （5）使用@Conditional判断是够注入Bean标注在方法上：判断为true，注入该Bean12345@Conditional(WindowCondition.class)//当操作系统为Window时，注入该Bean@Beanpublic Person window() &#123; return new Person("Window", 11);&#125; 12345678910111213141516171819202122232425262728public class WindowCondition implements Condition &#123; /** * 判断是否为Window系统 * * @param context 判断条件能使用的上下文（环境） * @param metadata 注释信息 * @return 是否加入容器中 */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; //1、能获取到ioc使用的beanfactory ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //2、获取类加载器 ClassLoader classLoader = context.getClassLoader(); //3、获取当前环境信息 Environment environment = context.getEnvironment(); //4、获取到bean定义的注册类 BeanDefinitionRegistry registry = context.getRegistry(); String property = environment.getProperty("os.name"); //可以判断容器中的bean注册情况，也可以给容器中注册bean boolean definition = registry.containsBeanDefinition("person"); return property.contains("Windows"); &#125;&#125; 标注在类上：判断为true，注入类下所有Bean12345678910111213141516@Conditional(LinuxCondition.class)//当操作系统为Linux时，注入该类的所有Bean@Configurationpublic class MainConfig2 &#123;// @Conditional(WindowCondition.class) @Bean public Person window() &#123; return new Person("Window", 11); &#125;// @Conditional(LinuxCondition.class) @Bean public Person linux() &#123; return new Person("Linux", 11); &#125;&#125; 使用IDEA，修改当前操作系统属性 进入Edit Configuration 修改VM options值为 -Dos.name=Linux保存即可 （6）使用@Import注解注入Bean 在类上使用@Import(要导入容器的组件)，会自动注入该组件，其名默认为全类名 123@Import(Red.class) //注入Red组件，其名字为pers.mrxiexie.springannotation.bean.Red@Configurationpublic class MainConfig2 &#123;&#125; 使用ImportSelector，返回需要导入的组件的全类名数组 1234567891011121314@Import(&#123;Red.class, MyImportSelector.class&#125;)@Configurationpublic class MainConfig2 &#123;&#125;//自定义逻辑返回需要导入的组件public class MyImportSelector implements ImportSelector &#123; //返回值，就是到导入到容器中的组件全类名 //AnnotationMetadata:当前标注@Import注解的类的所有注解信息 @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;"pers.mrxiexie.springannotation.bean.Blue"&#125;; &#125;&#125; 使用ImportBeanDefinitionRegistrar，手动注册Bean到容器中 1234567891011121314151617181920212223242526@Import(&#123;Red.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)@Configurationpublic class MainConfig2 &#123;&#125;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * @param importingClassMetadata 当前类的注解信息 * @param registry BeanDefinition注册类； * 把所有需要添加到容器中的bean；调用 * BeanDefinitionRegistry.registerBeanDefinition手工注册进来 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean containRed = registry.containsBeanDefinition(Red.class.getName()); boolean containBlue = registry.containsBeanDefinition(Blue.class.getName()); if (containBlue &amp;&amp; containRed) &#123; //指定Bean定义信息；（Bean的类型，Bean。。。） RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Color.class); //注册一个Bean，指定bean名 registry.registerBeanDefinition("color", rootBeanDefinition); &#125; &#125;&#125; （7）使用Spring提供的 FactoryBean（工厂Bean）123456789101112131415161718192021222324252627282930313233343536/** * 创建一个Spring定义的FactoryBean */public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; //返回一个Color对象，这个对象会添加到容器中 @Override public Color getObject() throws Exception &#123; return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; //是单例？ //true：这个bean是单实例，在容器中保存一份 //false：多实例，每次获取都会创建一个新的bean； @Override public boolean isSingleton() &#123; return true; &#125;&#125;//注入ColorFactoryBean@Beanpublic FactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125;//获取ColorObject colorFactoryBean = ioc.getBean("colorFactoryBean");//获取ColorFactoryBeanObject colorFactoryBean = ioc.getBean(BeanFactory.FACTORY_BEAN_PREFIX + "colorFactoryBean"); 二、生命周期 bean的生命周期： bean创建—初始化—-销毁的过程容器管理bean的生命周期；我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法 （1）通过@Bean指定init-method和destroy-method1234567891011121314151617181920public class Car &#123; public Car()&#123; System.out.println("car's constructor"); &#125; public void init()&#123; System.out.println("init"); &#125; public void destroy()&#123; System.out.println("destroy"); &#125;&#125;//通过Bean注解的initMethod和destroyMethod指定Bean初始化方法和销毁方法@Bean(initMethod = "init", destroyMethod = "destroy")public Car car() &#123; return new Car();&#125; （2）通过让Bean实现InitializingBean（定义初始化逻辑）和DisposableBean（定义销毁逻辑）123456789101112131415161718public class Cat implements InitializingBean, DisposableBean &#123; public Cat()&#123; System.out.println("cat's constructor"); &#125; //Bean设置完属性后触发 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("init"); &#125; //Bean销毁时触发 @Override public void destroy() throws Exception &#123; System.out.println("destroy"); &#125;&#125; （3）通过可以使用JSR250，@PostConstruct和@PreDestroy @PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法 @PreDestroy：在容器销毁bean之前通知我们进行清理工作 123456789101112131415161718@Componentpublic class Dog &#123; public Dog()&#123; System.out.println("dog's constructor"); &#125; //Bean设置完属性后触发 @PostConstruct public void init()&#123; System.out.println("init ... postConstructor"); &#125; //Bean销毁时触发 @PreDestroy public void destroy()&#123; System.out.println("destroy ... preDestroy"); &#125;&#125; （4）BeanPostProcessor：bean的后置处理器 在Bean初始化前后进行一些处理工作 1234567891011121314151617@Componentpublic class MyBeanPostPrecessor implements BeanPostProcessor &#123; //在初始化之前工作，在initMethod和@PostConstruct前执行 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization : " + beanName); return bean; &#125; //在初始化之后工作，在initMethod和@PostConstruct后执行 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessAfterInitialization : " + beanName); return bean; &#125;&#125; 执行原理 挨个执行beforeInitialization，一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization 1234567891011//给bean进行属性赋值populateBean(beanName, mbd, instanceWrapper);initializeBean&#123; //执行所有postProcessBeforeInitialization方法 applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); //执行自定义初始化,initMethod和@PostConstruct invokeInitMethods(beanName, wrappedBean, mbd); //执行所有postProcessAfterInitialization方法 applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&#125; （5）执行顺序 构造器 后置处理器，BeanPostPrecessor.postProcessBeforeInitialization @PostConstruct 标注的方法 实现InitializingBean接口，afterPropertiesSet @Bean属性，initMethod 后置处理器，BeanPostPrecessor.postProcessAfterInitialization @PreDestroy 标注的方法 实现DisposableBean接口，destroy @Bean属性，destroyMethod 三、属性赋值使用@value进行赋值 基础赋值 12@Value("MrXieXie")String name; 可以写SpEL； #{} 12@Value("#&#123;20-2&#125;")int age; 使用@PropertySource导入配置文件，可以写${}；取出配置文件【properties】中的值（在运行环境变量里面的值） 1234567891011//导入resources下的person.properties配置文件@PropertySource("classpath:person.properties")@Configurationpublic class MainConfigOfPropertyValues &#123;&#125;//person.propertiesperson.nickname=你好啊//Person.java@Value("$&#123;person.nickname&#125;")String nickName; 四、自动装配（1）使用@Autowired，装配容器中的Bean Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值； @Autowired：自动注入： 1）、默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值 2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找applicationContext.getBean(&quot;bookDao&quot;) 3）、@Qualifier(“bookDao”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名 4）、自动装配默认一定要将属性赋值好，没有就会报错；可以使用@Autowired(required=false); 5）、@Primary：让Spring进行自动装配的时候，默认使用首选的bean；也可以继续使用@Qualifier指定需要装配的bean的名字 12345678910111213141516//MyDao.java@Repositorypublic class MyDao &#123;&#125;//MyService.java@Servicepublic class MyService &#123; //自动装配MyDao，若容器中没有该Bean，会报错，可以使用require属性设置为false，可以不注入该Bean @Autowired MyDao myDao; public void print()&#123; System.out.println(myDao); &#125;&#125; （2）使用@Qualifier指定装配指定id的Bean 若容器中含有多个相同的Bean，默认使用标注了@Autowired注解的属性名为id的Bean 也可以使用@Qualifier来装配指定id的Bean 123456@Autowired //若有多个相同的bean，默认装载id为 mydao 的beanMyDao myDao;@Qualifier("mydao2") //使用@Qualifier，装配id为 mydao2 的Bean@AutowiredMyDao myDao; （3）使用@Primary，默认使用首选的bean 也可以继续使用@Qualifier指定需要装配的bean的名字 1234567@Primary@Bean("mydao2")public MyDao myDao()&#123; MyDao myDao = new MyDao(); myDao.setLable(2); return myDao;&#125; （4）@Autowired与@Resource与@Inject的区别 Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解] @Resource：可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的；没有能支持@Primary功能没有支持@Autowired（reqiured=false）; @Inject：需要导入javax.inject的包，和Autowired的功能一样。没有required=false的功能； @Autowired：Spring定义的； @Resource、@Inject都是java规范 AutowiredAnnotationBeanPostProcessor:解析完成自动装配功能； @Autowired @Resource @Inject 依赖注入 支持 支持 支持 @Primary 支持 不支持 支持 @Qualifier 支持 不支持 支持 required=false 支持 不支持 不支持 （5） @Autowired:构造器，参数，方法，属性；都是从容器中获取参数组件的值 1）、标注在方法位置：@Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配 2）、标在构造器上：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取 3）、放在参数位置： （6）自定义组件想要使用Spring容器底层的一些组件 自定义组件如何获取ApplicationContext，BeanFactory，xxx 自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件； Aware；把Spring底层一些组件注入到自定义的Bean中；xxxAware：功能使用xxxProcessor； 如：ApplicationContextAware —&gt; ApplicationContextAwareProcessor（后置处理器）； 12345678910111213141516171819202122232425/** * 在Red中使用&#123;@link ApplicationContext,StringValueResolver,Environment&#125; */@Componentpublic class Red implements ApplicationContextAware, EmbeddedValueResolverAware, EnvironmentAware &#123; //获取IOC容器 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println(applicationContext); &#125; //获取字符串处理器 @Override public void setEmbeddedValueResolver(StringValueResolver resolver) &#123; String s = resolver.resolveStringValue("你好我是$&#123;os.name&#125;，今年#&#123;20-2&#125;"); System.out.println(s); &#125; //IOC运行环境 @Override public void setEnvironment(Environment environment) &#123; System.out.println(environment.getProperty("os.name")); &#125;&#125; 执行原理 1234567891011121314151617//ApplicationContextAwareProcessor后置处理器//调用初始化方法前执行@Overridepublic Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123; //.. invokeAwareInterfaces(bean); //..&#125;private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof ApplicationContextAware) &#123; //回调给实现了ApplicationContextAware接口的类的setApplicationContext方法。 ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; （7）@Profile环境切换Profile：Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能； @Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件 1）、加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境 2）、写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效 3）、没有标注环境标识的bean在，任何环境下都是加载的； 定义环境：开发环境、测试环境、生产环境 1234567891011121314//测试环境@Profile("test") @Bean("test") public DataSource testDataSource()&#123;&#125;//开发环境 @Profile("dev") @Bean("dev") public DataSource devDataSource()&#123;&#125;//生成环境 @Profile("prod") @Bean("prod") public DataSource prodDataSource()&#123;&#125; 切换环境 使用命令行动态参数: 在虚拟机参数位置加载 -Dspring.profiles.active=test； 代码的方式激活某种环境； 123456789AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();//1、创建一个applicationContext//2、设置需要激活的环境applicationContext.getEnvironment().setActiveProfiles("dev");//3、注册主配置类applicationContext.register(MainConfigOfProfile.class);//4、启动刷新容器applicationContext.refresh(); 五、AOP功能及原理（1）AOP基础使用 AOP：指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式； 导入aop模块；Spring AOP：(spring-aspects) 1compile 'org.springframework:spring-aspects:4.3.12.RELEASE' 定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx） 123456public class MathCalculator &#123; public int div(int x, int y) &#123; System.out.println("div"); return x / y; &#125;&#125; 定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；通知方法： 前置通知(@Before)：logStart：在目标方法(div)运行之前运行 后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束） 返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行 异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行 环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()） 1234567891011121314151617181920212223242526/** * 告诉Spring这是一个切面类 */@Aspectpublic class LogAspects &#123; //抽取公共的切入点表达式 //1、本类引用 //2、其他的切面引用 @Pointcut(value = "execution(public int pers.mrxiexie.springannotation.aop.MathCalculator.*(..))") public void pointcut() &#123;&#125; //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入） @Before("pointcut()") public void before(JoinPoint joinPoint) &#123;&#125; @After("pointcut()") public void after(JoinPoint joinPoint) &#123;&#125; //JoinPoint一定要出现在参数表的第一位 @AfterReturning(value = "pointcut()", returning = "obj") public void afterReturning(JoinPoint joinPoint, Object obj) &#123;&#125; @AfterThrowing(value = "pointcut()", throwing = "e") public void exception(JoinPoint joinPoint, Exception e) &#123;&#125;&#125; 将切面类和业务逻辑类（目标方法所在类）都加入到容器中; 123456789101112131415//开启基于注解的aop模式@EnableAspectJAutoProxy@Configurationpublic class MainConfigOfAOP &#123; @Bean public LogAspects logAspects()&#123; return new LogAspects(); &#125; @Bean public MathCalculator calculator()&#123; return new MathCalculator(); &#125;&#125; （2）AOP源码分析2.1 首先先从@EnableAspectJAutoProxy分析 从@EnableAspectJAutoProxy注解入手 1@EnableAspectJAutoProxy @Import(AspectJAutoProxyRegistrar.class) 注解注入 AspectJAutoProxyRegistrar 12@Import(AspectJAutoProxyRegistrar.class)public @interface EnableAspectJAutoProxy &#123;&#125; AspectJAutoProxyRegistrar 实现了 ImportBeanDefinitionRegistrar：手动注册Bean到容器中 12345678910111213141516171819class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //给容器注册一个AnnotationAwareAspectJAutoProxyCreator //名为org.springframework.aop.config.internalAutoProxyCreator AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); &#125; if (enableAspectJAutoProxy.getBoolean("exposeProxy")) &#123; AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); &#125; &#125;&#125; 4、查看ImportBeanDefinitionRegistrar的继承树 ProxyConfig (org.springframework.aop.framework) ProxyProcessorSupport (org.springframework.aop.framework) AbstractAutoProxyCreator (org.springframework.aop.framework.autoproxy) AbstractAdvisorAutoProxyCreator (org.springframework.aop.framework.autoproxy) AspectJAwareAdvisorAutoProxyCreator (org.springframework.aop.aspectj.autoproxy) AnnotationAwareAspectJAutoProxyCreator (org.springframework.aop.aspectj.annotation) 可以看出 AbstractAutoProxyCreator (org.springframework.aop.framework.autoproxy) 实现了： SmartInstantiationAwareBeanPostProcessor 后置处理器 BeanFactoryAware 自动装配BeanFactory 关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory AbstractAutoProxyCreator.setBeanFactory() AbstractAutoProxyCreator.有后置处理器的逻辑 AbstractAdvisorAutoProxyCreator.setBeanFactory() -&gt; initBeanFactory() AnnotationAwareAspectJAutoProxyCreator.initBeanFactory() 结论：@EnableAspectJAutoProxy给容器注册一个AnnotationAwareAspectJAutoProxyCreator 2.2 从AnnotationAwareAspectJAutoProxyCreator创建到注册流程分析 注册配置类，调用refresh()刷新容器 12345public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123; this(); register(annotatedClasses); //注册配置类 refresh(); //刷新容器&#125; 调用registerBeanPostProcessors()注册拦截bean创建的bean处理器 1234567891011@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; try &#123; //.. // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); //.. &#125; &#125;&#125; 调用registerBeanPostProcessors()方法注册后置处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; //先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; //添加其他BeanPostProcessor到容器中 beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); //区分哪些BeanPostProcessor实现了PriorityOrdered, Ordered, and the rest接口 List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // 首先注册实现了PriorityOrdered接口的BeanPostProcessor sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // 下一步，注册实现了Ordered接口的BeanPostProcessor // 注意：AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口 List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : orderedPostProcessorNames) &#123; //获取名字为org.springframework.aop.config.internalAutoProxyCreator的BeanPostProcessor //实际是就是获取AnnotationAwareAspectJAutoProxyCreator到第4步创建Bean BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // 最后注册剩余的所有BeanPostProcessor List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // 最后把BeanPostProcessor注册到BeanFactory中； sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125; 创建Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //创建PostBeanProcessor对象 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; //给Bean的属性赋值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; //初始化Bean exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; //..&#125; 初始化Bean 123456789101112131415161718192021222324252627282930313233343536protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; //处理Aware接口的方法回调，到第6步 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //调用所有后置处理器的postProcessBeforeInitialization wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //执行自定义初始化方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //调用所有后置处理器的postProcessAfterInitialization wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 处理Aware接口的方法回调 123456789101112131415private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; //AnnotationAwareAspectJAutoProxyCreator实现了BeanFactoryAware接口 //执行setBeanFactory方法 ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 执行setBeanFactory()方法 12345678910111213141516171819public void setBeanFactory(BeanFactory beanFactory) &#123; super.setBeanFactory(beanFactory); if (!(beanFactory instanceof ConfigurableListableBeanFactory)) &#123; throw new IllegalArgumentException( "AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: " + beanFactory); &#125; //BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；aspectJAdvisorsBuilder initBeanFactory((ConfigurableListableBeanFactory) beanFactory);&#125;@Overrideprotected void initBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; super.initBeanFactory(beanFactory); if (this.aspectJAdvisorFactory == null) &#123; this.aspectJAdvisorFactory = new ReflectiveAspectJAdvisorFactory(beanFactory); &#125; this.aspectJAdvisorsBuilder = new BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, this.aspectJAdvisorFactory);&#125; 2.3 从AnnotationAwareAspectJAutoProxyCreator执行流程分析 调用finishBeanFactoryInitialization()方法 1234567@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); &#125;&#125; 调用beanFactory.preInstantiateSingletons()方法 12345protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; //. // Instantiate all remaining (non-lazy-init) singletons. beanFactory.preInstantiateSingletons();&#125; 遍历获取容器中所有的Bean，依次创建对象getBean(beanName) 12//先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来getBean -&gt; doGetBean() -&gt; getSingleton() 调用createBean()方法 12345678910111213141516171819@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; //.. try &#123; //创建Bean实例之前先尝试用后置处理器返回对象的 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; //.. //创建Bean，跟创建后置处理器的流程一样（2.2第四条） Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug("Finished creating instance of bean '" + beanName + "'"); &#125; return beanInstance;&#125; AnnotationAwareAspectJAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor接口（InstantiationAwareBeanPostProcessor），会在Bean创建示例之前尝试使用该后置处理器创建对象。 12345678910111213141516171819202122232425262728293031323334353637protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) &#123; /** * SmartInstantiationAwareBeanPostProcessor继承InstantiationAwareBeanPostProcessor接口 * 执行所有实现了InstantiationAwareBeanPostProcessor接口的后置处理器的postProcessBeforeInstantiation方法 */ bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; //执行所有实现了InstantiationAwareBeanPostProcessor接口的后置处理器的postProcessAfterInitialization方法 bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = (bean != null); &#125; return bean;&#125;protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; //若实现了InstantiationAwareBeanPostProcessor接口，则执行postProcessBeforeInstantiation或者postProcessAfterInitialization方法尝试创建实例 if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null;&#125; 2.4 AnnotationAwareAspectJAutoProxyCreator（InstantiationAwareBeanPostProcessor）作用分析 AnnotationAwareAspectJAutoProxyCreator的postProcessBeforeInstantiation()方法。每个Bean创建之前，调用该方法。 12345678910111213141516171819202122232425262728293031323334@Overridepublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.contains(beanName)) &#123; //判断当前bean是否在advisedBeans中（保存了所有需要增强bean） if (this.advisedBeans.containsKey(cacheKey)) &#123; return null; &#125; //1. isInfrastructureClass(beanClass): 判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect） //2. shouldSkip(beanClass, beanName)): 是否需要跳过 if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. if (beanName != null) &#123; TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) &#123; this.targetSourcedBeans.add(beanName); Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; &#125; return null;&#125; shouldSkip(beanClass, beanName)): 是否需要跳过 123456789101112131415@Overrideprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) &#123; //获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor； List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); for (Advisor advisor : candidateAdvisors) &#123; //判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true if (advisor instanceof AspectJPointcutAdvisor) &#123; if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123; return true; &#125; &#125; &#125; //返回false return super.shouldSkip(beanClass, beanName);&#125; 创建对象，调用postProcessAfterInitialization()方法 1234567891011@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean != null) &#123; Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) &#123; //包装对象，如果在需要的情况下 return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean;&#125; 调用wrapIfNecessary()方法 123456789101112131415161718192021222324252627protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // 获取当前bean的所有增强器（通知方法） Object[] specificInterceptors（第5步） Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; //如果有代理则把当前Bean加入到advisedBeans并设置为true， this.advisedBeans.put(cacheKey, Boolean.TRUE); //创建代理对象（第6步） Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; //否则为false this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 调用getAdvicesAndAdvisorsForBean()方法，获取当前bean的所有增强器（通知方法） Object[] specificInterceptors 12345678910111213141516171819202122@Overrideprotected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123; List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) &#123; return DO_NOT_PROXY; &#125; return advisors.toArray();&#125;protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; //找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的） List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); //获取到能在bean使用的增强器。 List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; //给增强器排序 eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 创建代理对象，调用createProxy()方法 1234567891011121314151617181920212223242526272829303132rotected Object createProxy( Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123; if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123; AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); &#125; ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) &#123; if (shouldProxyTargetClass(beanClass, beanName)) &#123; proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; //获取所有增强器（通知方法） Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); //把增强器添加到工厂中 proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; //创建代理对象 return proxyFactory.getProxy(getProxyClassLoader());&#125; 创建AOP代理对象，getProxy() 一直调用到 createAopProxy()创建AOP代理对象 ，最后给容器中返回当前组件使用cglib增强了的代理对象；以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程。两种AOP代理对象： JdkDynamicAopProxy ObjenesisCglibAopProxy 1234567891011121314151617@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException("TargetSource cannot determine target class: " + "Either an interface or a target is required for proxy creation."); &#125; if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125;&#125; 2.5 AOP代理对象方法执行源码分析 首先执行intercept()拦截目标方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; Class&lt;?&gt; targetClass = null; Object target = null; try &#123; if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // May be null. Get as late as possible to minimize the time we // "own" the target, in case it comes from a pool... target = getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; //根据ProxyFactory对象获取将要执行的目标方法拦截器链；(第2步) List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); Object retVal; //如果没有拦截器链，直接执行目标方法 if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); //执行目标方法 retVal = methodProxy.invoke(target, argsToUse); &#125; //如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个 CglibMethodInvocation 对象，并调用 Object retVal = mi.proceed(); else &#123; // 执行拦截器链 retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); &#125; retVal = processReturnType(proxy, target, method, retVal); return retVal; &#125; finally &#123; if (target != null) &#123; releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 根据ProxyFactory对象获取将要执行的目标方法拦截器链（getInterceptorsAndDynamicInterceptionAdvice） 12345678910public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) &#123; MethodCacheKey cacheKey = new MethodCacheKey(method); List&lt;Object&gt; cached = this.methodCache.get(cacheKey); if (cached == null) &#123; cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this, method, targetClass); this.methodCache.put(cacheKey, cached); &#125; return cached;&#125; 调用getInterceptorsAndDynamicInterceptionAdvice()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overridepublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, Class&lt;?&gt; targetClass) &#123; //保存所有的拦截器，一个默认的ExposeInvocationInterceptor 和 4个增强器 List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length); Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); boolean hasIntroductions = hasMatchingIntroductions(config, actualClass); AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); for (Advisor advisor : config.getAdvisors()) &#123; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123; //遍历所有的增强器，将其转为Interceptor(第4步) MethodInterceptor[] interceptors = registry.getInterceptors(advisor); MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123; if (mm.isRuntime()) &#123; // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor) &#123; IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList;&#125; 将增强器转为MethodInterceptor 1234567891011121314151617181920@Overridepublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3); Advice advice = advisor.getAdvice(); //如果是MethodInterceptor，直接加入到集合中 if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor) advice); &#125; //如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor for (AdvisorAdapter adapter : this.adapters) &#123; if (adapter.supportsAdvice(advice)) &#123; interceptors.add(adapter.getInterceptor(advisor)); &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; //转换完成返回MethodInterceptor数组 return interceptors.toArray(new MethodInterceptor[interceptors.size()]);&#125; 2.6 执行拦截器链new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); 执行proceed方法 12345678910111213141516171819202122232425262728@Overridepublic Object proceed() throws Throwable &#123; // 如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法 //currentInterceptorIndex一开始为-1 if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; return invokeJoinpoint(); &#125; //按顺序获取拦截器从0开始 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. return proceed(); &#125; &#125; else &#123; ////链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；拦截器链的机制，保证通知方法与目标方法的执行顺序； return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; （3）AOP总结 @EnableAspectJAutoProxy 开启AOP功能 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator AnnotationAwareAspectJAutoProxyCreator是一个后置处理器； 容器的创建流程： registerBeanPostProcessors()注册后置处理器 创建AnnotationAwareAspectJAutoProxyCreator对象 finishBeanFactoryInitialization()初始化剩下的单实例bean 创建业务逻辑组件和切面组件 AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程 组件创建完之后，判断组件是否需要增强 是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib） 执行目标方法： 代理对象执行目标方法 CglibAopProxy.intercept()； 得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor） 利用拦截器的链式机制，依次进入每一个拦截器进行执行； 效果： 正常执行：前置通知-》目标方法-》后置通知-》返回通知 出现异常：前置通知-》目标方法-》后置通知-》异常通知 六、声明式事务（1）环境搭建 1、导入相关依赖 数据源、数据库驱动、Spring-jdbc模块 2、配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据 3、给方法上标注 @Transactional 表示当前方法是一个事务方法； 4、 @EnableTransactionManagement 开启基于注解的事务管理功能； 5、配置事务管理器来控制事务; public PlatformTransactionManager transactionManager() （2）源码分析 @EnableTransactionManagement 123456@Import(TransactionManagementConfigurationSelector.class)public @interface EnableTransactionManagement &#123; //.. AdviceMode mode() default AdviceMode.PROXY; //..&#125; TransactionManagementConfigurationSelector 1234567891011121314public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; &#123; @Override protected String[] selectImports(AdviceMode adviceMode) &#123; switch (adviceMode) &#123; case PROXY: //默认情况下，导入AutoProxyRegistrar（第3步）和ProxyTransactionManagementConfiguration（第4步）两个类 return new String[] &#123;AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()&#125;; case ASPECTJ: return new String[] &#123;TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;; default: return null; &#125; &#125;&#125; AutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，手动注册Bean 12345678910111213141516171819202122232425262728293031public class AutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean candidateFound = false; Set&lt;String&gt; annoTypes = importingClassMetadata.getAnnotationTypes(); for (String annoType : annoTypes) &#123; AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType); if (candidate == null) &#123; continue; &#125; Object mode = candidate.get("mode"); Object proxyTargetClass = candidate.get("proxyTargetClass"); if (mode != null &amp;&amp; proxyTargetClass != null &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp; Boolean.class == proxyTargetClass.getClass()) &#123; candidateFound = true; if (mode == AdviceMode.PROXY) &#123; //通过AopConfigUtils工具注册InfrastructureAdvisorAutoProxyCreator组件 //InfrastructureAdvisorAutoProxyCreator，利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；（同AOP的AnnotationAwareAspectJAutoProxyCreator） AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry); if ((Boolean) proxyTargetClass) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); return; &#125; &#125; &#125; &#125; //.. &#125;&#125; ProxyTransactionManagementConfiguration 12345678910111213141516171819202122232425262728293031323334@Configurationpublic class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123; //注册事务增强器 @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() &#123; BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor(); advisor.setTransactionAttributeSource(transactionAttributeSource()); advisor.setAdvice(transactionInterceptor()); advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber("order")); return advisor; &#125; //注册AnnotationTransactionAttributeSource解析事务注解 @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionAttributeSource transactionAttributeSource() &#123; return new AnnotationTransactionAttributeSource(); &#125; //注册事务拦截器 @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionInterceptor transactionInterceptor() &#123; TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionAttributeSource(transactionAttributeSource()); if (this.txManager != null) &#123; interceptor.setTransactionManager(this.txManager); &#125; return interceptor; &#125;&#125; TransactionAspectSupport.invokeWithinTransaction执行目标方法 123456789101112131415161718192021222324252627282930protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123; // If the transaction attribute is null, the method is non-transactional. final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass); final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try &#123; //执行目标方法 retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; //出现异常则回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; //提交事务 commitTransactionAfterReturning(txInfo); return retVal; &#125; //..&#125; 七、扩展原理（1）BeanFactoryPostProcessor BeanFactoryPostProcessor：BeanFactory的后置处理器 在标准初始化之后，修改应用上下文内部的BeanFactory。所有的bean定义信息都已经加载，但是没有bean被初始化。 （2）BeanDefinitionRegistryPostProcessor BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子接口 在标准初始化之后，修改应用上下文中的bean定义注册表。将加载所有常规bean定义，但是没有bean被初始化。这允许在下一个后处理阶段开始之前添加更多bean定义。 先执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法 再执行BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法 然后执行BeanFactoryPostProcessor的postProcessBeanFactory()方法 最后bean才初始化 源码分析： 创建ioc容器并刷新容器，调用refresh()方法 123456789101112131415161718192021222324252627282930313233@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); //在上下文中调用注册为bean的工厂处理器 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); //初始化所有的单实例Bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; &#125;&#125; invokeBeanFactoryPostProcessors(beanFactory); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123; // 如果有，先调用BeanDefinitionRegistryPostProcessors Set&lt;String&gt; processedBeans = new HashSet&lt;String&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; //常规beanfactory后置处理器列表 List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;BeanFactoryPostProcessor&gt;(); //注册表beanfactory后置处理器列表 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;(); for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; //分别将BeanDefinitionRegistryPostProcessor和常规BeanFactoryPostProcessor放在对应的列表 if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; // 按顺序执行实现了Ordered, Ordered, 和 没有实现接口的BeanDefinitionRegistryPostProcessorsPriority接口的方法 List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;(); // 第一，先执行实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 第二，执行实现了Ordered接口的BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法 postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 最后，执行没有实现接口的BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法 boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); &#125; // 执行BeanDefinitionRegistryPostProcessors的postProcessBeanFactory方法 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); &#125; //这里不初始化factorybean吗: 我们需要保留所有未初始化的常规bean，以便让bean工厂后处理器应用到它们! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // 按顺序执行实现了Ordered, Ordered, 和 没有实现接口的BeanFactoryPostProcessor接口的方法 List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // 跳过 已在第一阶段以上处理 &#125; else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // 第一, 先执行实现了PriorityOrdered接口的BeanFactoryPostProcessors的postProcessBeanFactory方法 sortPostProcessors(priorityOrderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // 第二, 执行实现了Ordered接口的BeanFactoryPostProcessors的postProcessBeanFactory方法 List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // 最后，执行实现了没有实现接口的BeanFactoryPostProcessors的postProcessBeanFactory方法 List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanFactoryPostProcessor&gt;(); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache();&#125; （3）ApplicationListener 监听容器中发布的事件，事件驱动模型开发 12345678910/** * 实现ApplicationListener接口，监听ApplicationEvent事件 */@Componentpublic class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; System.out.println("收到了事件 : " + event); &#125;&#125; 自定义发布事件 1234567@Testpublic void test() &#123; ApplicationContext ioc = new AnnotationConfigApplicationContext(ExtConfig.class); //自定义发布事件 ioc.publishEvent("asd"); ((AnnotationConfigApplicationContext) ioc).close();&#125; 执行结果打印 123收到了事件 : org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@612fc6eb: startup date [Tue Aug 21 11:33:08 CST 2018]; root of context hierarchy]收到了事件 : org.springframework.context.PayloadApplicationEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@612fc6eb: startup date [Tue Aug 21 11:33:08 CST 2018]; root of context hierarchy]收到了事件 : org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@612fc6eb: startup date [Tue Aug 21 11:33:08 CST 2018]; root of context hierarchy] 源码分析： 刷新IOC容器 123456789101112131415161718@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; try &#123; //.. // 为这个上下文初始化事件派发器。（第2步） initApplicationEventMulticaster(); //.. // 检查监听器并注册。（第3步） registerListeners(); //.. // 发布相应的事件。 finishRefresh(); &#125; &#125;&#125; 初始化事件多播器（派发器）applicationEventMulticaster，若容器中没有则创建一个SimpleApplicationEventMulticaster 12345678910111213141516171819protected void initApplicationEventMulticaster() &#123; ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123; this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); if (logger.isDebugEnabled()) &#123; logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]"); &#125; &#125; //若容器中没有APPLICATION_EVENT_MULTICASTER_BEAN_NAME，则创建一个SimpleApplicationEventMulticaster，并添加到容器中，我们就可以在其他组件要派发事件，自动注入这个applicationEventMulticaster； else &#123; this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); if (logger.isDebugEnabled()) &#123; logger.debug("Unable to locate ApplicationEventMulticaster with name '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "': using default [" + this.applicationEventMulticaster + "]"); &#125; &#125; 检查监听器并注册 12345678910111213141516171819202122protected void registerListeners() &#123; // 从容器中拿到所有的监听器，把他们注册到applicationEventMulticaster中 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener); &#125; // 不要在这里初始化factorybean:我们需要保留所有未初始化的常规bean，让后处理器应用到它们! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // 现在我们终于有了一个事件派发器，发布了早期的应用程序事件 Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; //发布了早期的应用程序事件 getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125;&#125; publishEvent -&gt; multicastEvent 发布事件 1234567891011121314151617181920@Overridepublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; Executor executor = getTaskExecutor(); // 如果有Executor，可以支持使用Executor进行异步派发 if (executor != null) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; invokeListener(listener, event); &#125; &#125;); &#125; else &#123; // 否则，同步的方式直接执行listener方法 invokeListener(listener, event); &#125; &#125;&#125; （4）@EventListener 使用该注解实现在某个方法中收取事件，而不需要类实现ApplicationListener 1234567@Servicepublic class BookService &#123; @EventListener(classes = &#123;ApplicationEvent.class&#125;) public void received(ApplicationEvent event) &#123; System.out.println("收到了监听 ： " + event); &#125;&#125; 源码分析： @EventListener 123456 * @see EventListenerMethodProcessor // 查看EventListenerMethodProcessor~ */@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EventListener &#123; 查看EventListenerMethodProcessor，实现了SmartInitializingSingleton接口 1public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware &#123; SmartInitializingSingleton接口 123public interface SmartInitializingSingleton &#123; void afterSingletonsInstantiated();&#125; refresh() -&gt; finishBeanFactoryInitialization(beanFactory) -&gt; beanFactory.preInstantiateSingletons(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overridepublic void preInstantiateSingletons() throws BeansException &#123; //.. // 触发所有非惰性单例bean的初始化。 for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; if (isFactoryBean(beanName)) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; // 先创建所有的单实例bean；getBean(); getBean(beanName); &#125; &#125; &#125; // 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的；如果是就调用afterSingletonsInstantiated(); for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo结合GitPages搭建博客]]></title>
    <url>%2FHexo%E7%BB%93%E5%90%88GitPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[前言 在接触Hexo之前，一直在使用印象笔记记录笔记，但是由于印象笔记一直不支持Markdown语法，只能通过马克飞象（专为印象笔记打造，要收费，果断卸载）或者SublimeText（上传后样式太丑，自定义太蛋疼，果断抛弃）。后来发现了Hexo，一款快速、简洁且高效的博客框架，支持Markdown语法，并且可以结合GitPages，存储在Github上，不需要另外购买云主机，最终决定使用Hexo创建一个属于自己的博客，记录工作学习中的笔记。 一、Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 二、下载Cmdercmder是window下一款替代默认cmd的命令行界面，其分为Mini版和Full版： Mini版：仅仅替代cmd Full版：包含git命令等功能 1、进入cmder官网，GitPages需要使用git命令上传，需要下载Full版 2、下载完成后解压双击cmder.exe即可使用，打开界面如下： 三、下载Node.js1、Hexo基于Node.js，进入Node.js下载左边最多用户使用的即可 2、默认安装即可 四、安装Hexo1、在cmder下输入如下命令，等待安装完毕即可 1npm install -g hexo-cli 五、初始化Hexo1、在cmder下输入如下命令初始化Hexo &lt;folder&gt;为自定义文件夹名字 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 此过程有点久，耐心等待安装完成即可~ 2、本地浏览博客，依次输入以下命令 12hexo ghexo s 3、最后打开浏览器输入127.0.0.1:4000，查看我们所搭建的博客吧 4、配置主题，发表文章不是本文的重点，更多详情，请参阅官方文档 六、部署到Github上1、登录Github官网，注册账号 2、创建一个新的项目 3、设置仓库名与用户名一致的前缀，后缀为.github.io 举个栗子：我的用户名为MrXieXie，则仓库应该命名为MrXieXie.github.io 4、点击Create repository按钮完成创建 5、获取仓库地址 6、配置_config.yml 7、安装git自动部署发布工具 1npm install hexo-deployer-git --save 8、发布到github（发布前习惯先hexo clean清空缓存文件），第一次登陆需要输入github的账号密码 1hexo deploy 9、最后，打开浏览器输入xieweicheng.github.io就可以访问我的博客了 七、使用自己的域名（可选）1、首先要先有自己的域名，可以在阿里云，腾讯云自行购买 2、在Hexo，source文件夹下创建CNAME文件，并修改内容为你的域名，重新部署到github上 1你的域名 3、解析域名指向你的github名字.github.io即可通过你的域名访问博客了 以阿里云为例 1、进入阿里云后台，找到域名列表，点击解析按钮解析你的域名 2、点击添加记录 3、添加一条新的记录，记录类型选择CNAME，记录值为你的github名.github.io 4、点击确定，稍等一段时间即可通过你的域名访问你的Hexo博客]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
